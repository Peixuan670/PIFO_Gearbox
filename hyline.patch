diff -rpuN ns-allinone-2.34.base/ns-2.34/classifier/classifier.cc ns-allinone-2.34.hyline/ns-2.34/classifier/classifier.cc
--- ns-allinone-2.34.base/ns-2.34/classifier/classifier.cc	2009-06-14 13:35:07.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/classifier/classifier.cc	2016-05-01 17:02:22.000000000 -0400
@@ -50,6 +50,11 @@ public:
 	}
 } class_classifier;
 
+void Classifier::pfcmessage(int ntoNodeid,int npriority,int nduration)
+{
+
+}
+
 
 Classifier::Classifier() : 
 	slot_(0), nslot_(0), maxslot_(-1), shift_(0), mask_(0xffffffff), nsize_(0)
@@ -101,7 +106,7 @@ void Classifier::alloc(int slot)
 }
 
 
-void Classifier::install(int slot, NsObject* p)
+void Classifier::install(int slot, NsObject* p,int ntoNodeid)
 {
 	if (slot >= nslot_)
 		alloc(slot);
@@ -142,6 +147,7 @@ int Classifier::getnxt(NsObject *nullage
 void Classifier::recv(Packet* p, Handler*h)
 {
 	NsObject* node = find(p);
+	DBGMARK(DBGPFC,4,"@ %s: rcv...target:%s\n",this->name(),node->name());
 	if (node == NULL) {
 		/*
 		 * XXX this should be "dropped" somehow.  Right now,
@@ -162,6 +168,7 @@ NsObject* Classifier::find(Packet* p)
 {
 	NsObject* node = NULL;
 	int cl = classify(p);
+	DBGMARK(DBGPFC,4,"@ %s: cl:%d nslot_:%d PFC sts...\n",this->name(),cl,nslot_);
 	if (cl < 0 || cl >= nslot_ || (node = slot_[cl]) == 0) { 
 		if (default_target_) 
 			return default_target_;
@@ -182,7 +189,7 @@ NsObject* Classifier::find(Packet* p)
 	return (node);
 }
 
-int Classifier::install_next(NsObject *node) {
+int Classifier::install_next(NsObject *node, int ntoNode) {
 	int slot = maxslot_ + 1;
 	install(slot, node);
 	return (slot);
@@ -191,6 +198,7 @@ int Classifier::install_next(NsObject *n
 int Classifier::command(int argc, const char*const* argv)
 {
 	Tcl& tcl = Tcl::instance();
+	DBGMARK(DBGCLS,4,"argv[1]:%s, argc:%d\n",argv[1],argc);
 	if(argc == 2) {
                 if (strcmp(argv[1], "defaulttarget") == 0) {
                         if (default_target_ != 0)
@@ -286,5 +294,49 @@ int Classifier::command(int argc, const
 			return (TCL_OK);
 		}
 	}
+	else if (strcmp(argv[1], "pfcmessage") == 0)
+	{
+		if(argc == 5)
+		{
+			int ntoNodeid = atoi(argv[2]);
+			int npriority = atoi(argv[3]);
+			int nduration = atoi(argv[4]);
+			DBGMARK(1,1,"ntoNodeid_:%d priority:%d duration:%d\n",ntoNodeid,npriority,nduration);
+			pfcmessage(ntoNodeid,npriority,nduration);
+			return TCL_OK;
+		}
+	}
+
 	return (NsObject::command(argc, argv));
 }
+
+
+int Classifier::CheckState(Packet* p)
+{
+	DBGMARK(DBGPFC,4,"now:%f, pkt:%p @ %s: Checking PFC sts...\n",NOW,p,this->name());
+	NsObject* node = find(p);
+	DBGMARK(DBGPFC,4,"next node:%s \n",node->name());
+	Classifier* clf;
+	bool multipath=false;
+	if (node == NULL)
+	{
+		DBGMARK(0,0,"node is null, returning normal...\n");
+		return PFC_NORMAL_STS;
+	}
+
+	//node could be next link (connector of the next link), or RXing Agent (TCP in our case)
+	//If node == Connector ==> it should call its target (Queue.CheckState)
+	//If node == RX Agent ==> it should return NORMAL State!
+
+	clf = dynamic_cast<Classifier*>(node);
+
+
+	if(clf!=0 && node->IsMultiPathForwarder(node)==0)
+	{
+//		DBGMARK(0,0,"Link pfc sts checking! returning normal.\n");
+		DBGMARK(DBGPFC,4,"node:%s End Host! returning normal.\n",node->name());
+		return PFC_NORMAL_STS;
+	}
+	DBGMARK(DBGPFC,4,"node:%s ,checking next Queue!\n",node->name());
+	return node->CheckState(p);
+}
diff -rpuN ns-allinone-2.34.base/ns-2.34/classifier/classifier.h ns-allinone-2.34.hyline/ns-2.34/classifier/classifier.h
--- ns-allinone-2.34.base/ns-2.34/classifier/classifier.h	2009-06-14 13:35:07.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/classifier/classifier.h	2016-05-01 17:02:22.000000000 -0400
@@ -38,6 +38,8 @@
 #define ns_classifier_h
 
 #include "object.h"
+#include "common.h"
+#define DBGCLS 0
 
 class Packet;
 
@@ -56,6 +58,8 @@ public:
 	inline void set_default_target(NsObject *obj) { 
 		default_target_ = obj;
 	}
+	//:
+	virtual void pfcmessage(int ntoNodeid,int npriority,int nduration);
 
 	virtual void recv(Packet* p, Handler* h);
 	virtual NsObject* find(Packet*);
@@ -66,19 +70,27 @@ public:
 	virtual void do_install(char* dst, NsObject *target) {
 		int slot = atoi(dst);
 		install(slot, target); }
-	int install_next(NsObject *node);
-	virtual void install(int slot, NsObject*);
+	virtual int install_next(NsObject *node,int ntoNode=(-1));
+	virtual void install(int slot, NsObject*,int ntoNode=(-1));
 
 	// function to set the rtg table size
 	void set_table_size(int nn);
 	// hierarchical specific
 	virtual void set_table_size(int level, int nn) {}
 
-	int allocPort (NsObject *);	
+	int allocPort (NsObject *);
+
+	/**
+	 * :
+	 * Check State, Classifier generally calls target's checkState function, except for PortClassifier
+	 * in which There is no further queues (target). PortClassifier will overload this function!
+	 */
+	virtual int CheckState(Packet* p);
+	virtual bool IsMultiPathForwarder(NsObject*node){	return false;}
 protected:
 	virtual int getnxt(NsObject *);
 	virtual int command(int argc, const char*const* argv);
-	void alloc(int);
+	virtual void alloc(int);
 	NsObject** slot_;	/* table that maps slot number to a NsObject */
 	int nslot_;
 	int maxslot_;
diff -rpuN ns-allinone-2.34.base/ns-2.34/classifier/classifier-mpath.cc ns-allinone-2.34.hyline/ns-2.34/classifier/classifier-mpath.cc
--- ns-allinone-2.34.base/ns-2.34/classifier/classifier-mpath.cc	2009-06-14 13:35:07.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/classifier/classifier-mpath.cc	2016-05-01 17:02:22.000000000 -0400
@@ -1,4 +1,5 @@
-/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
+/* -*- Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t
+              -*- */
 
 /*
  * Copyright (C) 1997 by the University of Southern California
@@ -50,21 +51,289 @@ static const char rcsid[] =
 #endif
 
 #include "classifier.h"
+#include "ip.h"
+#define MAX_SLOT 6500
+
+//#define DBGPFC 2
 
 class MultiPathForwarder : public Classifier {
 public:
-	MultiPathForwarder() : ns_(0) {} 
-	virtual int classify(Packet*) {
-		int cl;
-		int fail = ns_;
-		do {
-			cl = ns_++;
-			ns_ %= (maxslot_ + 1);
-		} while (slot_[cl] == 0 && ns_ != fail);
+	MultiPathForwarder() : ns_(0), nodeid_(0), nodetype_(0), perflow_(0), checkpathid_(0) {
+		bind("nodeid_", &nodeid_); 
+		bind("nodetype_", &nodetype_);
+		bind("perflow_", &perflow_);
+		bind("checkpathid_", &checkpathid_);
+	} 
+	virtual int classify(Packet* p) {
+      		int cl;
+		hdr_ip* h = hdr_ip::access(p);
+		/**
+		 * : deterministic routing support.
+		 * this implementation only works if the multipath option are one after each other,
+		 * and if they is no single path route before them
+		 */
+
+		if(h->prio_)DBGMARK(DBGCLS,1,"now:%f, pkt:%p @ {name:%s id:%d}:********** h->path_enable():%d \n",NOW,p,this->name(),nodeid(),h->path_enable());
+		if(h->path_enable())
+		{
+			/*
+			 * FIXME: We here considered that we are using FatTree (pfabric style)
+			 * End Host does not have multipath option. Only Edge and aggregate switch have.
+			 */
+			//Circumventing End Host!
+			if(maxslot_>=1)
+			{
+				int nexthoptmp=0;
+				int mask = 0x80;
+				//Use the 1st unused option.
+				for(int i=3;i>=0;i--)
+				{
+					nexthoptmp = h->path();
+					DBGMARK(DBGCLS,1,"now:%f, pkt:%p @ {id:%d}: nexthoptmp:%08x\n",NOW,p,nodeid(),nexthoptmp);
+					nexthoptmp >>= (i*8);
+					nexthoptmp = (nexthoptmp & 0xFF);
+					DBGMARK(DBGCLS,4,"********** nexthoptmp:%08x\n",nexthoptmp);
+					if((mask & ~nexthoptmp))
+					{
+						for(int j=0;j<=maxslot_;j++)
+						{
+							if(nexthoptmp==toNode_[j])
+							{
+								cl = j;
+								h->path()|= (0x80)<<(i*8);
+								DBGMARK(DBGCLS,1,"@ {id:%d}: {src,dst:%d,%d}Slot is found! %d\n",nodeid(),cl,h->src().addr_,h->dst().addr_);
+								return cl;
+							}
+							DBGMARK(DBGCLS,4,"@ {id:%d}: No Slot is found! nexthoptmp:%d maxslot_:%d \n",
+									nodeid(),nexthoptmp,maxslot_);
+						}
+					}
+				}
+			}
+			else
+			{
+				DBGMARK(DBGCLS,4,"@ {id:%d}: Endhost?! maxslot_:%d\n",nodeid(),maxslot_);
+			}
+		}
+
+		// Mohammad: multipath support
+		// fprintf(stdout, "perflow_ = %d, rcv packet in classifier\n", perflow_);
+		if (perflow_ || checkpathid_) {		  
+		  /*if (h->flowid() >= 10000000) {
+		  	int fail = ns_;
+			do {
+			  cl = ns_++;
+			  ns_ %= (maxslot_ + 1);
+			} while (slot_[cl] == 0 && ns_ != fail);		
+			return cl;
+			}*/
+		  
+			struct hkey {
+				int nodeid;
+					nsaddr_t src, dst;
+				int fid;
+			};
+			struct hkey buf_;
+			buf_.nodeid = nodeid_;
+			buf_.src = mshift(h->saddr());
+			buf_.dst = mshift(h->daddr());
+			buf_.fid = h->flowid();
+			/*if (checkpathid_)
+				buf_.prio = h->prio();
+			else
+			buf_.prio = 0;*/
+			char* bufString = (char*) &buf_;
+			int length = sizeof(hkey);
+
+			unsigned int ms_ = (unsigned int) HashString(bufString, length);
+			if (checkpathid_) {
+				int pathNum = h->prio();
+				int pathDig;
+				for (int i = 0; i < nodetype_; i++) {
+					pathDig = pathNum % 8;
+					pathNum /= 8;
+				}
+				//printf("%d: %d->%d\n", nodetype_, h->prio(), pathDig);
+				ms_ += h->prio(); //pathDig;
+			}
+			ms_ %= (maxslot_ + 1);
+			//printf("nodeid = %d, pri = %d, ms = %d\n", nodeid_, buf_.prio, ms_);
+			int fail = ms_;
+			do {
+				cl = ms_++;
+				ms_ %= (maxslot_ + 1);
+			} while (slot_[cl] == 0 && ms_ != fail);
+			//printf("nodeid = %d, pri = %d, cl = %d\n", nodeid_, h->prio(), cl);
+		}
+		else {
+			//hdr_ip* h = hdr_ip::access(p);
+			//if (h->flowid() == 45) {
+			//cl = h->prio() % (maxslot_ + 1);
+			//}
+			//else {
+			int fail = ns_;
+			do {
+				cl = ns_++;
+				ns_ %= (maxslot_ + 1);
+			} while (slot_[cl] == 0 && ns_ != fail);
+		}
+		//}
 		return cl;
 	}
+	int  nodeid(){return nodeid_;};
+	virtual int install_next(NsObject *node,int ntoNodeid)
+	{
+		if(ntoNodeid==(-1))
+		{
+			DBGERROR("ERRROR! Invalid toNodeid\n");
+			return 0;
+		}
+		DBGPRINT(DBGCLS,1,"ntoNodeid:%d",ntoNodeid);
+		int slot = maxslot_ + 1;
+		install(slot, node,ntoNodeid);
+		return (slot);
+	}
+	virtual void install(int slot, NsObject* p,int ntoNodeid)
+	{
+		if(ntoNodeid==(-1))
+		{
+			DBGERROR("ERRROR! Invalid toNodeid\n");
+			return;
+		}
+		if(slot>=MAX_SLOT)
+		{
+			DBGERROR("ERRROR! slot:%d is more than MAX_SLOT:%d\n",slot,MAX_SLOT);
+			return;
+		}
+		if (slot >= nslot_)
+			alloc(slot);
+		slot_[slot] = p;
+		toNode_[slot]=ntoNodeid;
+		if (slot >= maxslot_)
+			maxslot_ = slot;
+	}
+	virtual void alloc(int slot)
+	{
+		NsObject** old = slot_;
+		int n = nslot_;
+		if (old == 0)
+		    {
+			if (nsize_ != 0) {
+				//printf("classifier %x set to %d....%dth visit\n", this, nsize_, i++);
+				nslot_ = nsize_;
+			}
+			else {
+				//printf("classifier %x set to 32....%dth visit\n", this, j++);
+				nslot_ = 32;
+			}
+		    }
+		while (nslot_ <= slot)
+			nslot_ <<= 1;
+		slot_ = new NsObject*[nslot_];
+		memset(slot_, 0, nslot_ * sizeof(NsObject*));
+		for (int i = 0; i < n; ++i)
+		{
+			slot_[i] = old[i];
+		}
+		delete [] old;
+	}
+	virtual int command(int argc, const char*const* argv)
+	{
+		Tcl& tcl = Tcl::instance();
+		/*
+		 * $classifier installNext $Connector $toNode_id
+		 */
+		if (strcmp(argv[1], "installNext") == 0)
+		{
+			if(argc == 4)
+			{
+				//int slot = maxslot_ + 1;
+				NsObject* node = (NsObject*)TclObject::lookup(argv[2]);
+				if (node == NULL) {
+					tcl.resultf("Classifier::installNext attempt "
+				"to install non-object %s into classifier", argv[2]);
+					return TCL_ERROR;
+				};
+				int ntoNode = atoi(argv[3]);
+				DBGMARK(DBGCLS,1,"ntoNode_:%d\n",ntoNode);
+				int slot = install_next(node,ntoNode);
+				tcl.resultf("%u", slot);
+
+//				tcl.evalf("[%s set toNode_]",node->name());
+//				const char* result = tcl.result();
+//				DBGMARK(DBGCLS,1,"classifier_name:%s link:%s, node:%s slot:%d\n",this->name(),result, node->name(),slot);
+				return TCL_OK;
+			}
+			else
+			{
+				DBGMARK(DBGCLS,1,"ERROR!, not enough params for installnext!\n");
+				return TCL_ERROR;
+			}
+		}
+		else if (strcmp(argv[1], "pfcmessage") == 0)
+		{
+			if(argc == 5)
+			{
+				int ntoNodeid = atoi(argv[2]);
+				int npriority = atoi(argv[3]);
+				int nduration = atoi(argv[4]);
+				DBGMARK(DBGPFC,1,"ntoNodeid_:%d priority:%d duration:%d\n",ntoNodeid,npriority,nduration);
+				pfcmessage(ntoNodeid,npriority,nduration);
+				return TCL_OK;
+			}
+		}
+
+		//:
+
+		/**
+		 * : We do not need to overload the "install" command
+		 * We always call installnext for multipath
+		 */
+		return (Classifier::command(argc, argv));
+	}
+	virtual void pfcmessage(int ntoNodeid,int npriority,int nduration)
+	{
+		DBGPRINT(DBGPFC,2,"Message Received!\n");
+		DBGMARK(DBGPFC,2,"ntoNodeid_:%d priority:%d duration:%d\n",ntoNodeid,npriority,nduration);
+		/**
+		 *	CODE:
+		 */
+
+	}
+	virtual bool IsMultiPathForwarder(NsObject*node)
+	{
+		MultiPathForwarder* clf2 =dynamic_cast<MultiPathForwarder*>(node);
+		DBGMARK(DBGPFC,4,"************************* Checking %s ...:(clf2!=0):%d ",node->name(),(clf2!=0));
+		return (clf2!=0);
+	}
 private:
+	// fixme:MAKE it Dynamic!
+	/*
+	 * The dynamic version does not work properly!
+	 */
+	int toNode_[MAX_SLOT];
+
 	int ns_;
+	// Mohamamd: adding support for perflow multipath
+	int nodeid_;
+	int nodetype_;
+	int perflow_;
+	int checkpathid_;
+
+	static unsigned int
+	HashString(register const char *bytes,int length)
+	{
+		register unsigned int result;
+		register int i;
+
+		result = 0;
+		for (i = 0;  i < length;  i++) {
+			result += (result<<3) + *bytes++;
+		}
+		return result;
+	}
+
+
 };
 
 static class MultiPathClass : public TclClass {
diff -rpuN ns-allinone-2.34.base/ns-2.34/classifier/classifier-port.cc ns-allinone-2.34.hyline/ns-2.34/classifier/classifier-port.cc
--- ns-allinone-2.34.base/ns-2.34/classifier/classifier-port.cc	2009-06-14 13:35:07.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/classifier/classifier-port.cc	2016-05-01 17:02:22.000000000 -0400
@@ -55,6 +55,7 @@ static const char rcsid[] =
 
 int PortClassifier::classify(Packet *p) 
 {
+	DBGMARK(DBGPFC,4,"@ %s:",this->name());
 	// Port classifier returns the destination port.  No shifting
 	// or masking is required since in the 32-bit addressing,
 	// ports are stored in a seperate variable.
diff -rpuN ns-allinone-2.34.base/ns-2.34/classifier/classifier-port.h ns-allinone-2.34.hyline/ns-2.34/classifier/classifier-port.h
--- ns-allinone-2.34.base/ns-2.34/classifier/classifier-port.h	2009-06-14 13:35:07.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/classifier/classifier-port.h	2016-05-01 17:02:22.000000000 -0400
@@ -59,6 +59,15 @@
 class PortClassifier : public Classifier {
 protected:
 	int classify(Packet *p);
+
+	//: PFC Functionality
+	/**
+	 * End-Hosts should return Normal state since there is no further queue in front of them!
+	 */
+//	virtual int CheckState(Packet* p) {
+//		DBGMARK(DBGPFC,4,"@ %s: End-Host:Port Classifier! Returning normal state...\n",this->name());
+//		return PFC_NORMAL_STS;}
+
 // 	void clear(int slot);
 // 	int getnxt(NsObject *);
 //	int command(int argc, const char*const* argv);
diff -rpuN ns-allinone-2.34.base/ns-2.34/common/common.h ns-allinone-2.34.hyline/ns-2.34/common/common.h
--- ns-allinone-2.34.base/ns-2.34/common/common.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-allinone-2.34.hyline/ns-2.34/common/common.h	2016-05-31 12:06:06.000000000 -0400
@@ -0,0 +1,164 @@
+/** ====================================================================
+ *      Copyright(c) 2015,  Abbasloo, All Rights Reserved.
+ *      Author:  Abbasloo
+ *      Email :	ab.@nyu.edu
+ * ===================================================================== **/
+
+//#####################################################################################################
+#ifndef NS_2_34_COMMON_COMMON_H_
+#define NS_2_34_COMMON_COMMON_H_
+//#####################################################################################################
+
+//=========================================================================
+#include <stdio.h>
+#include <string.h>
+//#include "Debug.h"
+//#include "MemTrack.h"
+//=========================================================================
+
+//=========================================================================
+//General Result Codes
+enum ERes
+{
+	ERES_SUCCESS 					=  0,
+	ERES_WARNING					= -1,
+	ERES_ERROR 						= -2,
+	ERES_ERR_INVALID_PARAMETER		= -3,
+	ERES_ERR_OPERATION_FAILED		= -4,
+	ERES_ERR_INVALID_POINTER		= -5,
+	ERES_ERR_NO_MEM					= -6,
+	ERES_ERR_INVALID_OPERATION		= -7,
+	ERES_ERR_NOT_IMPLEMENTED		= -8,
+};
+//=========================================================================
+
+//#define ERROR		-1
+
+#define DBGPFC 1
+
+/*
+//ANSI Terminal Colors
+#define COL_DGRY "[0;30m"
+#define COL_DBLU "[0;34m"
+#define COL_DGRN "[0;32m"
+#define COL_DCYN "[0;36m"
+#define COL_DRED "[0;31m"
+#define COL_DMAG "[0;35m"
+#define COL_DYEL "[0;33m"
+#define COL_DWHT "[0;37m"
+#define COL_LGRY "[1;30m"
+#define COL_LBLU "[1;34m"
+#define COL_LGRN "[1;32m"
+#define COL_LCYN "[1;36m"
+#define COL_LRED "[1;31m"
+#define COL_LMAG "[1;35m"
+#define COL_LYEL "[1;33m"
+#define COL_LWHT "[1;37m"
+//#define COL_LBLK "[1;30m"
+#define HIDCRSR "[?25l"
+#define SHWCRSR "[?25h"
+#define CLSSTR  "[2J"
+#define ESCS	""
+#define ESCC	''
+#define ESCNUM	0x1B
+#define CC_BS	'\x08'
+*/
+//ANSI Terminal Colors
+#define COL_DGRY ""
+#define COL_DBLU ""
+#define COL_DGRN ""
+#define COL_DCYN ""
+#define COL_DRED ""
+#define COL_DMAG ""
+#define COL_DYEL ""
+#define COL_DWHT ""
+#define COL_LGRY ""
+#define COL_LBLU ""
+#define COL_LGRN ""
+#define COL_LCYN ""
+#define COL_LRED ""
+#define COL_LMAG ""
+#define COL_LYEL ""
+#define COL_LWHT ""
+//#define COL_LBLK "[1;30m"
+#define HIDCRSR ""
+#define SHWCRSR ""
+#define CLSSTR  ""
+#define ESCS	""
+#define ESCC	''
+#define ESCNUM	0x1B
+#define CC_BS	'\x08'
+
+#define MOVCRSR(_x,_y)   "["#_y";"#_x"H"
+
+
+//=========================================================================
+// GCC Attributes
+//=========================================================================
+//for Functions
+#define __GFA_INLINE			__attribute__((always_inline)) 		//Force in-line
+#define __GFA_NOINLINE			__attribute__((noinline))			//Force no in-line
+#define __GFA_FLATTEN			__attribute__((flatten))			//in-line all calls from this function(if possible)
+#define __GFA_ERROR(_msg_)		__attribute__((error(_msg_)))		//Generate Error
+#define __GFA_WARN(_msg_)		__attribute__((warning(_msg_)))		//Generate Warning
+#define __GFA_UNUSED			__attribute__((unused)) 			//do not generate warning if not used
+#define __GFA_USED				__attribute__((used)) 				//mark as used
+//for Types
+#define __GTA_ALIGNE_BYTE		__attribute__((aligned(8))) 		//Byte alignment
+#define __GTA_ALIGNE			__attribute__((aligned)) 			//Use Optimum alignment
+#define __GTA_PACKED			__attribute__((packed)) 			//Use minimum memory(for enums,union,...)
+#define __GTA_UNUSED			__attribute__((unused)) 			//do not generate warning if not used
+//for Variables
+#define __GVA_ALIGNE_BYTE		__attribute__((aligned(8))) 		//Byte alignment
+#define __GVA_ALIGNE			__attribute__((aligned)) 			//Use Optimum alignment
+#define __GVA_PACKED			__attribute__((packed)) 			//Use minimum memory(for enums,union,...)
+#define __GVA_UNUSED			__attribute__((unused)) 			//do not generate warning if not used
+#define __GVA_USED				__attribute__((used)) 				//mark as used
+//=========================================================================
+
+
+//=========================================================================
+#define VERSION(_major_, _minor_) ( ((_major_ & 0xFF)<<8) | (_minor_ & 0xFF) )
+#define MAJOR_VERSION(_version_)	((_version_ >> 8) & 0xFF)
+#define MINOR_VERSION(_version_)	(_version_ & 0xFF)
+
+#define CHECK_VAR_RANGE_B(_var, _low, _high) (((_var) >= (_low))&&((_var) <= (_high)))
+#define CHECK_VAR_RANGE_NB(_var, _low, _high) (((_var) > (_low))&&((_var) < (_high)))
+#define CHECK_VAR_RANGE_NOT_B(_var, _low, _high) (((_var) <= (_low))||((_var) >= (_high)))
+#define CHECK_VAR_RANGE_NOT_NB(_var, _low, _high) (((_var) < (_low))||((_var) > (_high)))
+
+#define CHECK_POINTER(_pointer)	((_pointer)?1:0)
+
+#define SUCCESS(_res) ( (_res==ERES_SUCCESS)?true:false)
+#define ERROR(_res) ( (_res!=ERES_SUCCESS)?true:false)
+
+
+#ifdef PALCON_H_
+#define PUTCH(ch) CConsole::PutChar(ch)
+#define PRINT(fmt, arg...)  CConsole::Print(fmt, ## arg )
+#define PRINTXY(_x,_y, fmt, arg...)  do{CConsole::Print("[%d;%dH",_y,_x); CConsole::Print(fmt, ## arg );}while(0)
+#define PRINTCOL(col, fmt, arg...) CConsole::Print( col fmt COL_DWHT, ## arg )
+#define DBGPRINTPRTY(curlvl, showlvl, fmt, arg...)	do{if(curlvl>=showlvl)CConsole::Print(COL_LWHT "\r[%s] " COL_DWHT fmt COL_DWHT, __PRETTY_FUNCTION__ , ## arg );}while(0)
+#define DBGPRINT(curlvl, showlvl, fmt, arg...)  do{if(curlvl>=showlvl)CConsole::Print(COL_LWHT "\r[%s] " COL_DWHT fmt COL_DWHT, __FUNCTION__ , ## arg );}while(0)
+#define DBGMARK(curlvl, showlvl, fmt, arg...)	do{if(curlvl>=showlvl)CConsole::Print(COL_LBLU "\r[%s-%s-%d] " COL_DBLU fmt COL_DWHT, __FILE_NAME__, __FUNCTION__, __LINE__ , ## arg );}while(0)
+#define DBGERROR(fmt, arg...)		CConsole::Print(COL_LRED "\r[%s] " COL_DRED fmt COL_DWHT, __FUNCTION__ , ## arg )
+#define DBGWARN(fmt, arg...)		CConsole::Print(COL_LYEL "\r[%s] " COL_DYEL fmt COL_DWHT, __FUNCTION__ , ## arg )
+#define DBGINFO(fmt, arg...)		CConsole::Print(COL_LBLU "\r[%s] " COL_DGRN fmt COL_DWHT, __FUNCTION__ , ## arg )
+#else
+#define PUTCH(ch) do{fputc(ch, stdout);}while(0)
+#define PRINT(fmt, arg...)  do{fprintf(stdout, fmt, ## arg );fflush(stdout);}while(0)
+#define PRINTXY(_x,_y,fmt,arg...) do{fprintf(stdout, "[%d;%dH",_y,_x); fprintf(stdout, fmt, ## arg );fflush(stdout);}while(0)
+#define PRINTCOL(col, fmt, arg...) do{fprintf(stdout, col fmt COL_DWHT, ## arg );fflush(stdout);}while(0)
+#define DBGPRINTPRTY(curlvl, showlvl,fmt, arg...)	do{if(curlvl>=showlvl){fprintf(stdout, COL_LWHT "\r[%s] " COL_DWHT fmt COL_DWHT, __PRETTY_FUNCTION__ , ## arg );fflush(stdout);}}while(0)
+#define DBGPRINT(curlvl, showlvl, fmt, arg...)	do{if(curlvl>=showlvl){fprintf(stdout, COL_LWHT "\r[%s] " COL_DWHT fmt COL_DWHT, __FUNCTION__ , ## arg );fflush(stdout);}}while(0)
+#define DBGMARK(curlvl, showlvl, fmt, arg...)	do{if(curlvl>=showlvl){fprintf(stdout, COL_LBLU "\r[%s-%s-%d] " COL_DBLU fmt COL_DWHT, __FILE_NAME__, __FUNCTION__, __LINE__ , ## arg );fflush(stdout);}}while(0)
+#define DBGERROR(fmt, arg...)	do{fprintf(stdout, COL_LRED "\r[%s] " COL_DRED fmt COL_DWHT, __FUNCTION__ , ## arg );fflush(stdout);}while(0)
+#define DBGWARN(fmt, arg...)	do{fprintf(stdout, COL_LYEL "\r[%s] " COL_DYEL fmt COL_DWHT, __FUNCTION__ , ## arg );fflush(stdout);}while(0)
+#define DBGINFO(fmt, arg...)	do{fprintf(stdout, COL_LGRN "\r[%s] " COL_DGRN fmt COL_DWHT, __FUNCTION__ , ## arg );fflush(stdout);}while(0)
+#endif
+//=========================================================================
+#define __FILE_NAME__ (strrchr(__FILE__,'/')?strrchr(__FILE__,'/')+1:__FILE__)
+//=========================================================================
+
+//#####################################################################################################
+#endif /* NS_2_34_COMMON_COMMON_H_ */
diff -rpuN ns-allinone-2.34.base/ns-2.34/common/connector.h ns-allinone-2.34.hyline/ns-2.34/common/connector.h
--- ns-allinone-2.34.base/ns-2.34/common/connector.h	2009-06-14 13:35:44.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/common/connector.h	2016-05-01 17:02:22.000000000 -0400
@@ -51,9 +51,13 @@ public:
 	void setDropTarget(NsObject *dt) {drop_ = dt; } 
 protected:
 	virtual void drop(Packet* p, const char *s);
-	int command(int argc, const char*const* argv);
+	virtual int command(int argc, const char*const* argv);
 	void recv(Packet*, Handler* callback = 0);
-	inline void send(Packet* p, Handler* h) { target_->recv(p, h); }
+	inline void send(Packet* p, Handler* h) { target_->recv(p, h);}
+
+	//: PFC functionality
+	virtual int CheckState(Packet* p){DBGMARK(DBGPFC,4,"@ %s: Checking PFC sts...target:%s\n",this->name(),target_->name());
+	return target_->CheckState(p);}
 
 	NsObject* target_;
 	NsObject* drop_;	// drop target for this connector
diff -rpuN ns-allinone-2.34.base/ns-2.34/common/controller.cc ns-allinone-2.34.hyline/ns-2.34/common/controller.cc
--- ns-allinone-2.34.base/ns-2.34/common/controller.cc	1969-12-31 19:00:00.000000000 -0500
+++ ns-allinone-2.34.hyline/ns-2.34/common/controller.cc	2016-05-31 12:00:08.000000000 -0400
@@ -0,0 +1,1111 @@
+/** ====================================================================
+ *
+ *  	Copyright 2015,  Abbasloo, All rights reserved.
+ *  	Email : ab.@nyu.edu
+ *
+ *  	New York University
+ *
+ * ===================================================================== **/
+
+#include "controller.h"
+#include <stdlib.h>
+SFlow::SFlow(SSortedTableEntry *sEntry)
+{
+	this->sEntry=sEntry;
+}
+
+//SFlow::SFlow()
+//{
+//	this->sEntry->OrgIndex=0;//parent
+//	this->sEntry->pairid=0;
+//	this->sEntry->flowid=0;
+//	this->sEntry->deadline=0;
+//	this->sEntry->start_time=0;
+//	this->sEntry->last_time=0;
+//	this->sEntry->remaining_size=0;
+//	this->sEntry->remaining_deadline=0;
+//	this->sEntry->eState = eInit;
+//	this->sEntry->ePreState = eInit;
+//	this->sEntry->sPath.AggIndex=(-1);
+//	this->sEntry->sPath.CoreIndex=(-1);
+//
+//}
+
+void SFlow::Copy(SFlow other)
+{
+//	DBGMARK(DBG,8,"this->sEntry:%p....Other.sEntry=%p\n",&this->sEntry,&other.sEntry);
+//	this->sEntry->Copy(other.sEntry);
+	this->sEntry=other.sEntry;
+}
+
+bool SFlow::operator<(const SFlow& other) const
+{
+//	DBGMARK(DBG,8,"other.Entry:%p\n",other.sEntry);
+	if(this->sEntry!=NULL && other.sEntry!=NULL)
+	{
+		DBGMARK(DBG,8,"this->sEntry->remaining_size:%d....other.sEntry->remaining_size:%d\n",this->sEntry->remaining_size,other.sEntry->remaining_size);
+		DBGMARK(DBG,8,"return:%d\n",((*this->sEntry) < (*other.sEntry)));
+		return	((*this->sEntry) < (*other.sEntry));
+	}
+	else
+		return	false;
+}
+
+bool SFlow::operator!=(const SFlow& other) const
+{
+	DBGMARK(DBG,8,"\n");
+	if(this->sEntry!=NULL && other.sEntry!=NULL)
+	{
+		DBGMARK(DBG,8,"this->sEntry->remaining_size:%d....other.sEntry->remaining_size:%d\n"
+				"sEntry->flowid:%d .... other.sEntry->flowid:%d\n",this->sEntry->remaining_size,other.sEntry->remaining_size
+				,this->sEntry->flowid,other.sEntry->flowid);
+		DBGMARK(DBG,8,"return:%d\n",((*this->sEntry) != (*other.sEntry)));
+		return	((*this->sEntry) != (*other.sEntry));
+	}
+	else
+		return	true;
+}
+
+bool SFlow::operator==(const SFlow& other) const
+{
+	if(this->sEntry!=NULL && other.sEntry!=NULL)
+		return	(sEntry->flowid==other.sEntry->flowid);
+	if(this->sEntry==NULL && other.sEntry==NULL)
+	{
+		return true;
+	}
+	else
+		return false;
+}
+
+SFlow& SFlow::operator=(const SFlow& other)
+{
+	if(this != &other)
+	{
+		Copy(other);
+	}
+	return *this;
+}
+
+SFlowEntry::SFlowEntry(int pairid,int fid,int size,int deadline,
+		int src_pod,int src_edg,int src_index,int dst_pod,int dst_edg,int dst_index)
+{
+	this->pairid=pairid;
+	this->flowid=fid;
+	this->size=size;
+	this->deadline=deadline;
+	this->src_pod=src_pod;
+	this->src_edg=src_edg;
+	this->src_index=src_index;
+	this->dst_pod=dst_pod;
+	this->dst_edg=dst_edg;
+	this->dst_index=dst_index;
+	Sorted_Index = 0;//parent
+}
+
+bool SFlowEntry::operator<(const SFlowEntry& other) const
+{
+	return	(flowid<other.flowid)?true:(flowid==other.flowid && pairid<other.pairid)?true:false;
+}
+
+void SFlowEntry::Copy(SFlowEntry sEntry)
+{
+	pairid=sEntry.pairid;
+	flowid=sEntry.flowid;
+	src_pod=sEntry.src_pod;
+	src_edg=sEntry.src_edg;
+	src_index=sEntry.src_index;
+	dst_pod=sEntry.dst_pod;
+	dst_edg=sEntry.dst_edg;
+	dst_index=sEntry.dst_index;
+	size=sEntry.size;
+	deadline=sEntry.deadline;
+
+	Sorted_Index=sEntry.Sorted_Index;
+}
+
+bool SFlowEntry::operator!=(const SFlowEntry& other) const
+{
+	return (flowid != other.flowid);
+}
+
+SFlowEntry& SFlowEntry::operator=(const SFlowEntry& other)
+{
+	if(this != &other)
+	{
+		Copy(other);
+	}
+	return *this;
+}
+
+void SSortedTableEntry::Copy(SSortedTableEntry sEntry)
+{
+	pairid=sEntry.pairid;
+	flowid=sEntry.flowid;
+	start_time=sEntry.start_time;
+	last_time=sEntry.last_time;
+	remaining_size=sEntry.remaining_size;
+	remaining_deadline=sEntry.remaining_deadline;
+	deadline=sEntry.deadline;
+	eState=sEntry.eState;
+	ePreState=sEntry.ePreState;
+	OrgIndex=sEntry.OrgIndex;
+	sPath.AggIndex=sEntry.sPath.AggIndex;
+	sPath.CoreIndex=sEntry.sPath.CoreIndex;
+}
+
+bool SSortedTableEntry::operator<(const SSortedTableEntry& other) const
+{
+	if(deadline>0)
+	{
+		if(other.deadline==0)
+		{
+			return true;
+		}
+		else
+		{
+			return	(remaining_deadline<other.remaining_deadline)?true:(remaining_deadline>other.remaining_deadline)?false:
+					(remaining_deadline==other.remaining_deadline && remaining_size<other.remaining_size)?true:
+					(remaining_deadline==other.remaining_deadline && remaining_size>other.remaining_size)?false:
+					(flowid<other.flowid)?true:(flowid==other.flowid && pairid<other.pairid)?true:false;
+		}
+	}
+	else
+	{
+		if(other.deadline>0)
+		{
+			return false;
+		}
+		else
+		{
+			return (remaining_size<other.remaining_size)?true:(remaining_size>other.remaining_size)?false:
+					(flowid<other.flowid)?true:(flowid==other.flowid && pairid<other.pairid)?true:false;
+		}
+	}
+}
+
+bool SSortedTableEntry::operator!=(const SSortedTableEntry& other) const
+{
+	return (!((pairid==other.pairid) && flowid == other.flowid
+			&& remaining_size==other.remaining_size && remaining_deadline==other.remaining_deadline
+			&& deadline==other.deadline));
+}
+
+SSortedTableEntry& SSortedTableEntry::operator=(const SSortedTableEntry& other)
+{
+	if(this != &other)
+	{
+		Copy(other);
+	}
+	return *this;
+}
+
+cController::cController()
+{
+	Init();
+}
+
+void cController::Init()
+{
+	cFlowTree.Initialize(sFlowTable.sTable,MAX_FLOW_NUM,true);
+	cSortedTree.Initialize(sSortedTable.sTable,MAX_FLOW_NUM,true);
+	NumCore=1;
+	NumPod=4;
+	NumAggPerPod=MAX_AGG_PER_POD;
+	NumCorPerAgg=MAX_CORE_NUM;
+	NumEdgPerPod=MAX_EDG_PER_POD;
+	NumHostPerEdge=MAX_HOST_PER_EDG;
+	HostEdgeBW=1;
+	EdgeAggBW=10;
+	AggCoreBW=10;
+
+	for(int dir=0;dir<2;dir++)
+	{
+		for(int i=0;i<MAX_POD_NUM;i++)
+		{
+			for(int j=0;j<MAX_EDG_PER_POD;j++)
+			{
+				for(int n=0;n<MAX_HOST_PER_EDG;n++)
+				{
+//					for(int flow=0;flow<21;flow++)
+//					{
+//						HostEdgeLink[dir][i][j][n].sFlows.sTable[flow].sEntry = new SSortedTableEntry;
+//					}
+					HostEdgeLink[dir][i][j][n].cFlowTree.Initialize(HostEdgeLink[dir][i][j][n].sFlows.sTable,MAX_FLOW_PER_LINK,true);
+					HostEdgeLink[dir][i][j][n].RBW = HostEdgeBW;
+				}
+				for(int n=0;n<MAX_AGG_PER_POD;n++)
+				{
+//					for(int flow=0;flow<21;flow++)
+//					{
+//						EdgeAggrLink[dir][i][j][n].sFlows.sTable[flow].sEntry = new SSortedTableEntry;
+//					}
+					EdgeAggrLink[dir][i][j][n].cFlowTree.Initialize(EdgeAggrLink[dir][i][j][n].sFlows.sTable,MAX_FLOW_PER_LINK,true);
+					EdgeAggrLink[dir][i][j][n].RBW = EdgeAggBW;
+
+				}
+			}
+			for(int j=0;j<MAX_CORE_NUM;j++)
+			{
+				for(int n=0;n<MAX_AGG_PER_POD;n++)
+				{
+//					for(int flow=0;flow<21;flow++)
+//					{
+//						AggrCoreLink[dir][i][n][j].sFlows.sTable[flow].sEntry = new SSortedTableEntry;
+//					}
+					AggrCoreLink[dir][i][n][j].cFlowTree.Initialize(AggrCoreLink[dir][i][n][j].sFlows.sTable,MAX_FLOW_PER_LINK,true);
+					AggrCoreLink[dir][i][n][j].RBW = AggCoreBW;
+				}
+			}
+		}
+	}
+//	InitializeBW();
+}
+
+void cController::InitializeBW()
+{
+	for(int dir=0;dir<2;dir++)
+	{
+		for(int i=0;i<NumPod;i++)
+		{
+			for(int j=0;j<NumEdgPerPod;j++)
+			{
+				for(int n=0;n<NumHostPerEdge;n++)
+				{
+					HostEdgeLink[dir][i][j][n].RBW = HostEdgeBW;
+				}
+				for(int n=0;n<NumAggPerPod;n++)
+				{
+					EdgeAggrLink[dir][i][j][n].RBW = EdgeAggBW;
+				}
+			}
+			for(int j=0;j<NumCore;j++)
+			{
+				for(int n=0;n<NumAggPerPod;n++)
+				{
+					AggrCoreLink[dir][i][n][j].RBW = AggCoreBW;
+				}
+			}
+		}
+	}
+}
+
+void cController::Update()
+{
+	for(int nIndex=cFlowTree.First();nIndex>0;nIndex=cFlowTree.Next(nIndex))
+	{
+		int Sorted_Index_ = cFlowTree.Entry(nIndex)->Sorted_Index;
+		DBGMARK(DBG,7,"Sorted_Index_:%d\n",Sorted_Index_);
+		int changed =0;
+		if(cSortedTree.Entry(Sorted_Index_)->deadline)
+		{
+			cSortedTree.Entry(Sorted_Index_)->remaining_deadline -= (now()-cSortedTree.Entry(Sorted_Index_)->start_time)/1000000;
+			if(cSortedTree.Entry(Sorted_Index_)->remaining_deadline<0)
+			{
+				cSortedTree.Entry(Sorted_Index_)->remaining_deadline =0;
+			}
+			changed++;
+		}
+		if(cSortedTree.Entry(Sorted_Index_)->eState==eAllowed)
+		{
+			//First: Remove it from Path's Links
+			RemoveFlow(nIndex);
+
+			Tcl::instance().evalf("%s get-remaining %d %d ", this->name(),cSortedTree.Entry(nIndex)->pairid,cSortedTree.Entry(nIndex)->flowid);
+
+//			cSortedTree.Entry(Sorted_Index_)->remaining_size -= (now()-cSortedTree.Entry(Sorted_Index_)->last_time)*HostEdgeBW*(1000000000/8);
+//			if(cSortedTree.Entry(Sorted_Index_)->remaining_size<=0)
+//			{
+//				cSortedTree.Entry(Sorted_Index_)->remaining_size=1;
+//			}
+			changed++;
+		}
+		DBGMARK(DBG,7,"flowid:%d Remaining deadline:%d Remaining size:%d\n",cSortedTree.Entry(Sorted_Index_)->flowid,cSortedTree.Entry(Sorted_Index_)->remaining_deadline,cSortedTree.Entry(Sorted_Index_)->remaining_size);
+		//Update SortedTable
+		if(changed)
+		{
+//			//First: Remove it from Path's Links
+//			RemoveFlow(nIndex);
+
+			//Remove it from Sorted List.
+			SSortedTableEntry sEntryTmp;
+			sEntryTmp.Copy(*cSortedTree.Entry(Sorted_Index_));
+			if(cSortedTree.Del(Sorted_Index_)<0)
+			{
+				DBGMARK(DBG,0,"error!\n");
+			}
+			//Add the updated one to Sorted List.
+			int newIndex = cSortedTree.Add(sEntryTmp);
+			if(newIndex<=0)
+			{
+				DBGERROR("ERROR! Can not add the entry!\n");
+				return;
+			}
+			cFlowTree.Entry(nIndex)->Sorted_Index = newIndex;
+			//Add the updated one to Path's Links.
+			AddFlow(nIndex);
+			DBGMARK(DBG,7,"Sorted_Index_:%d\n",newIndex);
+		}
+	}
+}
+
+void cController::SetRemainingSize(int pairid,int fid,int size,int deadline,int src_pod,int src_edg,int src_index,int dst_pod,int dst_edg,int dst_index,int RemainingSize)
+{
+	DBGMARK(DBG,2,"time:%lf fid: %d ,size: %d ,deadline: %d ,src_pod: %d ,src_edg: %d ,src_index: %d ,dst_pod: %d ,dst_edg: %d ,dst_index : %d\nRemainingSize:%d\n",now(),fid,size,deadline,src_pod,src_edg,src_index,dst_pod,dst_edg,dst_index,RemainingSize);
+	SFlowEntry sEntryTmp(pairid,fid,size,deadline,src_pod,src_edg,src_index,dst_pod,dst_edg,dst_index);
+	int nIndex = cFlowTree.Find(sEntryTmp);
+	if(nIndex<=0)
+	{
+		DBGERROR("ERROR! NOT find!\n");
+		return;
+	}
+	int nIndexSorted=cFlowTree.Entry(nIndex)->Sorted_Index;
+	if(cSortedTree.Entry(nIndexSorted)->remaining_size >= RemainingSize)
+		cSortedTree.Entry(nIndexSorted)->remaining_size = RemainingSize;
+}
+
+void cController::NewRequest(int pairid,int fid,int size,int deadline,int src_pod,int src_edg,int src_index,int dst_pod,int dst_edg,int dst_index)
+{
+	DBGMARK(DBG,2,"fid: %d ,size: %d ,deadline: %d ,src_pod: %d ,src_edg: %d ,src_index: %d ,dst_pod: %d ,dst_edg: %d ,dst_index : %d\n"
+			,fid,size,deadline,src_pod,src_edg,src_index,dst_pod,dst_edg,dst_index);
+	SFlowEntry sEntryTmp(pairid,fid,size,deadline,src_pod,src_edg,src_index,dst_pod,dst_edg,dst_index);
+	int nIndex = cFlowTree.Add(sEntryTmp);
+	if(nIndex<=0)
+	{
+		DBGERROR("ERROR! ADD FAILED!\n");
+		return;
+	}
+	SSortedTableEntry sSortedEntryTmp(pairid,fid,size,deadline,now());
+	int nIndexSorted = cSortedTree.Add(sSortedEntryTmp);
+	if(nIndexSorted>0)
+	{
+		cFlowTree.Entry(nIndex)->Sorted_Index=nIndexSorted;
+		cSortedTree.Entry(nIndexSorted)->OrgIndex=nIndex;
+	}
+	else
+	{
+		DBGMARK(DBG,0,"error!\n");
+		return;
+	}
+//	DBGMARK(DBG,2,"***************\n");
+	Schedule(nIndex);
+//DBGMARK(DBG,2,"***************\n");
+}
+
+void cController::RemoveRequest(int pairid,int fid,int size,int deadline,int src_pod,int src_edg,int src_index,int dst_pod,int dst_edg,int dst_index)
+{
+	DBGMARK(DBG,2,"fid: %d ,size: %d ,deadline: %d ,src_pod: %d ,src_edg: %d ,src_index: %d ,dst_pod: %d ,dst_edg: %d ,dst_index : %d\n"
+			,fid,size,deadline,src_pod,src_edg,src_index,dst_pod,dst_edg,dst_index);
+	SFlowEntry sEntryTmp(pairid,fid,size,deadline,src_pod,src_edg,src_index,dst_pod,dst_edg,dst_index);
+	int nIndex = cFlowTree.Find(sEntryTmp);
+	int NextIndex=0;
+	if(nIndex>0)
+	{
+		if(cFlowTree.Entry(nIndex)->Sorted_Index>0)
+		{
+			//1st: Remove it from Path's Lkinks:
+			RemoveFlow(nIndex);
+			NextIndex=cSortedTree.Next(cFlowTree.Entry(nIndex)->Sorted_Index);
+			cSortedTree.Entry(cFlowTree.Entry(nIndex)->Sorted_Index)->eState=eStopped;
+			int res= cSortedTree.Del(cFlowTree.Entry(nIndex)->Sorted_Index);
+			if(res<0)
+			{
+				DBGMARK(DBG,0,"Error!\n");
+				return;
+			}
+		}
+		if(cFlowTree.Del(nIndex)<0)
+		{
+			DBGMARK(DBG,0,"Error!\n");
+			return;
+		}
+
+		Update();
+		ReSchedule(cSortedTree.First());
+		ShowTable();
+	}
+	else
+	{
+		DBGMARK(0,0,"fid: %d ,size: %d ,deadline: %d ,src_pod: %d ,src_edg: %d ,src_index: %d ,dst_pod: %d ,dst_edg: %d ,dst_index : %d\n"
+				,fid,size,deadline,src_pod,src_edg,src_index,dst_pod,dst_edg,dst_index);
+		DBGERROR("Error,NO ENTRY FOUND!\n");
+	}
+}
+
+bool cController::CheckAvailableBW(int nIndex)
+{
+	int Res=0;
+	DBGMARK(DBG,7,"FLowID:%d\n",cSortedTree.Entry(cFlowTree.Entry(nIndex)->Sorted_Index)->flowid);
+	SFlow NewFlow(cSortedTree.Entry(cFlowTree.Entry(nIndex)->Sorted_Index));
+
+	//Start from the dst and come to the src
+
+	//HostEdgeLink
+	if(!HostEdgeLink[RX][cFlowTree.Entry(nIndex)->dst_pod][cFlowTree.Entry(nIndex)->dst_edg][cFlowTree.Entry(nIndex)->dst_index].cFlowTree.IsEmpty())
+	{
+		if (HostEdgeLink[RX][cFlowTree.Entry(nIndex)->dst_pod][cFlowTree.Entry(nIndex)->dst_edg][cFlowTree.Entry(nIndex)->dst_index].RBW < HostEdgeBW)
+		{
+			Res = HostEdgeLink[RX][cFlowTree.Entry(nIndex)->dst_pod][cFlowTree.Entry(nIndex)->dst_edg][cFlowTree.Entry(nIndex)->dst_index].cFlowTree.FindNext(NewFlow);
+			DBGMARK(DBG,7,"Res:%d\n",Res);
+			if (Res<=0)
+			{
+				return false;
+			}
+		}
+	}
+	//Check dst edge-aggregation stage
+	for (int aggindex=0;aggindex<NumAggPerPod;aggindex++)
+	{
+		if(		((!EdgeAggrLink[RX][cFlowTree.Entry(nIndex)->dst_pod][cFlowTree.Entry(nIndex)->dst_edg][aggindex].cFlowTree.IsEmpty()) &&
+					(((EdgeAggrLink[RX][cFlowTree.Entry(nIndex)->dst_pod][cFlowTree.Entry(nIndex)->dst_edg][aggindex].RBW < HostEdgeBW)
+							&&(EdgeAggrLink[RX][cFlowTree.Entry(nIndex)->dst_pod][cFlowTree.Entry(nIndex)->dst_edg][aggindex].cFlowTree.FindNext(NewFlow)>0))
+					||(EdgeAggrLink[RX][cFlowTree.Entry(nIndex)->dst_pod][cFlowTree.Entry(nIndex)->dst_edg][aggindex].RBW >= HostEdgeBW)))
+				||(EdgeAggrLink[RX][cFlowTree.Entry(nIndex)->dst_pod][cFlowTree.Entry(nIndex)->dst_edg][aggindex].cFlowTree.IsEmpty()))
+		{
+			//Whether there is at least one flow with lower priority:
+			//Check dst aggregation-core stage
+			for (int AggPort=0;AggPort<NumCorPerAgg;AggPort++)
+			{
+				int coreindex = AggPort+aggindex*NumCorPerAgg;
+
+				if(		((!AggrCoreLink[RX][cFlowTree.Entry(nIndex)->dst_pod][aggindex][coreindex].cFlowTree.IsEmpty())&&
+							(((AggrCoreLink[RX][cFlowTree.Entry(nIndex)->dst_pod][aggindex][coreindex].RBW < HostEdgeBW)
+								&&(AggrCoreLink[RX][cFlowTree.Entry(nIndex)->dst_pod][aggindex][coreindex].cFlowTree.FindNext(NewFlow)>0))
+							||(AggrCoreLink[RX][cFlowTree.Entry(nIndex)->dst_pod][aggindex][coreindex].RBW >= HostEdgeBW)))
+						||(AggrCoreLink[RX][cFlowTree.Entry(nIndex)->dst_pod][aggindex][coreindex].cFlowTree.IsEmpty()))
+				{
+					//srcAggindex is equal to the dstAggindex
+					//Check src aggregation-core stage
+					if(		((!AggrCoreLink[TX][cFlowTree.Entry(nIndex)->src_pod][aggindex][coreindex].cFlowTree.IsEmpty()) &&
+									(((AggrCoreLink[TX][cFlowTree.Entry(nIndex)->src_pod][aggindex][coreindex].RBW < HostEdgeBW)
+											&&(AggrCoreLink[TX][cFlowTree.Entry(nIndex)->src_pod][aggindex][coreindex].cFlowTree.FindNext(NewFlow)>0))
+									||(AggrCoreLink[TX][cFlowTree.Entry(nIndex)->src_pod][aggindex][coreindex].RBW < HostEdgeBW)))
+							||(AggrCoreLink[TX][cFlowTree.Entry(nIndex)->src_pod][aggindex][coreindex].cFlowTree.IsEmpty()))
+					{
+						//Check src edge-aggregation stage
+						if(		((!EdgeAggrLink[TX][cFlowTree.Entry(nIndex)->src_pod][cFlowTree.Entry(nIndex)->src_edg][aggindex].cFlowTree.IsEmpty()) &&
+										(((EdgeAggrLink[TX][cFlowTree.Entry(nIndex)->src_pod][cFlowTree.Entry(nIndex)->src_edg][aggindex].RBW < HostEdgeBW)
+												&&(EdgeAggrLink[TX][cFlowTree.Entry(nIndex)->src_pod][cFlowTree.Entry(nIndex)->src_edg][aggindex].cFlowTree.FindNext(NewFlow)>0))
+										||	(EdgeAggrLink[TX][cFlowTree.Entry(nIndex)->src_pod][cFlowTree.Entry(nIndex)->src_edg][aggindex].RBW >= HostEdgeBW)))
+								||(EdgeAggrLink[TX][cFlowTree.Entry(nIndex)->src_pod][cFlowTree.Entry(nIndex)->src_edg][aggindex].cFlowTree.IsEmpty()))
+						{
+							//Check src host-edge stage
+							if(!HostEdgeLink[TX][cFlowTree.Entry(nIndex)->src_pod][cFlowTree.Entry(nIndex)->src_edg][cFlowTree.Entry(nIndex)->src_index].cFlowTree.IsEmpty())
+							{
+								if (HostEdgeLink[TX][cFlowTree.Entry(nIndex)->src_pod][cFlowTree.Entry(nIndex)->src_edg][cFlowTree.Entry(nIndex)->src_index].RBW < HostEdgeBW)
+								{
+									Res = HostEdgeLink[TX][cFlowTree.Entry(nIndex)->src_pod][cFlowTree.Entry(nIndex)->src_edg][cFlowTree.Entry(nIndex)->src_index].cFlowTree.FindNext(NewFlow);
+									DBGMARK(DBG,7,"Res:%d",Res);
+									if (Res<=0)
+									{
+										return false;
+									}
+								}
+							}
+							return true;
+						}
+					}
+				}
+			}
+		}
+	}
+	return false;
+}
+
+bool cController::FindPath(int nIndex,list<int> &FinalList,SPath &sPath)
+{
+	list<int> PreemptionList(7);
+	FinalList=PreemptionList;
+	bool FirstTime=true;
+	bool IsBlocked=true;
+	bool IsFound=false;
+	SFlow sFlowTmp(cSortedTree.Entry(cFlowTree.Entry(nIndex)->Sorted_Index));
+
+	int RemBW=65000; //Remaining BW
+	SLink *sLink[6];
+	int FlowIndex[6];
+	int MaxPriorityIndex;
+	SSortedTableEntry sMaxPriority;
+	sMaxPriority.remaining_size=0xFFFFFFFF;
+
+	for (int AggIndex=0;AggIndex<NumAggPerPod;AggIndex++)
+	{
+		for (int AggPort=0;AggPort<NumCorPerAgg;AggPort++)
+		{
+			int CoreIndex = AggPort+AggIndex*NumCorPerAgg;
+			IsBlocked=false;
+			list<int> LinkFlowList[6];
+			//Check All Flows that can be preempted in the Edge-Agg link;
+
+			int RemBWTmp=65000;
+			int MaxPriorityIndexTmp;
+			/**
+			 * Init ///////////////////////////////////////////////////
+			 *
+			 **/
+			//Define Links
+			sLink[0]=&HostEdgeLink[TX][cFlowTree.Entry(nIndex)->src_pod][cFlowTree.Entry(nIndex)->src_edg][cFlowTree.Entry(nIndex)->src_index];
+			sLink[1] = &EdgeAggrLink[TX][cFlowTree.Entry(nIndex)->src_pod][cFlowTree.Entry(nIndex)->src_edg][AggIndex];
+			sLink[2] = &AggrCoreLink[TX][cFlowTree.Entry(nIndex)->src_pod][AggIndex][CoreIndex];
+			sLink[3] = &AggrCoreLink[RX][cFlowTree.Entry(nIndex)->dst_pod][AggIndex][CoreIndex];
+			sLink[4] = &EdgeAggrLink[RX][cFlowTree.Entry(nIndex)->dst_pod][cFlowTree.Entry(nIndex)->dst_edg][AggIndex];
+			sLink[5]=&HostEdgeLink[RX][cFlowTree.Entry(nIndex)->dst_pod][cFlowTree.Entry(nIndex)->dst_edg][cFlowTree.Entry(nIndex)->dst_index];
+
+			DBGMARK(DBG,1,"\n");
+			//Create list of lower priority flows in the corresponding path if there is a need for preemption
+			for (int nLinkIndex=0;nLinkIndex<6;nLinkIndex++)
+			{
+				for (int Index=sLink[nLinkIndex]->cFlowTree.FindNext(sFlowTmp);Index>0;Index=sLink[nLinkIndex]->cFlowTree.Next(Index))
+				{
+					if(sLink[nLinkIndex]->RBW < HostEdgeBW)
+						LinkFlowList[nLinkIndex].push_front(sLink[nLinkIndex]->cFlowTree.Entry(Index)->sEntry->OrgIndex);
+				}
+
+				if(sLink[nLinkIndex]->RBW < HostEdgeBW && LinkFlowList[nLinkIndex].empty())
+				{
+					DBGMARK(DBG,7,"This path is not available!\n");
+					IsBlocked = true;
+				}
+			}
+			//Go to the next path.
+			if(IsBlocked) continue;
+			//If at least one path is not blocked: we have a solution!
+			IsFound=true;
+			DBGMARK(DBG,7,"\n");
+			//Create none empty lists. We at least have one none empty list, if we are here!
+			list<int> Box[6];
+			list<int>::iterator iter[6];
+			int BoxNum=0;
+
+			for (int nLinkIndex=0;nLinkIndex<6;nLinkIndex++)
+			{
+				int RBWTmp_[6];
+				//No change in RM BW of this link since the flow will be preempt another flow.
+				if(!LinkFlowList[nLinkIndex].empty())
+				{
+					RBWTmp_[nLinkIndex] = sLink[nLinkIndex]->RBW;
+					Box[BoxNum]=LinkFlowList[nLinkIndex];
+					iter[BoxNum]=Box[BoxNum].begin();
+					BoxNum++;
+				}
+				//there is enough room. No preemption is needed; therefore, decrease the tmp remaining BW
+				else
+				{
+					RBWTmp_[nLinkIndex] = sLink[nLinkIndex]->RBW - HostEdgeBW;
+				}
+
+				if(RemBWTmp>RBWTmp_[nLinkIndex])
+				{
+					RemBWTmp=RBWTmp_[nLinkIndex];
+				}
+			}
+			for(int BoxIndex=0;BoxIndex<BoxNum;BoxIndex++)
+			{
+				DBGMARK(DBG,7,"BoxIndex:%d Size:%d\n",BoxIndex,Box[BoxIndex].size());
+			}
+			DBGMARK(DBG,7,"BoxNum:%d\n",BoxNum);
+			bool done=false;
+			//Create list of lower priority flows which we can preempt them.
+			while(!done)
+			{
+				list<int> PmListTmp(0);
+				for(int BoxIndex=0;BoxIndex<BoxNum;BoxIndex++)
+				{
+					PmListTmp.push_front(*iter[BoxIndex]);
+					DBGMARK(DBG,7,"pushing:(fid:%d)\n",cFlowTree.Entry(*iter[BoxIndex])->flowid);
+				}
+				for(list<int>::iterator i=PmListTmp.begin();i!=PmListTmp.end();i++)
+				{
+					DBGMARK(DBG,7,"list:%d",*i);
+				}
+
+				DBGMARK(DBG,7,"PreemptionList.size():%d PmListTmp.size():%d\n",PreemptionList.size(),PmListTmp.size());
+				PmListTmp.unique();
+				//FIXME: here it is better to do a random selection between the lists with equal sizes.
+				//With the following approach, we will select the list with lowest priorities (the lowest priorities will be added in final stages).
+				if(PreemptionList.size()>=PmListTmp.size())
+				{
+					PreemptionList=PmListTmp;
+				}
+
+				done=true;
+				for(int Index=BoxNum-1;Index>=0;Index--)
+				{
+					iter[Index]++;
+					if(iter[Index]!=Box[Index].end())
+					{
+						for(int k=Index+1;k<BoxNum;k++)
+						{
+							iter[k]=Box[k].begin();
+						}
+						done=false;
+						break;
+					}
+					else
+					{
+						iter[Index]--;
+					}
+				}
+			}
+			SSortedTableEntry sflowtmp;
+			if(PreemptionList.size())
+			{
+				for(list<int>::iterator i=PreemptionList.begin();i!=PreemptionList.end();i++)
+				{
+					//Get Max priority
+					if(sflowtmp.remaining_size < (cSortedTree.Entry(cFlowTree.Entry(*i)->Sorted_Index)->remaining_size))
+					{
+						sflowtmp=*cSortedTree.Entry(cFlowTree.Entry(*i)->Sorted_Index);
+						MaxPriorityIndexTmp = *i;
+					}
+
+					DBGMARK(DBG,7,"list:%d",*i);
+				}
+
+				if((cSortedTree.Entry(cFlowTree.Entry(MaxPriorityIndexTmp)->Sorted_Index)->remaining_size) < sMaxPriority.remaining_size)
+				{
+					sMaxPriority=*cSortedTree.Entry(cFlowTree.Entry(MaxPriorityIndexTmp)->Sorted_Index);
+				}
+			}
+			//Calculate Final best flow list (and Path)
+//			for(list<int>::iterator i=FinalList.begin();i!=FinalList.end();i++)
+//			{
+//				DBGMARK(DBG,1,"PreFinal list of flowid:%d \t",cFlowTree.Entry(*i)->flowid);
+//			}
+
+			if((FinalList.size()>PreemptionList.size()) || ((FinalList.size()==PreemptionList.size()) && (RemBW>RemBWTmp)))
+			{
+				DBGMARK(DBG,7,"(RemBW:%d RemBWTmp:%d, AggIndex:%d,CoreIndex:%d)\n",RemBW,RemBWTmp,AggIndex,CoreIndex);
+				FinalList=PreemptionList;
+				sPath.AggIndex = AggIndex;
+				sPath.CoreIndex= CoreIndex;
+				//Calculate the Bottleneck BW of the Path
+				RemBW=RemBWTmp;
+			}
+			///////////////////////////////////////////////////////////////////////////////////////////////////////////
+			//Now FinalList shows the optimum list of flows that should be preempted in this path.
+			//Notice:
+			//		: If path is empty (or with enough BW), FinalList is empty.
+			//		: This list will be used after invoking this function, to signal "stop" to the ones in the list.
+			///////////////////////////////////////////////////////////////////////////////////////////////////////////
+			for(list<int>::iterator i=FinalList.begin();i!=FinalList.end();i++)
+			{
+				DBGMARK(DBG,1,"list of flowid:%d remainingSize:%d\t",cFlowTree.Entry(*i)->flowid,cSortedTree.Entry(cFlowTree.Entry(*i)->Sorted_Index)->remaining_size);
+			}
+		}
+	}
+
+	if(IsFound)
+	{
+		if(FinalList.size())
+		{
+			if ((FinalList.size()*cSortedTree.Entry(cFlowTree.Entry(nIndex)->Sorted_Index)->remaining_size) > sMaxPriority.remaining_size)
+			{
+				DBGMARK(DBG_MIN_MAX_PRIORITY,1,"Could use preemption but there is minMax issue! :)\n");
+				DBGMARK(DBG_MIN_MAX_PRIORITY,1,"MAX[id: %d, rem.size:%d], Num.Preempt:%d, InputPriority:%d \n",sMaxPriority.flowid,sMaxPriority.remaining_size,FinalList.size(),cSortedTree.Entry(cFlowTree.Entry(nIndex)->Sorted_Index)->remaining_size);
+				IsFound=false;
+			}
+		}
+	}
+		for(list<int>::iterator i=FinalList.begin();i!=FinalList.end();i++)
+		{
+			DBGMARK(DBG,2,"list of flowid:%d remainingSize:%d\t",cFlowTree.Entry(*i)->flowid,cSortedTree.Entry(cFlowTree.Entry(*i)->Sorted_Index)->remaining_size);
+		}
+	DBGMARK(DBG,2,"Isfound:%d\n",IsFound);
+	return IsFound;
+}
+
+void cController::ManageNewInsertion(int OrgIndex,list<int> FinalList,SPath sPath)
+{
+	DBGMARK(DBG,6,"***************\n");
+	/**Fixme: Should we reschedule the preempted ones?
+	 * Just for now: Stop the ones which we should preempt.
+	 * We should do this after rescheduling the stopped ones.
+	 * We don't like out-of-order delivery!
+	 */
+	for(list<int>::iterator i=FinalList.begin();i!=FinalList.end();i++)
+	{
+
+		cSortedTree.Entry(cFlowTree.Entry(*i)->Sorted_Index)->ePreState=cSortedTree.Entry(cFlowTree.Entry(*i)->Sorted_Index)->eState;
+		//Remove it from its path's links.
+		RemoveFlow(*i);
+
+		//Fixme: Should we reschedule the preempted ones?
+		//To skip it in rescheduling. Just for now...
+		cSortedTree.Entry(cFlowTree.Entry(*i)->Sorted_Index)->eState=eWillBeStopped;
+		SendSignal(cFlowTree.Entry(*i)->Sorted_Index,eStopped);
+	}
+	int nIndex= cFlowTree.Entry(OrgIndex)->Sorted_Index;
+	cSortedTree.Entry(nIndex)->ePreState=cSortedTree.Entry(nIndex)->eState;
+	cSortedTree.Entry(nIndex)->eState=eAllowed;
+	cSortedTree.Entry(nIndex)->last_time=now();
+	cSortedTree.Entry(nIndex)->sPath=sPath;
+	AddFlow(OrgIndex);
+	SendSignal(nIndex,eAllowed);
+}
+
+void cController::ReSchedule(int ind)
+{
+	DBGMARK(DBG,2,"Starting...\n");
+	for(int nIndex=ind;nIndex>0;nIndex=cSortedTree.Next(nIndex))
+//	for(int nIndex=cSortedTree.First();nIndex>0;nIndex=cSortedTree.Next(nIndex))
+	{
+		if(cSortedTree.Entry(nIndex)->eState==eStopped)
+		{
+			bool Res = CheckAvailableBW(cSortedTree.Entry(nIndex)->OrgIndex);
+			if (Res)
+			{
+				list<int> FinalList(7);
+				SPath sPath;
+				Res = FindPath(cSortedTree.Entry(nIndex)->OrgIndex,FinalList,sPath);
+				if(Res)
+				{
+					DBGMARK(DBG,1,"Accepting this flow (id:%d,state:%d)...\n",cSortedTree.Entry(nIndex)->flowid,cSortedTree.Entry(nIndex)->eState);
+					ManageNewInsertion(cSortedTree.Entry(nIndex)->OrgIndex,FinalList,sPath);
+					DBGMARK(DBG,7,"\n");
+				}
+			}
+		}
+	}
+	for(int nIndex=ind;nIndex>0;nIndex=cSortedTree.Next(nIndex))
+//	for(int nIndex=cSortedTree.First();nIndex>0;nIndex=cSortedTree.Next(nIndex))
+	{
+		if(cSortedTree.Entry(nIndex)->eState==eWillBeStopped)
+		{
+			cSortedTree.Entry(nIndex)->eState=eStopped;
+		}
+	}
+	DBGMARK(DBG,2,"end.\n");
+}
+
+void cController::Schedule(int index)
+{
+	DBGMARK(DBG,2,"\n");
+
+	Update();
+
+	int nIndex=cFlowTree.Entry(index)->Sorted_Index;
+
+	int Res = CheckAvailableBW(index);
+
+	if (Res==false)
+	{
+		DBGMARK(DBG,1,"We can not accept this flow (%d, state:%d) yet! Wait...\n",cSortedTree.Entry(nIndex)->flowid,cSortedTree.Entry(nIndex)->eState);
+		if(cSortedTree.Entry(nIndex)->eState!=eStopped)
+		{
+			cSortedTree.Entry(nIndex)->ePreState=cSortedTree.Entry(nIndex)->eState;
+			cSortedTree.Entry(nIndex)->eState=eStopped;
+			SendSignal(nIndex,eStopped);
+		}
+	}
+	else
+	{
+		DBGMARK(DBG,1,"Accepting this flow (id:%d,state:%d)...\n",cSortedTree.Entry(nIndex)->flowid,cSortedTree.Entry(nIndex)->eState);
+		list<int> FinalList(7);
+		SPath sPath;
+		Res=FindPath(index,FinalList,sPath);
+		if(Res)
+		{
+			DBGMARK(DBG,1,"\n");
+			ManageNewInsertion(index,FinalList,sPath);
+			DBGMARK(DBG,1,"\n");
+		}
+		else
+		{
+			DBGMARK(DBG,1,"We can not accept this flow (%d, state:%d) yet! Wait...\n",cSortedTree.Entry(nIndex)->flowid,cSortedTree.Entry(nIndex)->eState);
+			if(cSortedTree.Entry(nIndex)->eState!=eStopped)
+			{
+				cSortedTree.Entry(nIndex)->ePreState=cSortedTree.Entry(nIndex)->eState;
+				cSortedTree.Entry(nIndex)->eState=eStopped;
+				SendSignal(nIndex,eStopped);
+			}
+		}
+		DBGMARK(DBG,1,"Done!\n");
+	}
+	//Reschedule teh flows with State==eStopped & Stop All flows with State==eWillBeStopped
+//	int nextIndex=cSortedTree.Next(cFlowTree.Entry(index)->Sorted_Index);
+	int nextIndex=cSortedTree.First();
+	if(Res && nextIndex>0)
+		ReSchedule(nextIndex);
+	DBGMARK(DBG,5,"***************pair:%d flowid:%d %d\n",cSortedTree.Entry(nIndex)->pairid,cSortedTree.Entry(nIndex)->flowid
+			,cSortedTree.Entry(nIndex)->eState);
+}
+
+void cController::RemoveFlow(int OrgIndex)
+{
+	if(cSortedTree.Entry(cFlowTree.Entry(OrgIndex)->Sorted_Index)->eState!=eAllowed)
+	{
+		DBGMARK(DBG,0,"ERROR! This Flow is not eAllowed.\n");
+		return;
+	}
+	int AggIndex = cSortedTree.Entry(cFlowTree.Entry(OrgIndex)->Sorted_Index)->sPath.AggIndex;
+	int CoreIndex= cSortedTree.Entry(cFlowTree.Entry(OrgIndex)->Sorted_Index)->sPath.CoreIndex;
+	SLink *sLink[6];
+
+	SFlow FlowTmp(cSortedTree.Entry(cFlowTree.Entry(OrgIndex)->Sorted_Index));
+
+	sLink[0]=&HostEdgeLink[TX][cFlowTree.Entry(OrgIndex)->src_pod][cFlowTree.Entry(OrgIndex)->src_edg][cFlowTree.Entry(OrgIndex)->src_index];
+	sLink[1] = &EdgeAggrLink[TX][cFlowTree.Entry(OrgIndex)->src_pod][cFlowTree.Entry(OrgIndex)->src_edg][AggIndex];
+	sLink[2] = &AggrCoreLink[TX][cFlowTree.Entry(OrgIndex)->src_pod][AggIndex][CoreIndex];
+	sLink[3] = &AggrCoreLink[RX][cFlowTree.Entry(OrgIndex)->dst_pod][AggIndex][CoreIndex];
+	sLink[4] = &EdgeAggrLink[RX][cFlowTree.Entry(OrgIndex)->dst_pod][cFlowTree.Entry(OrgIndex)->dst_edg][AggIndex];
+	sLink[5]=&HostEdgeLink[RX][cFlowTree.Entry(OrgIndex)->dst_pod][cFlowTree.Entry(OrgIndex)->dst_edg][cFlowTree.Entry(OrgIndex)->dst_index];
+
+	DBGMARK(DBG,3,"now:%f Deleting Flow id:%d state:%d remainingSize:%d Path:{Agg:%d,Core:%d}\n",now()
+			,cSortedTree.Entry(cFlowTree.Entry(OrgIndex)->Sorted_Index)->flowid,cSortedTree.Entry(cFlowTree.Entry(OrgIndex)->Sorted_Index)->eState
+			,cSortedTree.Entry(cFlowTree.Entry(OrgIndex)->Sorted_Index)->remaining_size,
+			cSortedTree.Entry(cFlowTree.Entry(OrgIndex)->Sorted_Index)->sPath.AggIndex,cSortedTree.Entry(cFlowTree.Entry(OrgIndex)->Sorted_Index)->sPath.CoreIndex);
+
+	DBGMARK(DBG,3,"now:%f Deleting Flow id:%d state:%d remainingSize:%d Path:{Agg:%d,Core:%d}\n",now()
+			,FlowTmp.sEntry->flowid,FlowTmp.sEntry->eState,FlowTmp.sEntry->remaining_size,
+			FlowTmp.sEntry->sPath.AggIndex,FlowTmp.sEntry->sPath.CoreIndex);
+
+	for(int LinkIndex=0;LinkIndex<6;LinkIndex++)
+	{
+		DBGMARK(DBG,5,"********************** LinkIndex:%d ... id:%d ... rem_size:%d\n",LinkIndex, FlowTmp.sEntry->flowid,FlowTmp.sEntry->remaining_size);
+		int nIndex=sLink[LinkIndex]->cFlowTree.Del(FlowTmp);
+		DBGMARK(DBG,5,"********************** LinkIndex:%d ... id:%d ... rem_size:%d\n",LinkIndex, FlowTmp.sEntry->flowid,FlowTmp.sEntry->remaining_size);
+		//		int nRes=sLink[LinkIndex]->cFlowTree.Del(FlowTmp);
+		if(nIndex>=0)
+		{
+			sLink[LinkIndex]->RBW+=HostEdgeBW;
+			if(sLink[LinkIndex]->RBW > 10)
+			{
+				DBGMARK(DBG,0,"{(%d,%d,%d) -> (%d,%d,%d)  @ sLink[%d]=[agg:%d][core:%d]->RBW:%d} \n",
+						cFlowTree.Entry(OrgIndex)->src_pod,cFlowTree.Entry(OrgIndex)->src_edg,cFlowTree.Entry(OrgIndex)->src_index
+						,cFlowTree.Entry(OrgIndex)->dst_pod,cFlowTree.Entry(OrgIndex)->dst_edg,cFlowTree.Entry(OrgIndex)->dst_index
+						,LinkIndex,AggIndex,CoreIndex,sLink[LinkIndex]->RBW);
+				ShowLinksFlows(sLink[LinkIndex]);
+			}
+		}
+		else
+		{
+			DBGMARK(DBG,0,"{(%d,%d,%d) -> (%d,%d,%d)  @ sLink[%d]=[agg:%d][core:%d]->RBW:%d} \n",
+					cFlowTree.Entry(OrgIndex)->src_pod,cFlowTree.Entry(OrgIndex)->src_edg,cFlowTree.Entry(OrgIndex)->src_index
+					,cFlowTree.Entry(OrgIndex)->dst_pod,cFlowTree.Entry(OrgIndex)->dst_edg,cFlowTree.Entry(OrgIndex)->dst_index
+					,LinkIndex,AggIndex,CoreIndex,sLink[LinkIndex]->RBW);
+			ShowLinksFlows(sLink[LinkIndex]);
+
+			DBGMARK(DBG,0,"Error! Can not Find it: nIndex{%d}\n",nIndex);
+			DBGERROR("ABORTTING!\n");
+			abort();
+		}
+	}
+}
+
+void cController::AddFlow(int OrgIndex)
+{
+	if(cSortedTree.Entry(cFlowTree.Entry(OrgIndex)->Sorted_Index)->eState!=eAllowed)
+	{
+		DBGMARK(DBG,0,"ERROR! This Flow is not allowed.\n");
+		return;
+	}
+
+	int AggIndex = cSortedTree.Entry(cFlowTree.Entry(OrgIndex)->Sorted_Index)->sPath.AggIndex;
+	int CoreIndex= cSortedTree.Entry(cFlowTree.Entry(OrgIndex)->Sorted_Index)->sPath.CoreIndex;
+	SLink *sLink[6];
+
+	SFlow FlowTmp(cSortedTree.Entry(cFlowTree.Entry(OrgIndex)->Sorted_Index));
+
+	sLink[0]=&HostEdgeLink[TX][cFlowTree.Entry(OrgIndex)->src_pod][cFlowTree.Entry(OrgIndex)->src_edg][cFlowTree.Entry(OrgIndex)->src_index];
+	sLink[1] = &EdgeAggrLink[TX][cFlowTree.Entry(OrgIndex)->src_pod][cFlowTree.Entry(OrgIndex)->src_edg][AggIndex];
+	sLink[2] = &AggrCoreLink[TX][cFlowTree.Entry(OrgIndex)->src_pod][AggIndex][CoreIndex];
+	sLink[3] = &AggrCoreLink[RX][cFlowTree.Entry(OrgIndex)->dst_pod][AggIndex][CoreIndex];
+	sLink[4] = &EdgeAggrLink[RX][cFlowTree.Entry(OrgIndex)->dst_pod][cFlowTree.Entry(OrgIndex)->dst_edg][AggIndex];
+	sLink[5]=&HostEdgeLink[RX][cFlowTree.Entry(OrgIndex)->dst_pod][cFlowTree.Entry(OrgIndex)->dst_edg][cFlowTree.Entry(OrgIndex)->dst_index];
+
+	DBGMARK(DBG,3,"now:%f Adding Flow id:%d state:%d remainingSize:%d Path:{Agg:%d,Core:%d}\n",now()
+			,cSortedTree.Entry(cFlowTree.Entry(OrgIndex)->Sorted_Index)->flowid,cSortedTree.Entry(cFlowTree.Entry(OrgIndex)->Sorted_Index)->eState
+			,cSortedTree.Entry(cFlowTree.Entry(OrgIndex)->Sorted_Index)->remaining_size,
+			cSortedTree.Entry(cFlowTree.Entry(OrgIndex)->Sorted_Index)->sPath.AggIndex,cSortedTree.Entry(cFlowTree.Entry(OrgIndex)->Sorted_Index)->sPath.CoreIndex);
+
+	DBGMARK(DBG,3,"now:%f Deleting Flow id:%d state:%d remainingSize:%d Path:{Agg:%d,Core:%d}\n",now()
+			,FlowTmp.sEntry->flowid,FlowTmp.sEntry->eState,FlowTmp.sEntry->remaining_size,
+			FlowTmp.sEntry->sPath.AggIndex,FlowTmp.sEntry->sPath.CoreIndex);
+
+	for(int LinkIndex=0;LinkIndex<6;LinkIndex++)
+	{
+		DBGMARK(DBG,5,"********************** LinkIndex:%d ... id:%d ... rem_size:%d\n",LinkIndex, FlowTmp.sEntry->flowid,FlowTmp.sEntry->remaining_size);
+		int res= sLink[LinkIndex]->cFlowTree.Add(FlowTmp);
+		DBGMARK(DBG,5,"********************** LinkIndex:%d ... id:%d ... rem_size:%d\n",LinkIndex, FlowTmp.sEntry->flowid,FlowTmp.sEntry->remaining_size);
+		//FIXME: We should not write following lines! Somewhere, something is wrong! :(
+		if(res>=0)
+		{
+			sLink[LinkIndex]->RBW-=HostEdgeBW;
+		}
+		else
+		{
+			DBGMARK(DBG,0,"{(%d,%d,%d) -> (%d,%d,%d)  @ sLink[%d]=[agg:%d][core:%d]->RBW:%d} \n",
+					cFlowTree.Entry(OrgIndex)->src_pod,cFlowTree.Entry(OrgIndex)->src_edg,cFlowTree.Entry(OrgIndex)->src_index
+					,cFlowTree.Entry(OrgIndex)->dst_pod,cFlowTree.Entry(OrgIndex)->dst_edg,cFlowTree.Entry(OrgIndex)->dst_index
+					,LinkIndex,AggIndex,CoreIndex,sLink[LinkIndex]->RBW);
+			ShowLinksFlows(sLink[LinkIndex]);
+//			sLink[LinkIndex]->RBW=0;
+			DBGERROR("ABORTTING!\n");
+			abort();
+		}
+		//Show table:
+//		for(int i=sLink[LinkIndex]->cFlowTree.First();i>0;i=sLink[LinkIndex]->cFlowTree.Next(i))
+//		{
+//			DBGMARK(DBG,1,"Table:\nLink:%d\tFlowID:%dRem Size:%d\n",LinkIndex,sLink[LinkIndex]->cFlowTree.Entry(i)->sEntry->flowid,sLink[LinkIndex]->cFlowTree.Entry(i)->sEntry->remaining_size);
+//		}
+
+	}
+}
+
+void cController::ShowLinksFlows(SLink *sLink)
+{
+	DBGMARK(DBG,2,"On this Link:\n");
+	for(int i=sLink->cFlowTree.First();i>0;i=sLink->cFlowTree.Next(i))
+	{
+		DBGMARK(DBG,0,"now:%f id:%d state:%d remainingSize:%d Path:{Agg:%d,Core:%d}\n",now()
+				,sLink->cFlowTree.Entry(i)->sEntry->flowid,sLink->cFlowTree.Entry(i)->sEntry->eState
+				,sLink->cFlowTree.Entry(i)->sEntry->remaining_size,
+				sLink->cFlowTree.Entry(i)->sEntry->sPath.AggIndex,sLink->cFlowTree.Entry(i)->sEntry->sPath.CoreIndex);
+
+		int OrgIndex=sLink->cFlowTree.Entry(i)->sEntry->OrgIndex;
+		DBGMARK(DBG,0,"\t\t\t\t{(%d,%d,%d) -> (%d,%d,%d)} \n",
+					cFlowTree.Entry(OrgIndex)->src_pod,cFlowTree.Entry(OrgIndex)->src_edg,cFlowTree.Entry(OrgIndex)->src_index
+					,cFlowTree.Entry(OrgIndex)->dst_pod,cFlowTree.Entry(OrgIndex)->dst_edg,cFlowTree.Entry(OrgIndex)->dst_index);
+
+	}
+}
+
+void cController::ShowTable()
+{
+	for(int nIndex=cSortedTree.First();nIndex>0;nIndex=cSortedTree.Next(nIndex))
+	{
+
+		if(cSortedTree.Entry(nIndex)->eState==eAllowed)
+		{
+			DBGMARK(DBG,1,"now:%f start:%lf id:%d state:%d prestate:%d remainingSize:%d Path:{Agg:%d,Core:%d}\n",now()
+					,cSortedTree.Entry(nIndex)->start_time,cSortedTree.Entry(nIndex)->flowid,cSortedTree.Entry(nIndex)->eState,cSortedTree.Entry(nIndex)->ePreState
+					,cSortedTree.Entry(nIndex)->remaining_size,cSortedTree.Entry(nIndex)->sPath.AggIndex,cSortedTree.Entry(nIndex)->sPath.CoreIndex);
+			int OrgIndex=cSortedTree.Entry(nIndex)->OrgIndex;
+			DBGMARK(DBG,2,"\t\t\t\t{(%d,%d,%d) -> (%d,%d,%d)} \n",
+						cFlowTree.Entry(OrgIndex)->src_pod,cFlowTree.Entry(OrgIndex)->src_edg,cFlowTree.Entry(OrgIndex)->src_index
+						,cFlowTree.Entry(OrgIndex)->dst_pod,cFlowTree.Entry(OrgIndex)->dst_edg,cFlowTree.Entry(OrgIndex)->dst_index);
+		}
+	}
+}
+
+void cController::SendSignal(int nIndex,EFlowState eState)
+{
+	if (eState==eAllowed)
+	{
+		int nPath = 0;
+		int AggrAddrBase=((0x00) + NumAggPerPod*cFlowTree.Entry(cSortedTree.Entry(nIndex)->OrgIndex)->src_pod);
+		int AggAddress = AggrAddrBase+cSortedTree.Entry(nIndex)->sPath.AggIndex;
+		int CoreAddrBase=NumAggPerPod*NumPod;
+		int CoreAddress=CoreAddrBase+cSortedTree.Entry(nIndex)->sPath.CoreIndex;
+
+		nPath = (AggAddress & 0x7F);
+		DBGMARK(DBG,7,"nPath:%08x\n",nPath);
+		nPath <<=8;
+		DBGMARK(DBG,7,"nPath:%08x\n",nPath);
+		nPath |= (CoreAddress & 0x7F);
+		DBGMARK(DBG,7,"nPath:%08x\n",nPath);
+		nPath <<=16;
+		nPath |= 0xFFFF;
+		DBGMARK(DBG,7,"nPath:%08x\n",nPath);
+
+		DBGMARK(DBG,5,"#####     %s signal %d %d %s %d", this->name(),cSortedTree.Entry(nIndex)->pairid,cSortedTree.Entry(nIndex)->flowid,"Go",nPath);
+		Tcl::instance().evalf("%s signal %d %d %s %d", this->name(),cSortedTree.Entry(nIndex)->pairid,cSortedTree.Entry(nIndex)->flowid,"Go",nPath);
+	}
+	else
+	{
+		DBGMARK(DBG,5,"#####     %s signal %d %d %s #####\n",this->name(),cSortedTree.Entry(nIndex)->pairid,cSortedTree.Entry(nIndex)->flowid,"Stop");
+		Tcl::instance().evalf("%s signal %d %d %s 0", this->name(),cSortedTree.Entry(nIndex)->pairid,cSortedTree.Entry(nIndex)->flowid,"Stop");
+	}
+
+}
+
+int cController::command(int argc, const char*const* argv)
+{
+	DBGMARK(DBG,7,"argc=%d\n",argc);
+	if (argc == 13)
+	{	DBGMARK(DBG,7,"\n");
+		if (strcmp(argv[1], "set_rem_size") == 0)
+		{
+				DBGMARK(DBG,5,"set_rem_size!\n");
+				SetRemainingSize(atoi(argv[2]),atoi(argv[3]),atoi(argv[4]),atoi(argv[5]),atoi(argv[6]),atoi(argv[7])
+						,atoi(argv[8]),atoi(argv[9]),atoi(argv[10]),atoi(argv[11]),atoi(argv[12]));
+				return(TCL_OK);
+		}
+	}
+	else if (argc == 12) {
+		if (strcmp(argv[1], "request") == 0) {
+				DBGMARK(DBG,5,"new incoming request!\n");
+				NewRequest(atoi(argv[2]),atoi(argv[3]),atoi(argv[4]),atoi(argv[5]),atoi(argv[6]),atoi(argv[7])
+						,atoi(argv[8]),atoi(argv[9]),atoi(argv[10]),atoi(argv[11]));
+				return(TCL_OK);
+		}
+		if (strcmp(argv[1], "rm-request") == 0) {
+				DBGMARK(DBG,5,"Removing request\n");
+				RemoveRequest(atoi(argv[2]),atoi(argv[3]),atoi(argv[4]),atoi(argv[5]),atoi(argv[6]),atoi(argv[7])
+						,atoi(argv[8]),atoi(argv[9]),atoi(argv[10]),atoi(argv[11]));
+				return(TCL_OK);
+		}
+	}
+	else if (argc ==2)
+	{
+		if (strcmp(argv[1], "showtabel") == 0)
+		{
+			ShowTable();
+			return(TCL_OK);
+		}
+	}
+	else if (argc ==8)
+	{
+		if (strcmp(argv[1], "settop") == 0)
+		{
+			SetTop(atoi(argv[2]),atoi(argv[3]),atoi(argv[4]),atoi(argv[5]),atoi(argv[6]),atoi(argv[7]));
+			return(TCL_OK);
+		}
+	}
+	else if (argc ==5)
+	{
+		if (strcmp(argv[1], "setbw") == 0)
+		{
+			SetBW(atoi(argv[2]),atoi(argv[3]),atoi(argv[4]));
+			return(TCL_OK);
+		}
+	}
+	return (TclObject::command(argc, argv));
+}
+
+void cController::SetTop(int NumHostPerEdge, int NumEdgPerPod, int NumAggPerPod, int NumCorPerAgg,int NumPod, int NumCore)
+{
+	this->NumCore=NumCore;
+	this->NumPod=NumPod;
+	this->NumAggPerPod=NumAggPerPod;
+	this->NumCorPerAgg=NumCorPerAgg;
+	this->NumEdgPerPod=NumEdgPerPod;
+	this->NumHostPerEdge=NumHostPerEdge;
+}
+
+void cController::SetBW(int HostEdgeBW, int EdgeAggBW, int AggCoreBW)
+{
+	this->HostEdgeBW=HostEdgeBW;
+	this->EdgeAggBW=EdgeAggBW;
+	this->AggCoreBW=AggCoreBW;
+	InitializeBW();
+}
+
+
+//int cController::SetPath(int *pPath, int nSize)
+//{
+//	int nPath = 0;
+//	int AggrAddrBase=0;
+//	int CoreAddrBase=NumAggPerPod*NumPod;
+//	DBGMARK(DBG,1,"CoreAddrBase:%08x\n",CoreAddrBase);
+//	nPath = (AggrAddrBase & 0x7F + NumAggPerPod*cFlowTree.Entry(cSortedTree.Entry(nIndex)->OrgIndex)->src_pod);
+//	DBGMARK(DBG,1,"nPath:%08x\n",nPath);
+//	nPath <<=8;
+//	DBGMARK(DBG,1,"nPath:%08x\n",nPath);
+//	nPath |= ((CoreAddrBase+1) & 0x7F );
+//	DBGMARK(DBG,1,"nPath:%08x\n",nPath);
+//	nPath <<=16;
+//	nPath |= 0xFFFF;
+//	DBGMARK(DBG,1,"nPath:%08x\n",nPath);
+//}
diff -rpuN ns-allinone-2.34.base/ns-2.34/common/controller.h ns-allinone-2.34.hyline/ns-2.34/common/controller.h
--- ns-allinone-2.34.base/ns-2.34/common/controller.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-allinone-2.34.hyline/ns-2.34/common/controller.h	2016-05-31 12:00:16.000000000 -0400
@@ -0,0 +1,221 @@
+/** ====================================================================
+ *
+ *  	Copyright 2015,  Abbasloo, All rights reserved.
+ *  	Email : ab.@nyu.edu
+ *
+ *  	New York University
+ *
+ * ===================================================================== **/
+
+#ifndef NS_2_34_COMMON_CONTROLLER_H_
+#define NS_2_34_COMMON_CONTROLLER_H_
+
+#include "common.h"
+#include "RBTree.h"
+#include <tclcl.h>
+#include "scheduler.h"
+#include <list>
+
+enum EFlowState
+{
+	eInit=0,
+	eStopped,
+	eWillBeStopped,
+	eAllowed
+};
+
+#define MAX_PORT_NUM		10
+#define MAX_CORE_NUM		(MAX_PORT_NUM*MAX_PORT_NUM)/4
+#define MAX_POD_NUM			MAX_PORT_NUM
+#define MAX_AGG_PER_POD		MAX_PORT_NUM/2
+#define MAX_EDG_PER_POD		MAX_PORT_NUM/2
+#define MAX_HOST_PER_EDG	35
+
+#define MAX_FLOW_PER_LINK	MAX_PORT_NUM+1
+
+#define MAX_FLOW_NUM 10001
+
+#define RX		0
+#define TX		1
+#define DBG		0
+#define DBG_MIN_MAX_PRIORITY 0
+struct SPath
+{
+	int AggIndex;
+	int CoreIndex;
+};
+
+struct SFlowEntry: public SRBTreeNode<int>
+{
+	int Sorted_Index;
+	int pairid;
+	int flowid;
+	int deadline;
+	int size;
+	int src_pod;
+	int src_edg;
+	int src_index;
+	int dst_pod;
+	int dst_edg;
+	int dst_index;
+
+	SFlowEntry(int pairid=0,int fid=0,int size=0,int deadline=0,int src_pod=0,int src_edg=0,int src_index=0,int dst_pod=0,int dst_edg=0,int dst_index=0);
+	void Copy(SFlowEntry sEntry);
+	bool operator<(const SFlowEntry& other) const;
+	bool operator!=(const SFlowEntry& other) const;
+	SFlowEntry& operator=(const SFlowEntry& other);
+};
+struct SSortedTableEntry: public SRBTreeNode<int>
+{
+	int OrgIndex;//Its Corresponding Index in FlowTable
+	int pairid;
+	int flowid;
+	int deadline;
+
+	EFlowState eState;
+	EFlowState ePreState;
+
+	double start_time;
+	double last_time;//last time that the flow got the permission.
+	int remaining_size;
+	int remaining_deadline;
+
+	SPath sPath;
+
+	SSortedTableEntry(int pairid=0,int fid=0,int size=0,int deadline=0, double start_time=0)
+	{
+		OrgIndex=0;//parent
+		this->pairid=pairid;
+		this->flowid=fid;
+		this->deadline=deadline;
+		this->start_time=start_time;
+		last_time=0;
+		this->remaining_size=size;
+		this->remaining_deadline=deadline;
+		eState = eInit;
+		ePreState = eInit;
+		sPath.AggIndex=(-1);
+		sPath.CoreIndex=(-1);
+	};
+	void Copy(SSortedTableEntry sEntry);
+	bool operator<(const SSortedTableEntry& other) const;
+	bool operator!=(const SSortedTableEntry& other) const;
+	SSortedTableEntry& operator=(const SSortedTableEntry& other);
+
+};
+struct SFlowTable
+{
+	//We could make the size a param and bind it too.
+	SFlowEntry sTable[MAX_FLOW_NUM];//Max size is 10,000 flows
+};
+struct SSortedTable
+{
+	//We could make the size a param and bind it too.
+	SSortedTableEntry sTable[MAX_FLOW_NUM];//Max size is 10,000 flows
+};
+
+struct SFlow: public SRBTreeNode<int>
+{
+	SSortedTableEntry *sEntry;
+	SFlow(SSortedTableEntry *sEntry=NULL);
+	void Copy(SFlow sEntry);
+	bool operator<(const SFlow& other) const;
+	bool operator!=(const SFlow& other) const;
+	SFlow& operator=(const SFlow& other);
+
+	//unique function in list works with the following!
+	bool operator==(const SFlow& other) const;
+};
+
+struct SFlows
+{
+	//Fixme: Make it dynamic
+	//Max size is 10 flows
+	SFlow sTable[MAX_FLOW_PER_LINK];
+};
+
+struct SLink
+{
+	//Fixme: Till Now: we sort flows by their priorities. So to find a flow with its FlowID, we should linearly search it.
+	void UpdatePriority(int fid, int priority);
+	CRBTree<SFlow> cFlowTree;
+	SFlows sFlows;
+	int RBW;					//Remaining BW
+};
+
+
+class cController: public TclObject
+{
+public:
+	cController();
+	void SetRemainingSize(int pairid,int fid,int size,int deadline,int src_pod,
+			int src_edg,int src_index,int dst_pod,int dst_edg,int dst_index,int RemainingSize);
+	void NewRequest(int pairid, int fid,int size,int deadline,int src_pod,
+			int src_edg,int src_index,int dst_pod,int dst_edg,int dst_index);
+	void RemoveRequest(int pairid, int fid,int size,int deadline,int src_pod,
+			int src_edg,int src_index,int dst_pod,int dst_edg,int dst_index);
+	void Init();
+	/**
+	 * Scheduling Related Functions
+	 */
+	void Schedule(int index);
+	void ReSchedule(int index);
+	bool CheckAvailableBW(int index);
+	bool AllocateBW(int nIndex);
+	bool FindPath(int index,list<int> &FinalList,SPath &sPath);
+	void RemoveFlow(int OrgIndex);
+	void AddFlow(int OrgIndex);
+	void ManageNewInsertion(int OrgIndex,list<int> FinalList,SPath sPath);
+	void ShowLinksFlows(SLink *sLink);
+
+	void SendSignal(int nIndex,EFlowState eState);
+//	int SetPath(int *pPath, int nSize=4);
+	virtual int command(int argc, const char*const* argv);
+	inline double now() { return Scheduler::instance().clock(); }
+	void ShowTable();
+	void SetTop(int NumHostPerEdge, int NumEdgPerPod, int NumAggPerPod, int NumCorPerAgg,int NumPod, int NumCore);
+	void SetBW(int HostEdgeBW, int EdgeAggBW, int AggCoreBW);
+
+private:
+	void InitializeBW();
+	void Update();
+private:
+	/**
+	 * We wont use dynamic structure here.
+	 * We saw issues with triple pointer initialization in NS2.
+	 * So here static arrays are used.
+	 */
+
+	SLink HostEdgeLink[2][MAX_POD_NUM][MAX_EDG_PER_POD][MAX_HOST_PER_EDG]; // [a][b][c] a:pod index, b: edge per pod index, c: host per edge index
+	SLink EdgeAggrLink[2][MAX_POD_NUM][MAX_EDG_PER_POD][MAX_AGG_PER_POD];
+	SLink AggrCoreLink[2][MAX_POD_NUM][MAX_AGG_PER_POD][MAX_CORE_NUM];
+
+public:
+	CRBTree<SFlowEntry> cFlowTree;
+	SFlowTable sFlowTable;
+
+	CRBTree<SSortedTableEntry> cSortedTree;
+	SSortedTable sSortedTable;
+
+	int NumCore;
+	int NumPod;
+	int NumCorPerAgg;
+	int NumAggPerPod;
+	int NumEdgPerPod;
+	int NumHostPerEdge;
+
+	int HostEdgeBW;
+	int EdgeAggBW;
+	int AggCoreBW;
+};
+
+static class ControllerClass : public TclClass {
+public:
+	ControllerClass() : TclClass("Controller") {}
+	TclObject* create(int, const char*const*) {
+		return (new cController());
+	}
+} class_controller_dcn;
+
+
+#endif /* NS_2_34_COMMON_CONTROLLER_H_ */
diff -rpuN ns-allinone-2.34.base/ns-2.34/common/ip.h ns-allinone-2.34.hyline/ns-2.34/common/ip.h
--- ns-allinone-2.34.base/ns-2.34/common/ip.h	2009-06-14 13:35:45.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/common/ip.h	2016-05-01 17:02:22.000000000 -0400
@@ -61,6 +61,32 @@ struct hdr_ip {
 	ns_addr_t	dst_;
 	int		ttl_;
 
+	/**
+	 * : It is the path determined by the controller,
+	 * Consider it as IEEE QinQ structure. we have different vlan tags showing the next hop in a multipath scenarios.
+	 * path structure: 4Bytes: each Byte shows next hop {only where there is a multipath option},
+	 * at most four hops are supported. {FirstOption|SecondOption|ThirdOption|FourthOption}
+	 * MSB in each Byte shows whether this byte is used by the previous switches.
+	 * If not used, the switch should use the first available option.
+	 * It is like striping VLAN tag on output when they are used.
+	 */
+	int path_;
+	/**
+	 * this bit shows whether the path is determined by the controller.
+	 * 1 indicates next hop is known, 0 indicates that we should use normal structure including ECMP.
+	 */
+	bool path_enable_;
+	bool& path_enable() {return (path_enable_); }
+	int& path() {return (path_); }
+
+	/* Mohammad: flag to indicate 
+	 * the last TCP ack for this flow 
+	 * had EcnEcho set. This is used by 
+	 * TBF to determin if flow should be 
+	 *paced. */
+	int             gotecnecho;
+	//abd
+
 	/* Monarch extn */
 // 	u_int16_t	sport_;
 // 	u_int16_t	dport_;
@@ -68,6 +94,7 @@ struct hdr_ip {
 	/* IPv6 */
 	int		fid_;	/* flow id */
 	int		prio_;
+	int 	prio_type_; //Shuang
 
 	static int offset_;
 	inline static int& offset() { return offset_; }
@@ -87,6 +114,7 @@ struct hdr_ip {
 	/* ipv6 fields */
 	int& flowid() { return (fid_); }
 	int& prio() { return (prio_); }
+	int& prio_type() {return (prio_type_); }
 };
 
 #endif
diff -rpuN ns-allinone-2.34.base/ns-2.34/common/object.h ns-allinone-2.34.hyline/ns-2.34/common/object.h
--- ns-allinone-2.34.base/ns-2.34/common/object.h	2009-06-14 13:35:45.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/common/object.h	2016-05-01 17:02:22.000000000 -0400
@@ -38,6 +38,7 @@
 #define ns_object_h
 
 #include "scheduler.h"
+#include "common.h"
 
 #define NOW Scheduler::instance().clock()
 
@@ -60,6 +61,10 @@ public:
 	virtual int delay_bind_dispatch(const char *varName, const char *localName, TclObject *tracer);
 	inline int isdebug() const { return debug_; }
 	virtual void debug(const char *fmt, ...);
+
+	//: PFC functionality
+	virtual int CheckState(Packet* p){DBGMARK(0,0,"No one has defined it yet! Returning Normal State.\n"); return 0;}
+	virtual bool IsMultiPathForwarder(NsObject*node){DBGMARK(0,0,"error! No one has defined it yet!\n"); return false;}
 protected:
 	virtual void reset();
 	void handle(Event*);
diff -rpuN ns-allinone-2.34.base/ns-2.34/common/packet.h ns-allinone-2.34.hyline/ns-2.34/common/packet.h
--- ns-allinone-2.34.base/ns-2.34/common/packet.h	2009-06-14 13:35:44.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/common/packet.h	2016-05-01 17:02:22.000000000 -0400
@@ -47,6 +47,15 @@
 #include "packet-stamp.h"
 #include "ns-process.h"
 
+//--------------------------------------------------------------------------
+/**
+ * : PFC Definitions
+ */
+#define PFC_NORMAL_STS		0
+#define PFC_PAUSED_STS		1
+
+//--------------------------------------------------------------------------
+
 // Used by wireless routing code to attach routing agent
 #define RT_PORT		255	/* port that all route msgs are sent to */
 
diff -rpuN ns-allinone-2.34.base/ns-2.34/common/RBTree.h ns-allinone-2.34.hyline/ns-2.34/common/RBTree.h
--- ns-allinone-2.34.base/ns-2.34/common/RBTree.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-allinone-2.34.hyline/ns-2.34/common/RBTree.h	2016-05-31 11:58:20.000000000 -0400
@@ -0,0 +1,1319 @@
+/** ====================================================================
+ * 		RBTree.h
+ *
+ *  	Copyright 2015,  Abbasloo, All rights reserved.
+ *      Email : ab.@nyu.edu
+ *
+ * ===================================================================== **/
+
+#ifndef NS_2_34_COMMON_RBTREE_H_
+#define NS_2_34_COMMON_RBTREE_H_
+
+
+#include <stdio.h>
+#include "common.h"
+
+enum EColor{Red,Black};
+enum EAddType{TreeBase,IndexBase};
+
+#define RBDBG 5
+#define RBNULL (-1)
+/**
+*  Red Black tree node Str.
+*/
+template<class Type>
+struct SDLLPrimary
+{
+	Type nNext;
+	Type nPrev;
+}__attribute__((packed));
+
+/**
+ * IMPORTANT:"class Type" HAVE TO BE A SIGNED TYPENAME which includes "Signed Char,Signed Short int & Signed int"
+ */
+template<class Type>
+struct SRBTreeNode : protected SDLLPrimary<Type>
+{
+public:
+	template<class xEntry> friend class CRBTree;
+protected:
+	Type nRight;
+	Type nLeft;
+	Type nParent;	//nParent for Index 0 Points to the Root of Tree (m_pxTable[0].nParent)!
+	Type nColor;	//nColor for Index 0 Shows the Number of Nodes in Tree (Number of Active Nodes).
+	Type nFree;		//nFree.0(nFree%2) = 1 ==> Free -	nFree.0 = 0 ==> Full -	(nFree/2) > 0 Indicates Next Free Index.
+//	virtual const xEntry& operator = (const xEntry& x) = 0;
+
+}__attribute__((packed));
+
+/**
+*   the Red-Black tree encapsulates basic dictionary operator such as find,insert,erase and so on
+*   the insert and erase function implemented by iterate method.
+*/
+
+template<class xEntry>
+class CRBTree{
+public:
+
+	CRBTree(xEntry* pxTable, int nEntryCount)
+	{
+		m_nAddType = TreeBase;
+		m_pxTable = pxTable;
+		m_nEntryCount = nEntryCount;
+	};
+	//-------------------------------------------------------------
+	CRBTree()__attribute__ ((noinline))
+	{
+		m_nAddType = TreeBase;
+		m_pxTable = 0;
+		m_nEntryCount = 0;
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	~CRBTree()__attribute__ ((noinline)){}
+	//-------------------------------------------------------------
+	/**Initialize Table Entries------(nKindOfLL)?TreeBase:IndexBase;
+	 *
+	 * @param pxTable
+	 * @param nEntryCount
+	 * @param nReset
+	 * @param nKindOfLL
+	 * @return
+	 */
+	int Initialize(xEntry* pxTable, int nEntryCount, int nReset, int nKindOfLL= true) __attribute__ ((noinline))
+	{
+		m_pxTable = pxTable;
+		if(CHECK_POINTER(m_pxTable))
+		{
+			m_nEntryCount = nEntryCount;
+			if (nKindOfLL)
+				m_nAddType = TreeBase;
+			else
+				m_nAddType = IndexBase;
+
+			if(nReset)
+			{
+				//Initialize all entries
+				//Root:
+				//Allocator: Reserved in Location "0" of Array
+				m_pxTable[0].nParent = RBNULL;
+				m_pxTable[0].nLeft = RBNULL;
+				m_pxTable[0].nParent = RBNULL;
+				m_pxTable[0].nRight = RBNULL;
+				m_pxTable[0].nFree = 3;
+				m_pxTable[0].nColor = 0;
+
+				m_pxTable[0].nNext = 0;
+				m_pxTable[0].nPrev = 0;
+
+				for(int nIndex=1; nIndex<m_nEntryCount;nIndex++)
+				{
+					m_pxTable[nIndex].nNext = 0;
+					m_pxTable[nIndex].nPrev = 0;
+					m_pxTable[nIndex].nLeft = RBNULL;
+					m_pxTable[nIndex].nParent = RBNULL;
+					m_pxTable[nIndex].nRight = RBNULL;
+					m_pxTable[nIndex].nColor = Red;
+					int n = ((nIndex+1)% m_nEntryCount);
+					m_pxTable[nIndex].nFree = (2 * ((n)?n:1)) + 1;
+				}
+			}
+		}
+		else
+		{
+			DBGWARN("Error:Null pointer\n\r");
+			m_nEntryCount = 0 ;
+			return ERES_ERR_OPERATION_FAILED;
+		}
+		return ERES_SUCCESS;
+	}
+	//-------------------------------------------------------------
+
+	int Initialize() __attribute__ ((noinline))
+	{
+		if(CHECK_POINTER(m_pxTable))
+		{
+			//Initialize all entries
+			//Root:
+			//Allocator: Reserved in Location "0" of Array
+			m_pxTable[0].nParent = RBNULL;
+			m_pxTable[0].nLeft = RBNULL;
+			m_pxTable[0].nParent = RBNULL;
+			m_pxTable[0].nRight = RBNULL;
+			m_pxTable[0].nFree = 3;
+			m_pxTable[0].nColor = 0;
+
+			m_pxTable[0].nNext = 0;
+			m_pxTable[0].nPrev = 0;
+
+			for(int nIndex=1; nIndex<m_nEntryCount;nIndex++)
+			{
+				m_pxTable[nIndex].nNext = 0;
+				m_pxTable[nIndex].nPrev = 0;
+				m_pxTable[nIndex].nLeft = RBNULL;
+				m_pxTable[nIndex].nParent = RBNULL;
+				m_pxTable[nIndex].nRight = RBNULL;
+				m_pxTable[nIndex].nColor = Red;
+				int n = ((nIndex+1)% m_nEntryCount);
+				m_pxTable[nIndex].nFree = (2 * ((n)?n:1)) + 1;
+			}
+		}
+		else
+		{
+			DBGWARN("Error:Null pointer\n\r");
+			m_nEntryCount = 0 ;
+			return ERES_ERR_OPERATION_FAILED;
+		}
+		return ERES_SUCCESS;
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	/** the number of nodes in the red black tree
+	 *
+	 * @return
+	 */
+	int Size()
+	{
+		return m_pxTable[0].nColor;
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	/**  whether the tree is empty or not;
+	 *
+	 * @return
+	 */
+	bool IsEmpty()
+	{
+		return m_pxTable[0].nParent==RBNULL;
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	/**get the minimum element ( return location(>0) on success, <0 on error)
+	 *
+	 * @return
+	 */
+	const int GetMin()
+       {
+	      return  GetMin(m_pxTable[0].nParent);
+	 }
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	/**get the minimum element ( return location(>0) on success, <0 on error)
+	 *
+	 * @return
+	 */
+	const int GetMax()
+	{
+		return GetMax(m_pxTable[0].nParent);
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	/**Return Next Index of (exist or not exist)Entry: if any(>0 if exist) else return < 0
+	 *
+	 * @param x
+	 * @return
+	 */
+	int FindNext(const xEntry &x) __attribute__ ((noinline))
+	{
+		int tmp=m_pxTable[0].nParent;
+		bool bFirstTimeInit = true;
+		int nResultIndexTmp = RBNULL;
+		int nResultIndex = RBNULL;
+		if (0>tmp)
+			return RBNULL;
+		else
+		{
+			while (tmp>=0)
+			{
+				int nRes = Compare(x,m_pxTable[tmp]);
+				if (nRes<0)
+				{
+					tmp=m_pxTable[tmp].nRight;
+				}
+				else if(nRes>0)
+				{
+					nResultIndexTmp = tmp ;
+					if(!bFirstTimeInit)
+					{
+						int nRes2 = Compare(m_pxTable[nResultIndexTmp],m_pxTable[nResultIndex]);
+						if(nRes2 > 0 )
+						{
+							nResultIndex = nResultIndexTmp;
+						}
+					}
+					else
+					{
+						nResultIndex = tmp ;
+						bFirstTimeInit = false;
+					}
+
+					tmp=m_pxTable[tmp].nLeft;
+				}
+				else
+				{
+					return Next(tmp);
+
+					/*tmp=m_pxTable[tmp].nRight;
+
+					if(tmp>=0)
+					{
+						return (GetMin(tmp));
+					}
+					else
+					{
+						return nResultIndex;
+					}*/
+				}
+			}
+		}
+		return nResultIndex;
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	/**Return Previous Index of (exist or not exist)Entry: if any(>0 if exist) else return < 0
+	 *
+	 * @param x
+	 * @return
+	 */
+	int FindPrev(const xEntry &x) __attribute__ ((noinline))
+	{
+		int tmp=m_pxTable[0].nParent;
+		bool bFirstTimeInit = true;
+		int nResultIndexTmp = RBNULL;
+		int nResultIndex = RBNULL;
+		if (0>tmp)
+			return RBNULL;
+		else
+		{
+			while (tmp>=0)
+			{
+				int nRes = Compare(x,m_pxTable[tmp]);
+				if (nRes<0)
+				{
+					nResultIndexTmp = tmp ;
+					if(!bFirstTimeInit)
+					{
+						int nRes2 = Compare(m_pxTable[nResultIndexTmp],m_pxTable[nResultIndex]);
+						if(nRes2 < 0 )
+						{
+							nResultIndex = nResultIndexTmp;
+						}
+					}
+					else
+					{
+						nResultIndex = tmp ;
+						bFirstTimeInit = false;
+					}
+
+					tmp=m_pxTable[tmp].nRight;
+				}
+				else if(nRes>0)
+				{
+					tmp=m_pxTable[tmp].nLeft;
+				}
+				else
+				{
+					tmp=m_pxTable[tmp].nLeft;
+					if(tmp>=0)
+					{
+						return (GetMax(tmp));
+					}
+					else
+					{
+						return nResultIndex;
+					}
+				}
+			}
+		}
+		return nResultIndex;
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	/**Return Next Index of (exist)Entry if any(>0 if exist)
+	 *
+	 * @param rxEntry
+	 * @param nArrayIndex
+	 * @return
+	 */
+	int Next(xEntry& rxEntry)
+	{
+		int nIndex = Find(rxEntry);
+		if(nIndex>0)
+		{
+			if(IsIndexActive(nIndex))
+				return m_pxTable[nIndex].nNext;
+			else
+				return ERES_ERR_OPERATION_FAILED;
+		}
+		else
+			return ERES_ERR_OPERATION_FAILED;
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	/**Return Next Index of (exist)Entry if any(>0 if exist)
+	 *
+	 * @param rxEntry
+	 * @param nArrayIndex
+	 * @return
+	 */
+	//FIXME: {SA} next failed if operator= has not been implemented by user(it may affect other functions too)
+	int Next(int nArrayIndex)
+	{
+		if((nArrayIndex<=0)|| (nArrayIndex>=m_nEntryCount))//not Found
+		{
+			DBGPRINT(RBDBG,1,"Out of Range index {%d}!\n\r",nArrayIndex);
+			return ERES_ERR_OPERATION_FAILED;
+		}
+		if(IsIndexActive(nArrayIndex))
+			return m_pxTable[nArrayIndex].nNext;
+
+		DBGPRINT(RBDBG,1,"There is no such an index {%d}, This Index is Free!\n\r",nArrayIndex);
+		return RBNULL;
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	/**return Index if Entry found(>0)
+	 *
+	 * @param x
+	 * @param nArrayIndex
+	 * @return
+	 */
+	int Find(const xEntry &x) __attribute__ ((noinline))
+	{
+		int nIndex = Find(m_pxTable[0].nParent,x);
+		if((nIndex>0))
+		{
+			if(IsIndexActive(nIndex))
+				return nIndex;
+			else
+			{
+				DBGPRINT(RBDBG,1,"The Entry is Free!\n\r");
+				return ERES_ERR_OPERATION_FAILED;
+			}
+		}
+		else
+		{
+			DBGPRINT(RBDBG,1,"No Entry Found!\n\r");
+			return ERES_ERR_OPERATION_FAILED;
+		}
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	/**return Pointer to Entry if Entry found, else NULL
+	 *
+	 * @param x
+	 * @param nArrayIndex
+	 * @return
+	 */
+	xEntry* FindE(const xEntry &x)
+	{
+		int nIndex = Find(m_pxTable[0].nParent,x);
+		if(nIndex>0)
+		{
+			if(IsIndexActive(nIndex))
+				return &m_pxTable[nIndex];
+			else
+			{
+				DBGPRINT(RBDBG,1,"There is no such an Instance out there!\n\r");
+				return NULL;
+			}
+
+		}
+		else
+			return NULL;
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	/**insert element with unique Key.if find the exist element,give an Error!
+	 *
+	 * @param x
+	 * @param nArrayIndex
+	 * @return > 0 on success
+	 */
+	int Add(const xEntry &x,int nArrayIndex=0) __attribute__ ((noinline))
+	{
+		int nFinalIndex;
+		if(CHECK_POINTER(m_pxTable))
+		{
+			//first find the insert position (node's Location in Tree) and its nParent ,call InserAux
+			int y=m_pxTable[0].nParent;
+			int p=m_pxTable[0].nParent;
+			int nNextResultIndex = RBNULL;
+			bool bNextFirstTimeInit = true;
+			int nNextResultIndexTmp = RBNULL;
+			bool bPrevFirstTimeInit = true;
+			int nPrevResultIndexTmp = RBNULL;
+			int nPrevResultIndex = RBNULL;
+			while (y>=0)
+			{
+				p=y;
+				int nRes = Compare(x,m_pxTable[y]);//1:x<y -1:x>y 0: x=y
+				if (nRes > 0)
+				{
+					nNextResultIndexTmp = y ;
+					if(!bNextFirstTimeInit)
+					{
+						int nRes2 = Compare(m_pxTable[nNextResultIndexTmp],m_pxTable[nNextResultIndex]);
+						if(nRes2 > 0 )
+						{
+							nNextResultIndex = nNextResultIndexTmp;
+						}
+					}
+					else
+					{
+						nNextResultIndex = y ;
+						bNextFirstTimeInit = false;
+					}
+
+
+					y = m_pxTable[y].nLeft;
+				}
+				else if(nRes < 0)
+				{
+					nPrevResultIndexTmp = y ;
+					if(!bPrevFirstTimeInit)
+					{
+						int nRes2 = Compare(m_pxTable[nPrevResultIndexTmp],m_pxTable[nPrevResultIndex]);
+						if(nRes2 < 0 )
+						{
+							nPrevResultIndex = nPrevResultIndexTmp;
+						}
+					}
+					else
+					{
+						nPrevResultIndex = y ;
+						bPrevFirstTimeInit = false;
+					}
+
+					y = m_pxTable[y].nRight;
+				}
+				else
+				{
+					DBGPRINT(RBDBG,1,"Error:Equal Insertion\n\r");
+					return ERES_ERR_OPERATION_FAILED;
+				}
+			}
+
+			if(InserAux(p,x,nArrayIndex,nNextResultIndex,nPrevResultIndex,nFinalIndex)<0)
+			{
+				DBGPRINT(RBDBG,1,"Error: \n\r");
+				return ERES_ERR_OPERATION_FAILED;
+			}
+			else
+			{
+				return nFinalIndex;
+			}
+		}
+		else
+		{
+			DBGWARN("Error:Null pointer\n\r");
+			return ERES_ERR_OPERATION_FAILED;
+		}
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	/**Modify Existing Entry of table( return location(>0) on success, <0 on error)
+	 *
+	 * @param rxEntry
+	 * @return
+	 */
+	int Modify(xEntry& rxEntry)
+	{
+		if(CHECK_POINTER(m_pxTable))
+		{
+			int nIndex;
+			nIndex = Find(rxEntry);
+			if(nIndex>0)
+				m_pxTable[nIndex] = rxEntry;
+			else
+				return ERES_ERR_OPERATION_FAILED;
+
+			return nIndex;
+		}
+		else
+		{
+			DBGWARN("Error:Null pointer\n\r");
+			return ERES_ERR_OPERATION_FAILED;
+		}
+	}
+    //-------------------------------------------------------------
+	//-------------------------------------------------------------
+	/**Modify Existing Entry of table (with index = nArrayIndex)( return location(>0) on success, <0 on error)
+	 *
+	 * @param rxEntry
+	 * @param nArrayIndex
+	 * @return
+	 */
+	int Modify(int nArrayIndex,xEntry& rxEntry)
+	{
+		if (nArrayIndex!=0)
+		{
+			if ((nArrayIndex > 0) && (nArrayIndex < m_nEntryCount))
+			{
+				m_pxTable[nArrayIndex] = rxEntry;
+				return nArrayIndex;
+			}
+			else
+				return ERES_ERR_OPERATION_FAILED;
+		}
+		else
+		{
+			return ERES_ERR_OPERATION_FAILED;
+		}
+	}
+    //-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	/**Erase the first element with key that equals to x
+	 *
+	 * @param x
+	 * @return
+	 */
+	int Del(const xEntry&x) __attribute__ ((noinline))
+	{
+		//only erase the first x
+		int y =m_pxTable[0].nParent;
+		while (y>=0)//Root should not Point to 0 index
+		{
+			int nRes = Compare(x,m_pxTable[y]);
+			if (nRes>0)
+				y = m_pxTable[y].nLeft;
+			else if (nRes<0)
+				y = m_pxTable[y].nRight;
+			else break;
+		}
+		return EraseAux(y);
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	/**erase the element in indexe nIndex
+	 *
+	 * @param nIndex
+	 * @return
+	 */
+	int Del(int nIndex) __attribute__ ((noinline))
+	{
+		return EraseAux(nIndex);
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	/**First(>0 if any)
+	 *
+	 * @return
+	 */
+	int First(void)
+	{
+		return ((IsEmpty())?RBNULL:m_pxTable[0].nNext);
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	int Last()
+	{
+		return ((IsEmpty())?RBNULL:m_pxTable[0].nPrev);
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	/**true if index is not free
+	 *
+	 * @param nIndex
+	 * @return
+	 */
+	int IsIndexActive(int nIndex)
+	{
+		if(!CHECK_VAR_RANGE_NB(nIndex, 0, m_nEntryCount))
+		{
+			DBGPRINT(RBDBG,1,"Invalid Index(%d)\n", nIndex);
+			return false;
+		}
+
+		return (m_pxTable[nIndex].nFree%2)?false:true;
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	/**Return Pointer To Entry
+	 *
+	 * @param nIndex
+	 * @return
+	 */
+	xEntry* Entry(int nIndex) __attribute__ ((noinline))
+	{
+		if(!CHECK_VAR_RANGE_NB(nIndex, 0, m_nEntryCount))
+		{
+			DBGERROR("Invalid Index(%d)\n", nIndex);
+			return NULL;
+		}
+		if(CHECK_POINTER(m_pxTable))
+		{
+			return &m_pxTable[nIndex];
+		}
+		else
+		{
+			DBGWARN("Error:Null pointer\n\r");
+			return NULL;
+		}
+	}
+	//-------------------------------------------------------------
+
+private:
+	int m_nAddType;
+	xEntry *m_pxTable;
+	int m_nEntryCount;
+private:
+	//-------------------------------------------------------------
+	//return Index > 0 if allocation successes else return Index < 0
+	int Allocator(int nChosenIndex) __attribute__ ((noinline))
+	{
+		if(m_nAddType==TreeBase)
+		{
+			if(nChosenIndex==0)
+			{
+				int nNextFreeIndex = m_pxTable[0].nFree/2;
+				int nFree = m_pxTable[nNextFreeIndex].nFree%2;
+				if(nNextFreeIndex==0)
+				{
+					DBGPRINT(RBDBG,1,"sorry Bro!The array is full\n\r");
+					return ERES_ERR_OPERATION_FAILED;
+				}
+				else if(nNextFreeIndex< 0)
+				{
+					DBGPRINT(RBDBG,1,"Next is Null.\n\r");
+					return ERES_ERR_OPERATION_FAILED;
+				}
+				else
+				{
+					if(nFree)
+					{
+//						DBGPRINT(RBDBG,1,"nIndex = %d\n\r",nNextFreeIndex);
+						return (nNextFreeIndex);
+					}
+					else
+					{
+						DBGPRINT(RBDBG,1,"Invalid Allocation: Index = %d\n\r",nNextFreeIndex);
+						return ERES_ERR_INVALID_OPERATION;
+					}
+				}
+
+			}
+			else
+			{
+				DBGPRINT(RBDBG,1,"The Type of addition have been set to Tree Base while an Index has been entered, Are You Kidding me?! \n\r");
+				return ERES_ERR_OPERATION_FAILED;
+			}
+		}
+		else
+		{
+			if(nChosenIndex!=0)
+			{
+				int nNextFreeIndex = nChosenIndex;
+				int nFree = m_pxTable[nNextFreeIndex].nFree%2;
+				if(nNextFreeIndex==0)
+				{
+					DBGPRINT(RBDBG,1,"sorry Bro!Invalid Location, The index 0 is reserved !\n\r");
+					return ERES_ERR_OPERATION_FAILED;
+				}
+				else if(nNextFreeIndex< 0)
+				{
+					DBGPRINT(RBDBG,1,"Next Is Null.\n\r");
+					return ERES_ERR_OPERATION_FAILED;
+				}
+				else
+				{
+					if(nFree)
+					{
+//						DBGPRINT(RBDBG,1,"nArrayIndex = %d\n\r",nNextFreeIndex);
+						return (nNextFreeIndex);
+					}
+					else
+					{
+						DBGPRINT(RBDBG,1,"sorry Bro! The Node is not Free!{%d}\n\r",nNextFreeIndex);
+						return ERES_ERR_INVALID_OPERATION;
+					}
+				}
+			}
+			else
+			{
+				DBGPRINT(RBDBG,1,"The Type of addition have been set to Index Base while a Valid Index has not been entered, Are You Kidding me?! \n\r");
+				return ERES_ERR_OPERATION_FAILED;
+			}
+		}
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+    int GetMin(int begin) __attribute__ ((noinline))
+    {
+		if (0>begin)
+		{
+			DBGPRINT(RBDBG,1,"the tree is empty,get min error!");
+			return ERES_ERR_OPERATION_FAILED;
+		}
+		else
+		{
+			int min=begin;
+			while (m_pxTable[min].nLeft>=0)
+				min=m_pxTable[min].nLeft;
+			return min;
+		}
+    }
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+    int GetMax(int begin)
+    {
+		if (0>begin)
+		{
+			DBGPRINT(RBDBG,1,"the tree is empty,get max error!");
+			return ERES_ERR_OPERATION_FAILED;
+		}
+		else
+		{
+			int max=begin;
+			while (m_pxTable[max].nRight>=0)
+			{
+				max=m_pxTable[max].nRight;
+			}
+			return max;
+		}
+    }
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+    int Find(int begin,const xEntry &x) __attribute__ ((noinline))
+	{
+		if (0>begin)
+			return RBNULL;
+		else
+		{
+			int tmp=begin;
+			while (tmp>=0)
+			{
+				int nRes = Compare(x,m_pxTable[tmp]);
+				if (nRes<0)
+					tmp=m_pxTable[tmp].nRight;
+				else if(nRes>0)
+					tmp=m_pxTable[tmp].nLeft;
+				else break;
+			}
+			return tmp;
+		}
+	}
+	//-------------------------------------------------------------
+
+    //-------------------------------------------------------------
+	void RotateLeft(int t) __attribute__ ((noinline))
+	{
+		int tmp = m_pxTable[t].nRight;
+		m_pxTable[t].nRight =  m_pxTable[tmp].nLeft;
+
+		if (m_pxTable[tmp].nLeft>=0)
+			m_pxTable[m_pxTable[tmp].nLeft].nParent = t;
+
+		m_pxTable[tmp].nLeft =t;
+		m_pxTable[tmp].nParent = m_pxTable[t].nParent;
+
+		if (t==m_pxTable[0].nParent)
+			m_pxTable[0].nParent = tmp;
+		else if (t==m_pxTable[m_pxTable[t].nParent].nLeft)
+			m_pxTable[m_pxTable[t].nParent].nLeft = tmp;
+		else
+			m_pxTable[m_pxTable[t].nParent].nRight=tmp;
+
+		m_pxTable[t].nParent =tmp;
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	void RotateRight(int t) __attribute__ ((noinline))
+	{
+
+		int tmp=m_pxTable[t].nLeft;
+		m_pxTable[t].nLeft = m_pxTable[tmp].nRight;
+
+		if (m_pxTable[tmp].nRight>=0)
+			m_pxTable[m_pxTable[tmp].nRight].nParent = t;
+
+		m_pxTable[tmp].nRight = t;
+
+
+//		if (m_pxTable[t].nParent>=0)
+		m_pxTable[tmp].nParent = m_pxTable[t].nParent;
+//		DBGPRINT(RBDBG,1,"tmp= %d - t = %d - m_pxTable[tmp].nParent = %d \n\r",tmp,t,m_pxTable[tmp].nParent );
+
+		if (t==m_pxTable[0].nParent)
+		{
+			m_pxTable[0].nParent=tmp;
+		}
+		else if (t==m_pxTable[m_pxTable[t].nParent].nLeft)
+		{
+			m_pxTable[m_pxTable[t].nParent].nLeft = tmp;
+		}
+		else
+		{
+			m_pxTable[m_pxTable[t].nParent].nRight = tmp;
+		}
+
+//	       DBGPRINT(RBDBG,1,"0) P:%d - R:%d -L:%d -  \n\r",m_pxTable[0].nParent,m_pxTable[0].nRight,m_pxTable[0].nLeft);
+
+		m_pxTable[t].nParent = tmp;
+//	       DBGPRINT(RBDBG,1,"0) P:%d - R:%d -L:%d -  \n\r",m_pxTable[0].nParent,m_pxTable[0].nRight,m_pxTable[0].nLeft);
+
+//		DBGPRINT(RBDBG,1,"Grand Parent:%d - Parent:%d |||||||||||||| Grand_Parent:%d -  \n\r",t,tmp,m_pxTable[t].nParent);
+
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	int EraseAux(int z) __attribute__ ((noinline))
+	{
+		if (0>=z)
+		{
+			DBGPRINT(RBDBG,1,"Nothing Found Baby!\n\r");
+			return ERES_ERR_OPERATION_FAILED;
+		}
+		//Free the z Location:
+
+
+		int x=0;
+		int x_parent=0;
+		int y = z;
+		if(m_pxTable[y].nLeft==RBNULL)
+			x = m_pxTable[y].nRight;
+		else if (m_pxTable[y].nRight==RBNULL)
+			x = m_pxTable[y].nLeft;
+		else
+		{
+			y=m_pxTable[y].nRight;
+			while (m_pxTable[y].nLeft>=0)
+				y = m_pxTable[y].nLeft;
+			x= m_pxTable[y].nRight;
+		}
+//		DBGPRINT(RBDBG,5," y = %d, x = %d , z = %d\n\r",y,x,z);
+		if (y!=z)
+		{
+			int nTmp;
+			//y is higher level replace node;
+			//x is nRight-leftmost (lower level ) replace node;
+			m_pxTable[m_pxTable[z].nLeft].nParent = y;
+			m_pxTable[y].nLeft=m_pxTable[z].nLeft;
+
+//			DBGPRINT(RBDBG,1," m_pxTable[z].nLeft = %d, m_pxTable[m_pxTable[z].nLeft].nParent = %d , m_pxTable[y].nLeft = %d\n\r",
+//								m_pxTable[z].nLeft,m_pxTable[m_pxTable[z].nLeft].nParent,m_pxTable[y].nLeft);
+			if (y!=m_pxTable[z].nRight)
+			{
+				x_parent = m_pxTable[y].nParent;
+				if (x>=0)
+					m_pxTable[x].nParent = m_pxTable[y].nParent;
+				m_pxTable[m_pxTable[y].nParent].nLeft = x;
+				m_pxTable[y].nRight=m_pxTable[z].nRight;
+				m_pxTable[m_pxTable[z].nRight].nParent = y ;
+//				DBGPRINT(RBDBG,1,"%d) = %d---p = %d,l= %d R = %d Color= %d ,Free = %d ,NFree = %d \n\r\n\r",y,m_pxTable[y].a,m_pxTable[y].nParent,m_pxTable[y].nLeft,m_pxTable[y].nRight,m_pxTable[y].nColor,(m_pxTable[y].nFree%2),(m_pxTable[y].nFree/2));
+
+			}
+			else
+				x_parent = y;
+			if (m_pxTable[0].nParent == z)
+				m_pxTable[0].nParent = y;
+			else if(z==m_pxTable[m_pxTable[z].nParent].nLeft)
+				m_pxTable[m_pxTable[z].nParent].nLeft = y;
+			else
+				m_pxTable[m_pxTable[z].nParent].nRight = y;
+			m_pxTable[y].nParent=m_pxTable[z].nParent;
+//			DBGPRINT(RBDBG,1,"m_pxTable[y].nColor = %d , m_pxTable[z].nColor = %d\n\r",m_pxTable[y].nColor,m_pxTable[z].nColor);
+
+//			Swap(m_pxTable[y].nColor,m_pxTable[z].nColor);
+			nTmp = m_pxTable[y].nColor;
+			m_pxTable[y].nColor = m_pxTable[z].nColor;
+			m_pxTable[z].nColor = nTmp;
+//			DBGPRINT(RBDBG,1,"m_pxTable[y].nColor = %d , m_pxTable[z].nColor = %d\n\r",m_pxTable[y].nColor,m_pxTable[z].nColor);
+//			DBGPRINT(RBDBG,1,"m_pxTable[m_pxTable[z].nParent].nRight = %d ,m_pxTable[y].nParent = %d \n\r",m_pxTable[m_pxTable[z].nParent].nRight,m_pxTable[y].nParent);
+			y = z;
+//			DBGPRINT(RBDBG,1," y = %d, x = %d , z = %d Z.Color = %d\n\r",y,x,z,m_pxTable[y].nColor);
+		}
+		else
+		{
+//			DBGPRINT(RBDBG,1," I'm Here !-------------else (y!=z) \n\r");
+			//y==z is delete node;
+			x_parent = m_pxTable[y].nParent;
+			if (x>=0)
+				m_pxTable[x].nParent = m_pxTable[y].nParent;
+			if (z==m_pxTable[0].nParent)
+				m_pxTable[0].nParent = x;
+			else
+			{
+				if (z==m_pxTable[m_pxTable[z].nParent].nLeft)
+					m_pxTable[m_pxTable[z].nParent].nLeft = x;
+				else
+					m_pxTable[m_pxTable[z].nParent].nRight = x;
+			}
+		}
+//		DBGPRINT(RBDBG,1,"m_pxTable[y].nColor = %d , m_pxTable[z].nColor = %d Red = %d\n\r",m_pxTable[y].nColor,m_pxTable[z].nColor,Red);
+		if (m_pxTable[y].nColor!=Red)
+		{
+//			DBGPRINT(RBDBG,1," I'm Here !-------------m_pxTable[y].nColor!=Red \n\r");
+			EraseFixup(x,x_parent);
+		}
+		ResetNode(z);
+		m_pxTable[z].nFree = m_pxTable[0].nFree;
+		m_pxTable[z].nFree |= 0x1;
+		m_pxTable[0].nFree = ( z << 1 ) + 1;
+		//==========================================
+		if(m_pxTable[z].nNext>0)
+		{
+			if(m_pxTable[z].nPrev>0)
+			{
+				m_pxTable[m_pxTable[z].nPrev].nNext = m_pxTable[z].nNext;
+				m_pxTable[m_pxTable[z].nNext].nPrev = m_pxTable[z].nPrev;
+			}
+			else
+			{
+				m_pxTable[m_pxTable[z].nNext].nPrev = 0;
+				m_pxTable[0].nNext = m_pxTable[z].nNext;
+			}
+		}
+		else
+		{
+			if(m_pxTable[z].nPrev>0)
+			{
+				m_pxTable[m_pxTable[z].nPrev].nNext = 0;
+				m_pxTable[0].nPrev = m_pxTable[z].nPrev;
+			}
+			else
+			{
+				m_pxTable[0].nNext = 0;
+				m_pxTable[0].nPrev = 0;
+			}
+		}
+		//==========================================
+		--m_pxTable[0].nColor;
+
+/*
+		for(int i=0;i<20;i++)
+			DBGPRINT(RBDBG,1,"%d) = %d---p = %d,l= %d R = %d Color= %d ,Free = %d ,NFree = %d , nNext = %d, nPrev = %d \n\r",i,m_pxTable[i].a,m_pxTable[i].nParent,m_pxTable[i].nLeft,m_pxTable[i].nRight,m_pxTable[i].nColor,(m_pxTable[i].nFree%2),(m_pxTable[i].nFree/2), m_pxTable[i].nNext,m_pxTable[i].nPrev);
+*/
+
+/*
+		for(int i=0;i<30;i++)
+				DBGPRINT(RBDBG,1,"%d) = %d---p = %d,l= %d R = %d Color= %d ,Free = %d ,NFree = %d \n\r\n\r",i,m_pxTable[i].a,m_pxTable[i].nParent,m_pxTable[i].nLeft,m_pxTable[i].nRight,m_pxTable[i].nColor,(m_pxTable[i].nFree%2),(m_pxTable[i].nFree/2));
+*/
+
+		return ERES_SUCCESS;
+//		delete y;
+
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	//update the x and its nParent link,then InserFixup
+
+	int InserAux(int p,const xEntry&x,int nChosenIndex,int nNextResultIndex,int nPrevResultIndex,int& nFinalIndex) __attribute__ ((noinline))
+	{
+//		Node*cur=new Node(x);
+
+		int nIndex = Allocator(nChosenIndex);
+
+		if(nIndex>0)
+		{
+
+			if (0>p)
+			{
+	//			m_pxTable[m_pxTable[0].nParent] = x;//??
+				m_pxTable[0].nParent = nIndex;
+			}
+			else
+			{
+				int nRes = Compare(x,m_pxTable[p]);
+				if (nRes>0)
+				{
+	//				x.nParent = p;
+	//				m_pxTable[m_pxTable[p].nLeft] = x;//??
+					m_pxTable[p].nLeft = nIndex;
+					m_pxTable[m_pxTable[p].nLeft].nParent = p;
+//					nIndex = m_pxTable[p].nLeft ;
+				}
+				else if (nRes<0)
+				{
+	//				m_pxTable[m_pxTable[p].nRight] = x;//??
+	//				p->nRight=cur;
+					m_pxTable[p].nRight = nIndex;
+					m_pxTable[m_pxTable[p].nRight].nParent = p;
+	//				cur->nParent=p;
+//					nIndex = m_pxTable[p].nRight;
+				}
+				else
+				{
+					DBGPRINT(RBDBG,1,"Error: Equality!\n\r");
+				}
+			}
+			InserFixup(nIndex);
+			//==========================================
+			if(nNextResultIndex>0)
+			{
+				m_pxTable[nIndex].nNext = nNextResultIndex;
+				if(m_pxTable[nNextResultIndex].nPrev>0)
+					m_pxTable[m_pxTable[nNextResultIndex].nPrev].nNext = nIndex;
+				m_pxTable[nNextResultIndex].nPrev = nIndex;
+			}
+			else
+			{
+				m_pxTable[nIndex].nNext = 0;
+			}
+			if(nPrevResultIndex>0)
+			{
+				m_pxTable[nIndex].nPrev = nPrevResultIndex;
+				m_pxTable[m_pxTable[nIndex].nPrev].nNext = nIndex;
+			}
+			else
+			{
+				m_pxTable[nIndex].nPrev = 0;
+			}
+
+			if(m_pxTable[nIndex].nPrev == 0)
+				m_pxTable[0].nNext = nIndex;
+
+			if(m_pxTable[nIndex].nNext == 0)
+				m_pxTable[0].nPrev = nIndex;
+			//==========================================
+			m_pxTable[nIndex] = x;
+			//==========================================
+			m_pxTable[nIndex].nFree &= 0xFFFFFFFE;
+			if(!IsIndexActive((m_pxTable[nIndex].nFree/2)))
+				m_pxTable[0].nFree = ( (m_pxTable[nIndex].nFree/2) << 1 ) + 1;
+			else
+				m_pxTable[0].nFree = 0x1;
+			++m_pxTable[0].nColor;
+			//==========================================
+
+/*
+			DBGPRINT(RBDBG,1,"************** Root of Tree ************\n\r");
+			DBGPRINT(RBDBG,1,"0) = ---p = %d,l= %d R = %d Color= %d ,Free = %d ,NFree = %d nNext = %d, nPrev = %d \n\r",m_pxTable[0].nParent,m_pxTable[0].nLeft,m_pxTable[0].nRight,m_pxTable[0].nColor,(m_pxTable[0].nFree%2),(m_pxTable[0].nFree/2), m_pxTable[0].nNext,m_pxTable[0].nPrev);
+*/
+
+/*
+
+			DBGPRINT(RBDBG,1,"============================================================================================\n\r");
+			for(int i=0;i<20;i++)
+				DBGPRINT(RBDBG,1,"%d) = %d---p = %d,l= %d R = %d Color= %d ,Free = %d ,NFree = %d , nNext = %d, nPrev = %d \n\r",i,m_pxTable[i].a,m_pxTable[i].nParent,m_pxTable[i].nLeft,m_pxTable[i].nRight,m_pxTable[i].nColor,(m_pxTable[i].nFree%2),(m_pxTable[i].nFree/2), m_pxTable[i].nNext,m_pxTable[i].nPrev);
+*/
+
+
+		}
+		else
+		{
+			DBGPRINT(RBDBG,1,"Error: Allocation failed\n\r");
+			return ERES_ERR_OPERATION_FAILED;
+		}
+		nFinalIndex = nIndex;
+		return ERES_SUCCESS;
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	void InserFixup(int nIndex) __attribute__ ((noinline))
+	{
+		m_pxTable[nIndex].nColor = Red;
+		while ((nIndex!=m_pxTable[0].nParent)&&(m_pxTable[m_pxTable[nIndex].nParent].nColor==Red))
+		{
+			if (m_pxTable[nIndex].nParent==m_pxTable[m_pxTable[m_pxTable[nIndex].nParent].nParent].nLeft)
+			{
+//				Node*u=c->nParent->nParent->nRight;
+				int nUncle = m_pxTable[m_pxTable[m_pxTable[nIndex].nParent].nParent].nRight;
+				if ((0>nUncle)||(m_pxTable[nUncle].nColor==Black))//Case 5
+				{
+					if (nIndex==m_pxTable[m_pxTable[nIndex].nParent].nRight)
+					{
+						nIndex=m_pxTable[nIndex].nParent;
+						RotateLeft(nIndex);
+					}
+					m_pxTable[m_pxTable[nIndex].nParent].nColor=Black;
+					m_pxTable[m_pxTable[m_pxTable[nIndex].nParent].nParent].nColor=Red;
+//					DBGPRINT(RBDBG,1,"I am Here - 0 -	me = %d, MyParent = %d MygrandPa = %d\n\r",nIndex,m_pxTable[nIndex].nParent,m_pxTable[m_pxTable[nIndex].nParent].nParent);
+					int nGP = m_pxTable[m_pxTable[nIndex].nParent].nParent;
+					RotateRight(nGP);
+				}
+				else
+				{
+					m_pxTable[m_pxTable[nIndex].nParent].nColor=Black;
+					m_pxTable[m_pxTable[m_pxTable[nIndex].nParent].nParent].nColor=Red;
+					m_pxTable[nUncle].nColor = Black;
+					nIndex = m_pxTable[m_pxTable[nIndex].nParent].nParent;
+				}
+			}
+			else
+			{
+				int nUncle = m_pxTable[m_pxTable[m_pxTable[nIndex].nParent].nParent].nLeft;
+				if ((0>nUncle)||(m_pxTable[nUncle].nColor==Black))
+				{
+					if (nIndex==m_pxTable[m_pxTable[nIndex].nParent].nLeft)
+					{
+						nIndex=m_pxTable[nIndex].nParent;
+//						DBGPRINT(RBDBG,1,"I am Here - 1 -\n\r");
+						RotateRight(nIndex);
+					}
+					m_pxTable[m_pxTable[nIndex].nParent].nColor=Black;
+					m_pxTable[m_pxTable[m_pxTable[nIndex].nParent].nParent].nColor=Red;
+					RotateLeft(m_pxTable[m_pxTable[nIndex].nParent].nParent);
+				}
+				else
+				{
+					m_pxTable[m_pxTable[nIndex].nParent].nColor=Black;
+					m_pxTable[m_pxTable[m_pxTable[nIndex].nParent].nParent].nColor=Red;
+					m_pxTable[nUncle].nColor = Black;
+					nIndex = m_pxTable[m_pxTable[nIndex].nParent].nParent;
+				}
+			}
+//			nLocalCounter++;
+//			DBGPRINT(RBDBG,1,"nLocalCounter = %d - nIndex = %d\n\r",nLocalCounter,nIndex);
+		}
+
+		m_pxTable[m_pxTable[0].nParent].nColor=Black;
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	void EraseFixup(int c,int p) __attribute__ ((noinline))
+	{
+		//c is replace node,p is c's nParent
+		while ((c!=m_pxTable[0].nParent)&&(c == RBNULL||m_pxTable[c].nColor==Black))
+		{
+			if (c==m_pxTable[p].nLeft)
+			{
+				int w=m_pxTable[p].nRight;
+				if (m_pxTable[w].nColor==Red)
+				{
+					m_pxTable[w].nColor=Black;
+					m_pxTable[p].nColor=Red;
+					RotateLeft(p);
+					w = m_pxTable[p].nRight;
+				}
+				if ((m_pxTable[w].nLeft==RBNULL||m_pxTable[m_pxTable[w].nLeft].nColor==Black)&&
+						(m_pxTable[w].nRight==RBNULL||m_pxTable[m_pxTable[w].nRight].nColor==Black))
+				{
+					m_pxTable[w].nColor=Red;
+					c = p;
+					p = m_pxTable[p].nParent;
+				}
+				else
+				{
+					if ((m_pxTable[w].nRight==RBNULL)||(m_pxTable[m_pxTable[w].nRight].nColor==Black))
+					{
+						if (m_pxTable[w].nLeft>=0)
+							m_pxTable[m_pxTable[w].nLeft].nColor=Black;
+						m_pxTable[w].nColor=Red;
+						RotateRight(w);
+						w = m_pxTable[p].nRight;
+					}
+					m_pxTable[w].nColor=m_pxTable[p].nColor;
+					m_pxTable[p].nColor=Black;
+					if (m_pxTable[w].nRight>=0)
+						m_pxTable[m_pxTable[w].nRight].nColor=Black;
+					RotateLeft(p);
+					break;
+				}
+			}
+			else
+			{
+				int w = m_pxTable[p].nLeft;
+				if (m_pxTable[w].nColor==Red)
+				{
+					m_pxTable[w].nColor=Black;
+					m_pxTable[p].nColor=Red;
+					RotateRight(p);
+					w = m_pxTable[p].nLeft;
+				}
+				if ((m_pxTable[w].nRight==RBNULL||m_pxTable[m_pxTable[w].nRight].nColor==Black)&&
+						(m_pxTable[w].nLeft==RBNULL||m_pxTable[m_pxTable[w].nLeft].nColor==Black))
+				{
+					m_pxTable[w].nColor=Red;
+					c = p;
+					p = m_pxTable[p].nParent;
+				}
+				else
+				{
+					if (m_pxTable[w].nLeft==RBNULL||m_pxTable[m_pxTable[w].nLeft].nColor==Black)
+					{
+						if (m_pxTable[w].nRight>=0)
+							m_pxTable[m_pxTable[w].nRight].nColor=Black;
+						m_pxTable[w].nColor=Red;
+						RotateLeft(w);
+						w=m_pxTable[p].nLeft;
+					}
+					m_pxTable[w].nColor = m_pxTable[p].nColor;
+					m_pxTable[p].nColor=Black;
+					if (m_pxTable[w].nLeft>=0)
+						m_pxTable[m_pxTable[w].nLeft].nColor=Black;
+					RotateRight(p);
+					break;
+				}
+			}
+		}
+		if (c>=0)
+			m_pxTable[c].nColor=Black;
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	void ResetNode(int nIndex)
+	{
+		m_pxTable[nIndex].nLeft = RBNULL;
+		m_pxTable[nIndex].nParent = RBNULL;
+		m_pxTable[nIndex].nRight = RBNULL;
+		m_pxTable[nIndex].nColor = Red;
+//		m_pxTable[nIndex].nFree = 2 * (nIndex+1) + 1;
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	int AssignValue(xEntry& xRef, xEntry& xKey)
+	{
+	     xKey.nParent = xRef.nParent;
+	     xKey.nLeft = xRef.nLeft;
+	     xKey.nRight = xRef.nRight;
+	     xKey.eNodeColor = xRef.eNodeColor;
+	     xKey.nNext =  xRef.nNext;
+	     xKey.nPrev =  xRef.nPrev;
+	     xKey.nFree =  xRef.nFree;
+
+	     return ERES_SUCCESS;
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	int Compare(const xEntry& xKeyone, const xEntry& xKeytwo)
+	{
+	    if (xKeyone < xKeytwo) return 1;
+	    else if (xKeytwo != xKeyone) return -1;
+	    else return 0;
+	}
+	//-------------------------------------------------------------
+
+	//-------------------------------------------------------------
+	void Swap(int &a,int &b)
+	{
+		int tmp=a;
+		a=b;
+		b=tmp;
+	}
+	//-------------------------------------------------------------
+
+};
+
+
+#endif /* NS_2_34_COMMON_RBTREE_H_ */
diff -rpuN ns-allinone-2.34.base/ns-2.34/gen/ns_tcl.cc ns-allinone-2.34.hyline/ns-2.34/gen/ns_tcl.cc
--- ns-allinone-2.34.base/ns-2.34/gen/ns_tcl.cc	2016-05-31 10:58:18.486815995 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/gen/ns_tcl.cc	2016-05-30 11:48:58.000000000 -0400
@@ -409,8 +409,8 @@ set rtnotif_ {}\n\
 set nodetype_ [$ns_ get-nodetype]\n\
 \n\
 $self mk-default-classifier\n\
-\n\
 set multiPath_ [$class set multiPath_]\n\
+\n\
 }\n\
 \n\
 Node instproc mk-default-classifier {} {\n\
@@ -606,6 +606,19 @@ set routes_($id) 1\n\
 } else {\n\
 if ![info exists mpathClsfr_($id)] {\n\
 set mpathClsfr_($id) [new Classifier/MultiPath]\n\
+$mpathClsfr_($id) set nodeid_ [$self id]\n\
+set nodecolor_ [$self get-attribute \"COLOR\"]\n\
+set nodetype_ 0\n\
+if {$nodecolor_ == \"green\"} {\n\
+set nodetype_ 1\n\
+}\n\
+if {$nodecolor_ == \"blue\"} {\n\
+set nodetype_ 2\n\
+}\n\
+if {$nodecolor_ == \"red\"} {\n\
+set nodetype_ 3\n\
+}\n\
+$mpathClsfr_($id) set nodetype_ $nodetype_\n\
 if {$routes_($id) > 0} {\n\
 assert \"$routes_($id) == 1\"\n\
 $mpathClsfr_($id) installNext \\\n\
@@ -614,7 +627,9 @@ $mpathClsfr_($id) installNext \\\n\
 $classifier_ install $id $mpathClsfr_($id)\n\
 }\n\
 foreach L $ifs {\n\
-$mpathClsfr_($id) installNext [$L head]\n\
+\n\
+set sl [$mpathClsfr_($id) cmd installNext [$L head] [[$L set toNode_] id]]\n\
+$mpathClsfr_($id) set slots_($sl) [$L head]			\n\
 incr routes_($id)\n\
 }\n\
 }\n\
@@ -1966,6 +1981,8 @@ $queue_ target $link_\n\
 $link_ target [$dst entry]\n\
 $queue_ drop-target $drophead_\n\
 \n\
+$queue_ nodeEntry [$dst entry]\n\
+\n\
 set ttl_ [new TTLChecker]\n\
 $ttl_ target [$link_ target]\n\
 $self ttl-drop-trace\n\
@@ -1980,7 +1997,7 @@ if { $srcRt_ == 1 } {\n\
 $self enable-src-rt $src $dst $head_\n\
 }\n\
 }\n\
-\n\
+puts \"$src $dst $head_ $queue_ $link_ $ttl_ [$dst entry]\"\n\
 }\n\
 \n\
 SimpleLink instproc enable-src-rt {src dst head} {\n\
@@ -3481,6 +3498,25 @@ return $base\n\
 \n\
 \n\
 \n\
+\n\
+Queue/RPQ instproc srcnode { src } {\n\
+$self instvar srcnode_\n\
+$self set srcnode_ $src\n\
+}\n\
+\n\
+Queue/RPQ instproc srcnode_instance {} {\n\
+$self instvar srcnode_\n\
+return $srcnode_\n\
+}\n\
+\n\
+Queue/RPQ instproc sendpfcmessage { prio duration } {\n\
+$self instvar srcnode_\n\
+puts \"calling pfcmessage @ Classifier: entry [[$self srcnode_instance] entry] pfcmessage [$srcnode_ id]  $prio $duration\"\n\
+set src [[$self srcnode_instance] entry]\n\
+$src pfcmessage [[$self srcnode_instance] id]  $prio $duration\n\
+}\n\
+\n\
+\n\
 Class CBQLink -superclass SimpleLink\n\
 CBQLink instproc init { src dst bw delay q cl {lltype \"DelayLink\"} } {\n\
 $self next $src $dst $bw $delay $q $lltype ; # SimpleLink ctor\n\
@@ -18859,9 +18895,15 @@ Queue/DropTail set drop_front_ false\n\
 Queue/DropTail set summarystats_ false\n\
 Queue/DropTail set queue_in_bytes_ false\n\
 Queue/DropTail set mean_pktsize_ 500\n\
+Queue/DropTail set drop_smart_ false\n\
+Queue/DropTail set sq_limit_ 10\n\
 \n\
 Queue/DropTail/PriQueue set Prefer_Routing_Protocols    1\n\
 \n\
+Queue/DropTail set drop_prio_ false\n\
+Queue/DropTail set deque_prio_ false\n\
+Queue/DropTail set keep_order_ false\n\
+\n\
 CMUPriQueue set qlen_logthresh_ 10\n\
 CMUPriQueue set fw_logthresh_ 25\n\
 CMUPriQueue set debug_ false\n\
@@ -18871,6 +18913,8 @@ Queue/dsRED set ecn_ 0\n\
 \n\
 Queue/XCP set tcp_xcp_on_ 0  ;\n\
 \n\
+\n\
+\n\
 Queue/RED set bytes_ true ;		# default changed on 10/11/2004.\n\
 Queue/RED set queue_in_bytes_ true ;	# default changed on 10/11/2004.\n\
 Queue/RED set thresh_ 0\n\
@@ -18906,6 +18950,115 @@ Queue/RED set top_ 0.5\n\
 Queue/RED set bottom_ 0\n\
 Queue/RED set cautious_ 0\n\
 Queue/RED set feng_adaptive_ 0\n\
+Queue/RED set pq_enable_ 0\n\
+Queue/RED set pq_mode_ 0\n\
+Queue/RED set pq_drainrate_ 0 ; # need to set this when PQ is enabled\n\
+Queue/RED set pq_thresh_ 0\n\
+Queue/RED set drop_prio_ 0\n\
+Queue/RED set deque_prio_ 0\n\
+\n\
+Agent/TCP/FullTcp/Sack/SolTCP set NI 1 ;#1Gbps\n\
+Agent/TCP set start_wait 0 \n\
+Agent/TCP set prempt_wait 0\n\
+Agent/TCP set num_prempt 0\n\
+\n\
+if {1} {\n\
+Queue/RPQ set queue_num_ 2\n\
+Queue/RPQ set pfc_enable 0\n\
+Queue/RPQ set pfc_threshold_0 500 ; #desabling pfc for queue #0\n\
+Queue/RPQ set pfc_threshold_1 175\n\
+Queue/RPQ set size_0 225\n\
+Queue/RPQ set size_1 225\n\
+Queue/RPQ set margin 10\n\
+\n\
+Queue/RPQ set bytes_ true ;		# default changed on 10/11/2004.\n\
+Queue/RPQ set queue_in_bytes_ true ;	# default changed on 10/11/2004.\n\
+Queue/RPQ set thresh_ 0\n\
+Queue/RPQ set maxthresh_ 0\n\
+Queue/RPQ set thresh_queue_ [Queue set limit_]\n\
+Queue/RPQ set maxthresh_queue_ [Queue set limit_]\n\
+Queue/RPQ set mean_pktsize_ 500\n\
+Queue/RPQ set idle_pktsize_ 100\n\
+Queue/RPQ set q_weight_ -1\n\
+Queue/RPQ set wait_ true\n\
+Queue/RPQ set linterm_ 10\n\
+Queue/RPQ set mark_p_ 0.1\n\
+Queue/RPQ set use_mark_p_ true\n\
+Queue/RPQ set setbit_ false\n\
+Queue/RPQ set gentle_ true\n\
+Queue/RPQ set drop_tail_ true\n\
+Queue/RPQ set drop_front_ false\n\
+Queue/RPQ set drop_rand_ false\n\
+Queue/RPQ set doubleq_ false\n\
+Queue/RPQ set ns1_compat_ false\n\
+Queue/RPQ set dqthresh_ 50\n\
+Queue/RPQ set ave_ 0.0\n\
+Queue/RPQ set prob1_ 0.0\n\
+Queue/RPQ set curq_ 0\n\
+Queue/RPQ set cur_max_p_ 0\n\
+Queue/RPQ set summarystats_ false\n\
+Queue/RPQ set alpha_ 0.01\n\
+Queue/RPQ set beta_ 0.9 \n\
+Queue/RPQ set adaptive_ 0\n\
+Queue/RPQ set interval_ 0.5\n\
+Queue/RPQ set targetdelay_ 0.005\n\
+Queue/RPQ set top_ 0.5\n\
+Queue/RPQ set bottom_ 0\n\
+Queue/RPQ set cautious_ 0\n\
+Queue/RPQ set feng_adaptive_ 0\n\
+Queue/RPQ set pq_enable_ 0\n\
+Queue/RPQ set pq_mode_ 0\n\
+Queue/RPQ set pq_drainrate_ 0 ; # need to set this when PQ is enabled\n\
+Queue/RPQ set pq_thresh_ 0\n\
+Queue/RPQ set drop_prio_ 0\n\
+Queue/RPQ set deque_prio_ 0\n\
+\n\
+}\n\
+if {1} {\n\
+Queue/RPQ set bytes_1 true ;		# default changed on 10/11/2004.\n\
+Queue/RPQ set queue_in_bytes_1 true ;	# default changed on 10/11/2004.\n\
+Queue/RPQ set thresh_1 0\n\
+Queue/RPQ set maxthresh_1 0\n\
+Queue/RPQ set thresh_queue_1 [Queue set limit_]\n\
+Queue/RPQ set maxthresh_queue_1 [Queue set limit_]\n\
+Queue/RPQ set mean_pktsize_1 500\n\
+Queue/RPQ set idle_pktsize_1 100\n\
+Queue/RPQ set q_weight_1 -1\n\
+Queue/RPQ set wait_1 true\n\
+Queue/RPQ set linterm_1 10\n\
+Queue/RPQ set mark_p_1 0.1\n\
+Queue/RPQ set use_mark_p_1 true\n\
+Queue/RPQ set setbit_1 false\n\
+Queue/RPQ set gentle_1 true\n\
+Queue/RPQ set drop_tail_1 true\n\
+Queue/RPQ set drop_front_1 false\n\
+Queue/RPQ set drop_rand_1 false\n\
+Queue/RPQ set doubleq_1 false\n\
+Queue/RPQ set ns1_compat_1 false\n\
+Queue/RPQ set dqthresh_1 50\n\
+Queue/RPQ set ave_1 0.0\n\
+Queue/RPQ set prob1_1 0.0\n\
+Queue/RPQ set curq_1 0\n\
+Queue/RPQ set cur_max_p_1 0\n\
+Queue/RPQ set summarystats_1 false\n\
+Queue/RPQ set alpha_1 0.01\n\
+Queue/RPQ set beta_1 0.9 \n\
+Queue/RPQ set adaptive_1 0\n\
+Queue/RPQ set interval_1 0.5\n\
+Queue/RPQ set targetdelay_1 0.005\n\
+Queue/RPQ set top_1 0.5\n\
+Queue/RPQ set bottom_1 0\n\
+Queue/RPQ set cautious_1 0\n\
+Queue/RPQ set feng_adaptive_1 0\n\
+Queue/RPQ set pq_enable_1 0\n\
+Queue/RPQ set pq_mode_1 0\n\
+Queue/RPQ set pq_drainrate_1 0 ; # need to set this when PQ is enabled\n\
+Queue/RPQ set pq_thresh_1 0\n\
+Queue/RPQ set drop_prio_1 0\n\
+Queue/RPQ set deque_prio_1 0\n\
+\n\
+}\n\
+\n\
 \n\
 Queue/RED/RIO set bytes_ false\n\
 Queue/RED/RIO set queue_in_bytes_ false\n\
@@ -18968,6 +19121,8 @@ Queue/Vq set mean_pktsize_ 1000\n\
 Queue/Vq set curq_ 0\n\
 Queue/Vq set drop_front_ 0\n\
 Queue/Vq set markfront_ 0\n\
+Queue/Vq set ctilde_ 0\n\
+Queue/Vq set vq_len_ 0\n\
 \n\
 Queue/REM set gamma_ 0.001\n\
 Queue/REM set phi_ 1.001\n\
@@ -19030,6 +19185,19 @@ QueueMonitor set pdrops_ 0\n\
 QueueMonitor set pmarks_ 0\n\
 QueueMonitor set bdrops_ 0\n\
 \n\
+QueueMonitor set num_monitor_ 50\n\
+for {set k 0} {$k < 50} {incr k} {\n\
+set tmp kdrops$k\n\
+QueueMonitor set $tmp 0\n\
+set tmp karrivals$k\n\
+QueueMonitor set $tmp 0\n\
+}\n\
+\n\
+QueueMonitor set ack_arrivals_ 0\n\
+QueueMonitor set ack_drops_ 0\n\
+QueueMonitor set ack_departures_ 0\n\
+\n\
+\n\
 QueueMonitor set qs_pkts_ 0\n\
 QueueMonitor set qs_bytes_ 0\n\
 QueueMonitor set qs_drops_ 0\n\
@@ -19112,6 +19280,10 @@ Classifier/Addr/MPLS set reroute_option_
 Classifier/Addr/MPLS set control_driven_ 0\n\
 Classifier/Addr/MPLS set data_driven_ 0\n\
 \n\
+Classifier/MultiPath set nodeid_ 0\n\
+Classifier/MultiPath set nodetype_ 0\n\
+Classifier/MultiPath set perflow_ 0\n\
+Classifier/MultiPath set checkpathid_ 0\n\
 \n\
 FECModel set debug_ false\n\
 \n\
@@ -19314,7 +19486,15 @@ NetworkInterface set debug_ false\n\
 TBF set rate_ 64k\n\
 TBF set bucket_ 1024\n\
 TBF set qlen_ 0\n\
-\n\
+TBF set pacer_enable_ 0\n\
+TBF set assoc_timeout_ 0.01\n\
+TBF set assoc_prob_ 0.125\n\
+TBF set maxrate_ 1000000000\n\
+TBF set minrate_ 10000000\n\
+TBF set qlength_factor_ 122;\n\
+TBF set rate_ave_factor_ 0.125\n\
+TBF set rate_update_interval_  0.000064\n\
+TBF set debug_ 0\n\
 MIPEncapsulator set addr_ 0\n\
 MIPEncapsulator set port_ 0\n\
 MIPEncapsulator set shift_ 0\n\
@@ -19628,6 +19808,17 @@ Agent/TCP set EnblRTTCtr_ 0\n\
 Agent/TCP set control_increase_ 0\n\
 \n\
 Agent/TCP set SetCWRonRetransmit_ true ; # added on 2005/06/19.\n\
+Agent/TCP set ecnhat_ false;\n\
+Agent/TCP set ecnhat_smooth_alpha_ true;\n\
+Agent/TCP set ecnhat_alpha_ 0.0;\n\
+Agent/TCP set ecnhat_g_ 0.125;\n\
+Agent/TCP set ecnhat_enable_beta_ false;\n\
+Agent/TCP set ecnhat_beta_ 0.0;\n\
+Agent/TCP set ecnhat_quadratic_beta_ false;\n\
+Agent/TCP set ecnhat_tcp_friendly_ false;\n\
+Agent/TCP set perPacketMP_ false;\n\
+Agent/TCP set pathAwareMP_ false;\n\
+Agent/TCP set num_paths_ 1\n\
 \n\
 Agent/TCP set nam_tracevar_ false\n\
 \n\
@@ -19659,6 +19850,7 @@ Agent/TCPSink set qs_enabled_ false\n\
 Agent/TCPSink set RFC2581_immediate_ack_ true\n\
 Agent/TCPSink set bytes_ 0\n\
 Agent/TCPSink set ecn_syn_ false ;	# Added 2005/11/21 for SYN/ACK pkts.\n\
+Agent/TCPSink set ecnhat_ false;\n\
 \n\
 Agent/TCPSink/DelAck set interval_ 100ms\n\
 catch {\n\
@@ -19780,6 +19972,21 @@ Agent/TCP/FullTcp set nopredict_ false;
 Agent/TCP/FullTcp set ecn_syn_ false; # Make SYN/ACK packet ECN-Capable?\n\
 Agent/TCP/FullTcp set ecn_syn_wait_ 0; # Wait after marked SYN/ACK? \n\
 Agent/TCP/FullTcp set debug_ false;  # Added Sept. 16, 2007.\n\
+Agent/TCP/FullTcp set flow_remaining_ -1; #Mohammad: added for robust FCT measurement\n\
+Agent/TCP/FullTcp set dynamic_dupack_ 0; # Mohammad: if non-zero, set dupack threshold to max(3, dynamic_dupack_ * cwnd_)\n\
+Agent/TCP/FullTcp set prio_scheme_ 2; #Shuang: priority scheme\n\
+Agent/TCP/FullTcp set prio_num_ 0; #Shuang: number of priority\n\
+Agent/TCP/FullTcp set pfc_enable 0; #: pfc\n\
+Agent/TCP/FullTcp set prio_cap0 6*1460+15;\n\
+Agent/TCP/FullTcp set prio_cap1 16*1460+15;\n\
+Agent/TCP/FullTcp set prio_cap2 30*1460+15;\n\
+Agent/TCP/FullTcp set prio_cap3 49*1460+15;\n\
+Agent/TCP/FullTcp set prio_cap4 266*1460+15;\n\
+Agent/TCP/FullTcp set prio_cap5 1001*1460+15;\n\
+Agent/TCP/FullTcp set prio_cap6 2825*1460+15;\n\
+Agent/TCP/FullTcp set prob_cap_ 0; #Shuang: prob mode\n\
+Agent/TCP/FullTcp set deadline 0; #Shuang: deadline\n\
+Agent/TCP/FullTcp set early_terminated_ 0; #Shuang\n\
 \n\
 Agent/TCP/FullTcp/Newreno set recov_maxburst_ 2; # max burst dur recov\n\
 \n\
@@ -19810,6 +20017,18 @@ $self instvar open_cwnd_on_pack_\n\
 set open_cwnd_on_pack_ false\n\
 }\n\
 \n\
+Agent/TCP/FullTcp/Sack/MinTCP instproc init {} {\n\
+$self next\n\
+}\n\
+\n\
+Agent/TCP/FullTcp/Sack/DDTCP instproc init {} {\n\
+$self next\n\
+}\n\
+\n\
+Agent/TCP/FullTcp/Sack/SolTCP instproc init {} {\n\
+$self next\n\
+}\n\
+\n\
 }\n\
 \n\
 if [TclObject is-class Agent/TCP/BayFullTcp] {\n\
@@ -19982,6 +20201,8 @@ Queue set util_records_ 5 ; 		# Changed
 \n\
 Delayer set debug_ false\n\
 \n\
+\n\
+\n\
 Agent/TCP/Linux set rtxcur_init_ 3\n\
 Agent/TCP/Linux set maxrto_ 120\n\
 Agent/TCP/Linux set minrto_ 0.2\n\
@@ -21337,6 +21558,21 @@ $self instvar scheduler_\n\
 $scheduler_ clearMemTrace\n\
 }\n\
 \n\
+Simulator instproc get-size { n1 n2 queuenum } {\n\
+$self instvar link_\n\
+puts \"----\"\n\
+set size [[$link_([$n1 id]:[$n2 id]) queue] get-size queuenum]\n\
+puts \"size:$size\"\n\
+}\n\
+\n\
+Simulator instproc get-thr { n1 n2 queuenum } {\n\
+$self instvar link_	\n\
+puts \"----\"\n\
+set size [[$link_([$n1 id]:[$n2 id]) queue] get-threshold queuenum]\n\
+puts \"size:$size\"\n\
+\n\
+}\n\
+\n\
 Simulator instproc simplex-link { n1 n2 bw delay qtype args } {\n\
 $self instvar link_ queueMap_ nullAgent_ useasim_\n\
 set sid [$n1 id]\n\
@@ -21405,7 +21641,14 @@ set pushback 1\n\
 set pushback 0\n\
 }\n\
 $n1 add-neighbor $n2 $pushback\n\
-\n\
+if {$qtype == \"RPQ\"} {\n\
+puts \"making an RPQ: setting proper queue's parameters\"\n\
+[$link_($sid:$did) queue] srcnode $n1 \n\
+[$link_($sid:$did) queue] get-size 0\n\
+[$link_($sid:$did) queue] get-size 1\n\
+[$link_($sid:$did) queue] get-threshold 0\n\
+[$link_($sid:$did) queue] get-threshold 1\n\
+}\n\
 if {[string first \"RED\" $qtype] != -1 || \n\
 [string first \"PI\" $qtype] != -1 || \n\
 [string first \"Vq\" $qtype] != -1 ||\n\
diff -rpuN ns-allinone-2.34.base/ns-2.34/Makefile.in ns-allinone-2.34.hyline/ns-2.34/Makefile.in
--- ns-allinone-2.34.base/ns-2.34/Makefile.in	2009-06-14 13:35:44.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/Makefile.in	2016-05-01 17:02:22.000000000 -0400
@@ -164,7 +164,7 @@ NS_TCL_LIB_STL = tcl/lib/ns-diffusion.tc
 OBJ_CC = \
 	tools/random.o tools/rng.o tools/ranvar.o common/misc.o common/timer-handler.o \
 	common/scheduler.o common/object.o common/packet.o \
-	common/ip.o routing/route.o common/connector.o common/ttl.o \
+	common/ip.o routing/route.o common/connector.o common/ttl.o common/controller.o \
 	trace/trace.o trace/trace-ip.o \
 	classifier/classifier.o classifier/classifier-addr.o \
 	classifier/classifier-hash.o \
diff -rpuN ns-allinone-2.34.base/ns-2.34/queue/drop-tail.cc ns-allinone-2.34.hyline/ns-2.34/queue/drop-tail.cc
--- ns-allinone-2.34.base/ns-2.34/queue/drop-tail.cc	2009-06-14 13:35:44.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/queue/drop-tail.cc	2016-05-01 17:02:22.000000000 -0400
@@ -87,7 +87,7 @@ void DropTail::enque(Packet* p)
 	if (summarystats) {
                 Queue::updateStats(qib_?q_->byteLength():q_->length());
 	}
-
+	//printf("qlim_ = %d, qib_ = %d, mean_pktsize_ = %d\n", qlim_, qib_, mean_pktsize_);
 	int qlimBytes = qlim_ * mean_pktsize_;
 	if ((!qib_ && (q_->length() + 1) >= qlim_) ||
   	(qib_ && (q_->byteLength() + hdr_cmn::access(p)->size()) >= qlimBytes)){
@@ -96,6 +96,77 @@ void DropTail::enque(Packet* p)
 			q_->enque(p);
 			Packet *pp = q_->deque();
 			drop(pp);
+		}
+		else if (drop_prio_) {
+			Packet *max_pp = p;
+			int max_prio = 0;
+
+			q_->enque(p);
+			q_->resetIterator();
+			for (Packet *pp = q_->getNext(); pp != 0; pp = q_->getNext()) {
+				if (!qib_ || ( q_->byteLength() - hdr_cmn::access(pp)->size() < qlimBytes)) {
+					hdr_ip* h = hdr_ip::access(pp);
+					int prio = h->prio();
+					if (prio >= max_prio) {
+						max_pp = pp;
+						max_prio = prio;
+					}
+				}
+			}
+			q_->remove(max_pp);
+			drop(max_pp);	
+		}
+		else if (drop_smart_) {
+			Packet *max_pp = p;
+			int max_count = 0;
+			
+			q_->enque(p);			
+			q_->resetIterator();
+			for (Packet *pp = q_->getNext(); pp != 0; pp = q_->getNext()) {
+				hdr_ip* h = hdr_ip::access(pp);
+				FlowKey fkey;
+				fkey.src = h->saddr();
+				fkey.dst = h->daddr();
+				fkey.fid = h->flowid();
+			
+				char* fkey_buf = (char*) &fkey;
+				int length = sizeof(fkey);
+				string fkey_string(fkey_buf, length);
+			
+				std::tr1::hash<string> string_hasher;
+				size_t signature = string_hasher(fkey_string);	
+				
+				if (sq_counts_.find(signature) != sq_counts_.end()) {
+					int count = sq_counts_[signature];
+					if (count > max_count) {
+						max_count = count;
+						max_pp = pp;
+					}
+				}				
+			}
+			q_->remove(max_pp);
+			/*hdr_ip* h = hdr_ip::access(p);
+		       	FlowKey fkey;
+	       		fkey.src = h->saddr();
+       			fkey.dst = h->daddr();
+       			fkey.fid = h->flowid();
+       		
+		        char* fkey_buf = (char*) &fkey;
+	       		int length = sizeof(fkey);
+	       		string fkey_string(fkey_buf, length);
+			
+	       		std::tr1::hash<string> string_hasher;
+	       		size_t p_sig = string_hasher(fkey_string);
+	       		h = hdr_ip::access(max_pp);
+	       		fkey.src = h->saddr();
+	       		fkey.dst = h->daddr();
+	       		fkey.fid = h->flowid();
+			
+	       		string fkey_string2(fkey_buf, length);			
+	       		size_t maxpp_sig = string_hasher(fkey_string2);
+
+			 printf("%s, enqueued %d, dropped %d instead\n", this->name(), p_sig, maxpp_sig);*/
+			drop(max_pp);		      
 		} else {
 			drop(p);
 		}
@@ -130,7 +201,96 @@ Packet* DropTail::deque()
         if (summarystats && &Scheduler::instance() != NULL) {
                 Queue::updateStats(qib_?q_->byteLength():q_->length());
         }
-	return q_->deque();
+	//printf("drop_smart_ = %d, sq_limit = %d \n", drop_smart_, sq_limit_);
+	
+	/*Shuang: deque the packet with the highest priority */
+	if (deque_prio_) {
+			q_->resetIterator();
+			Packet *p = q_->getNext();
+			int highest_prio_;
+			if (p != 0)
+				highest_prio_ = hdr_ip::access(p)->prio();
+			else
+				return 0;
+			for (Packet *pp = q_->getNext(); pp != 0; pp = q_->getNext()) {
+					hdr_ip* h = hdr_ip::access(pp);
+					int prio = h->prio();
+					//deque from the head
+					if (prio < highest_prio_) {
+						p = pp;
+						highest_prio_ = prio;
+				}
+			}
+			if (keep_order_) {
+				q_->resetIterator();
+				hdr_ip* hp = hdr_ip::access(p);
+				for (Packet *pp = q_->getNext(); pp != p; pp = q_->getNext()) {
+					hdr_ip* h = hdr_ip::access(pp);
+					if (h->saddr() == hp->saddr() 
+					&& h->daddr() == hp->daddr() 
+					&& h->flowid() == hp->flowid()) {
+						p = pp;
+						break;
+					}
+				}
+			}
+
+			//if (hdr_ip::access(p)->flowid() == 1) {
+		//		q_->resetIterator();
+		//		printf("DEQUE: flow %d queue_length %d\n", hdr_ip::access(p)->flowid(), q_->byteLength());
+		//		for (Packet *pp = q_->getNext(); pp != 0; pp = q_->getNext()) {
+		//			hdr_ip* h = hdr_ip::access(pp);
+		//			printf("( %d %d )", h->flowid(), h->prio());
+		//		}
+		//		printf("\n");
+		//		fflush(stdout);
+			//}
+
+			q_->remove(p);
+			return p;
+	} else
+	if (drop_smart_) {
+		Packet *p = q_->deque();
+		if (p) {
+			hdr_ip* h = hdr_ip::access(p);
+			FlowKey fkey;
+			fkey.src = h->saddr();
+			fkey.dst = h->daddr();
+			fkey.fid = h->flowid();
+			
+			char* fkey_buf = (char*) &fkey;
+			int length = sizeof(fkey);
+			string fkey_string(fkey_buf, length);
+			
+			std::tr1::hash<string> string_hasher;
+			size_t signature = string_hasher(fkey_string);			
+			sq_queue_.push(signature);
+						
+			if (sq_counts_.find(signature) != sq_counts_.end()) { 
+				sq_counts_[signature]++;
+				//printf("%s packet with signature %d, count = %d, qsize = %d\n", this->name(), signature, sq_counts_[signature], sq_queue_.size());				
+			}
+			else {
+				sq_counts_[signature] = 1;
+				//printf("%s first packet with signature %d, count = %d, qsize = %d\n", this->name(), signature, sq_counts_[signature], sq_queue_.size());
+			}
+
+       			if (sq_queue_.size() > sq_limit_) {
+		       		//printf("%s we are full %d %d\n", this->name(), sq_counts_.size(), sq_queue_.size());
+	       			size_t temp = sq_queue_.front();				                            	 sq_queue_.pop();
+				sq_counts_[temp]--;
+				if (sq_counts_[temp] == 0)
+					sq_counts_.erase(temp);
+				
+				//printf("%s removed front sig = %d, no longer full %d %d\n", this->name(), temp, sq_counts_.size(), sq_queue_.size());
+				
+			}
+		}
+		return p;
+		
+    	} else {
+		return q_->deque();
+	}
 }
 
 void DropTail::print_summarystats()
diff -rpuN ns-allinone-2.34.base/ns-2.34/queue/drop-tail.h ns-allinone-2.34.hyline/ns-2.34/queue/drop-tail.h
--- ns-allinone-2.34.base/ns-2.34/queue/drop-tail.h	2009-06-14 13:35:44.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/queue/drop-tail.h	2016-05-01 17:02:22.000000000 -0400
@@ -37,10 +37,35 @@
 #ifndef ns_drop_tail_h
 #define ns_drop_tail_h
 
-#include <string.h>
+/*#ifdef __GNUC__
+#include <ext/hash_map>
+#else
+#include <hash_map>
+#endif
+
+
+namespace std
+{
+ using namespace __gnu_cxx;
+}
+*/
+#include <tr1/unordered_map>
+#include <tr1/functional>
+#include <queue>
+
+using std::queue;
+using std::tr1::unordered_map;
+//using std::tr1::functional;
+
+#include <string>
 #include "queue.h"
 #include "config.h"
 
+typedef struct flowkey {
+	nsaddr_t src, dst;
+	int fid;
+} FlowKey;
+
 /*
  * A bounded, drop-tail queue
  */
@@ -50,27 +75,116 @@ class DropTail : public Queue {
 		q_ = new PacketQueue; 
 		pq_ = q_;
 		bind_bool("drop_front_", &drop_front_);
+		bind_bool("drop_smart_", &drop_smart_);
+		bind_bool("drop_prio_", &drop_prio_);
+		bind_bool("deque_prio_", &deque_prio_);
+		bind_bool("keep_order_", &keep_order_);
 		bind_bool("summarystats_", &summarystats);
 		bind_bool("queue_in_bytes_", &qib_);  // boolean: q in bytes?
 		bind("mean_pktsize_", &mean_pktsize_);
+		bind("sq_limit_", &sq_limit_);
 		//		_RENAMED("drop-front_", "drop_front_");
 	}
 	~DropTail() {
 		delete q_;
 	}
-  protected:
 	void reset();
 	int command(int argc, const char*const* argv); 
 	void enque(Packet*);
 	Packet* deque();
+  protected:
 	void shrink_queue();	// To shrink queue and drop excessive packets.
 
 	PacketQueue *q_;	/* underlying FIFO queue */
-	int drop_front_;	/* drop-from-front (rather than from tail) */
+	int drop_front_;	/* drop-from-front (rather than from tail) */	
 	int summarystats;
 	void print_summarystats();
 	int qib_;       	/* bool: queue measured in bytes? */
 	int mean_pktsize_;	/* configured mean packet size in bytes */
+	// Mohammad: for smart dropping
+	int drop_smart_;
+	// Shuang: for priority dropping
+	int drop_prio_;
+	int deque_prio_;
+	int keep_order_;
+
+
+	unsigned int sq_limit_;
+	unordered_map<size_t, int> sq_counts_;
+	std::queue<size_t> sq_queue_;
+
 };
 
+
+//
+//class DPQ;
+//
+//class PFCTimer_DPQ : public TimerHandler {
+//public:
+//	PFCTimer_DPQ(DPQ *a=0) : TimerHandler() { a_ = a; }
+//	void setid(int id){this->id=id;}
+//	void setRPQ(DPQ *a){a_=a;}
+//protected:
+//	virtual void expire(Event *e);
+//	DPQ *a_;
+//	int id;
+//};
+//
+///**
+// * 
+// */
+//class DPQ: public Queue
+//{
+//public:
+//	DPQ(/*int nQueueNum*/)
+//	{
+//
+//		Writecounter=0;
+//		m_nNumQueues = 2;
+//		m_bPFC=0;
+//		m_nMargin=10;
+//		for(int i=0;i<8;i++)
+//		{
+//			m_pfcState[i]=PFC_NORMAL_STS;
+//			m_pfcTimer[i].setRPQ(this);
+//			m_pfcTimer[i].setid(i);
+//		}
+//		pq_ = m_Queues->pq_;
+//
+//		bind("queue_num_", &m_nNumQueues);		    // minthresh
+//		bind("pfc_enable", &m_bPFC);
+//		bind("pfc_threshold_0", &m_nThreshold[0]);
+//		bind("pfc_threshold_1", &m_nThreshold[1]);
+//
+//		bind("size_0", &m_Queues[0].qlim_);
+//		bind("size_1", &m_Queues[1].qlim_);
+//		bind("margin",&m_nMargin);
+//		bindparams();
+//	}
+//	int command(int argc, const char*const* argv);
+//	void bindparams();
+//	void reset();
+//	void initialize_params();
+//	void print_summarystats();
+//	void SendPFCMessage(int Priority, int PauseDuration);
+//	int Writecounter;
+//	void enque(Packet*);
+//	Packet* deque();
+//	DropTail m_Queues[8];   // FIFO queues
+//	int m_nThreshold[8];
+//	int m_bPFC;
+//	int m_nNumQueues;
+//	int m_nMargin;
+//
+//	//PFC functionality
+//	virtual int CheckState(Packet* p);
+//	int m_pfcState[8];
+//	void pfctimeout(int id);
+//	PFCTimer_DPQ m_pfcTimer[8];
+//protected:
+//
+//public:
+//};
+//
+
 #endif
diff -rpuN ns-allinone-2.34.base/ns-2.34/queue/queue.cc ns-allinone-2.34.hyline/ns-2.34/queue/queue.cc
--- ns-allinone-2.34.base/ns-2.34/queue/queue.cc	2009-06-14 13:35:44.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/queue/queue.cc	2016-05-01 17:02:22.000000000 -0400
@@ -41,6 +41,27 @@ static const char rcsid[] =
 #include <math.h>
 #include <stdio.h>
 
+//:
+int Queue::GetState(Packet* p)
+{
+	DBGMARK(DBGPFC,4,"now:%f, pkt:%p @ %s: Checking PFC sts from %s\n",NOW,p,this->name(),nodeEntry_->name());
+
+	return nodeEntry_->CheckState(p);
+}
+int Queue::command(int argc, const char*const* argv)
+{
+	Tcl& tcl = Tcl::instance();
+	if (strcmp(argv[1], "nodeEntry") == 0) {
+		nodeEntry_ = (Classifier*)TclObject::lookup(argv[2]);
+		if (nodeEntry_ == 0) {
+			tcl.resultf("no such object %s", argv[2]);
+			return (TCL_ERROR);
+		}
+		return (TCL_OK);
+	}
+	return (Connector::command(argc, argv));
+}
+
 void PacketQueue::remove(Packet* target)
 {
 	for (Packet *pp= 0, *p= head_; p; pp= p, p= p->next_) {
@@ -56,6 +77,7 @@ void PacketQueue::remove(Packet* target)
 			return;
 		}
 	}
+	DBGERROR("PacketQueue:: remove() couldn't find target: %p\n",target);
 	fprintf(stderr, "PacketQueue:: remove() couldn't find target\n");
 	abort();
 }
@@ -129,6 +151,7 @@ void Queue::recv(Packet* p, Handler*)
 			utilUpdate(last_change_, now, blocked_);
 			last_change_ = now;
 			blocked_ = 1;
+			DBGMARK(DBGPFC,4,"@ %s: ... target:%s\n",this->name(),target_->name());
 			target_->recv(p, &qh_);
 		}
 	}
diff -rpuN ns-allinone-2.34.base/ns-2.34/queue/queue.h ns-allinone-2.34.hyline/ns-2.34/queue/queue.h
--- ns-allinone-2.34.base/ns-2.34/queue/queue.h	2009-06-14 13:35:44.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/queue/queue.h	2016-05-01 17:02:22.000000000 -0400
@@ -38,6 +38,7 @@
 #define ns_queue_h
 
 #include "connector.h"
+#include "classifier.h"
 #include "packet.h"
 #include "ip.h"
 class Packet;
@@ -109,6 +110,7 @@ private:
 };
 
 class Queue;
+class Classifier;
 
 class QueueHandler : public Handler {
 public:
@@ -142,6 +144,15 @@ public:
 	   Returns the maximum of recent measurements stored in util_buf_*/
 	double peak_utilization(void);
 	virtual ~Queue();
+
+	//: PFC functionality
+	int GetState(Packet* p);
+
+	//: PFC functionality
+	virtual int CheckState(Packet* p){DBGERROR("Error! No Implementation for ChackState!\n");return 0;}
+	virtual int command(int argc, const char*const* argv);
+
+	Classifier *nodeEntry_;
 protected:
 	Queue();
 	void reset();
diff -rpuN ns-allinone-2.34.base/ns-2.34/queue/red.cc ns-allinone-2.34.hyline/ns-2.34/queue/red.cc
--- ns-allinone-2.34.base/ns-2.34/queue/red.cc	2009-06-14 13:35:44.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/queue/red.cc	2016-05-01 17:02:22.000000000 -0400
@@ -560,7 +560,7 @@ REDQueue::drop_early(Packet* pkt)
 		edv_.count_bytes = 0;
 		hdr_flags* hf = hdr_flags::access(pickPacketForECN(pkt));
 		if (edp_.setbit && hf->ect() && 
-                     (!edp_.use_mark_p || edv_.v_prob1 < edp_.mark_p)) { 
+		    (!edp_.use_mark_p || edv_.v_prob1 <= edp_.mark_p)) { // Mohammad: I changed < to <= 
 			hf->ce() = 1; 	// mark Congestion Experienced bit
 			// Tell the queue monitor here - call emark(pkt)
 			return (0);	// no drop
@@ -984,3 +984,825 @@ void REDQueue::run_estimator(int nqueued
 	edv_.v_slope = f_sl;
 }
 
+//
+void REDQueue::SetIdle()
+{
+	idle_ = 1;
+	// deque() may invoked by Queue::reset at init
+	// time (before the scheduler is instantiated).
+	// deal with this case
+	if (&Scheduler::instance() != NULL)
+		idletime_ = Scheduler::instance().clock();
+	else
+		idletime_ = 0.0;
+}
+
+
+/**
+ * : RPQ
+ */
+
+void PFCTimer::expire(Event*)
+{
+	a_->pfctimeout(id);
+}
+
+void PFCDeQTimer::expire(Event*)
+{
+	a_->pfcResume(id);
+}
+
+/////////////////////////////////////////////////////////
+static class RPQClass : public TclClass {
+public:
+	RPQClass() : TclClass("Queue/RPQ") {}
+	TclObject* create(int argc, const char*const* argv) {
+		//printf("creating RED Queue. argc = %d\n", argc);
+/*
+		//mod to enable RED to take arguments
+		if (argc==5)
+			return (new RPQ(argv[4]));
+		else
+*/
+		return (new RPQ);
+	}
+} class_rpq;
+
+/************************************************************/
+/*
+
+void RPQ::enque(Packet* p)
+{
+	hdr_ip* hdr = hdr_ip::access(p);
+	FILE* pFile;
+	char pName[255];
+	sprintf(pName,"/home/student/Desktop/log.txt");
+//
+	//FIXME: First time we need "w" instead of "a"
+	if(Writecounter)
+		pFile = fopen (pName,"a");
+	else
+		pFile = fopen (pName,"w");
+	Writecounter++;
+//
+	fprintf(pFile,"Writecounter=%d enque: hdr->prio()=%d\n",Writecounter,hdr->prio());
+	int prio = hdr->prio();
+	if(prio>=0 && prio<m_nNumQueues )
+	{
+		fprintf(pFile,"enque:\n");
+		m_Queues[prio]->enque(p);
+		fprintf(pFile,"enque:2\n");
+	}
+	else
+	{
+		fprintf(pFile,"else:\n");
+		m_Queues[m_nNumQueues-1]->enque(p);
+		fprintf(pFile,"else:3\n");
+	}
+
+	fprintf(pFile,"pFile=%p before closing:\n",pFile);
+	fclose (pFile);
+}
+
+**********************************************************
+Packet* RPQ::deque()
+{
+	for(int i=0;i<m_nNumQueues;i++)
+	{
+		if(m_Queues[i]->length()!=0)
+		{
+			return m_Queues[i]->deque();
+		}
+	}
+	return m_Queues[0]->deque();
+}
+*/
+//**********************************************************
+void RPQ::pfctimeout(int id)
+{
+	if(id>=0 && id<m_nNumQueues)
+	{
+		if(m_Queues[id].length()<(m_nThreshold[id]-m_nMargin) || m_Queues[id].length()==0)
+		{
+			DBGMARK(DBGPFC,4,"pfctimeout (id:%d):  Changing sts to from %d to Normal...\n",id,m_pfcState[id]);
+			m_pfcState[id]=PFC_NORMAL_STS;
+		}
+		else
+		{
+			double pasueTime = 0.000001;//1us
+			m_pfcTimer[id].resched(pasueTime);
+		}
+	}
+}
+
+void RPQ::pfcResume(int id)
+{
+	if(m_bPFC)
+	{
+		Packet *p;
+		int bussy=false;
+//		DBGMARK(DBGPFC,2,"@%s : Dequeuing...\n",this->name());
+		for(int i=0;i<id;i++)
+		{
+			if(m_Queues[i].length()!=0)
+			{
+				bussy=true;
+			}
+		}
+		if(!bussy)
+		{
+//			Scheduler::instance().schedule(&qh_, &intr_, 0.000001);
+			if(m_Queues[id].length()!=0)
+			{
+//				DBGMARK(0,0," try to send it at now:%f\n",NOW);
+				if (!blocked_) {
+//					DBGMARK(0,0," \n");
+					/*
+					 * We're not blocked.
+					 */
+					p=pfcdeque(id);
+					if (p != 0) {
+						utilUpdate(last_change_, NOW, blocked_);
+						last_change_ = NOW;
+						blocked_ = 1;
+						target_->recv(p, &qh_);
+					}
+				}
+				else
+				{
+//					DBGMARK(0,0,"Blocked!\n");
+				}
+			}
+		}
+		else
+		{
+			m_pfcDQTimer[id].resched(0.000001);
+		}
+	}
+}
+
+void RPQ::SendPFCMessage(int Priority, int PauseDuration)
+{
+
+	Tcl::instance().evalf("%s sendpfcmessage %d %d", this->name(),Priority,PauseDuration);
+}
+
+int RPQ::command(int argc, const char*const* argv)
+{
+	int ret=TCL_OK;
+/*
+	FILE* pFile;
+	char pName[255];
+	sprintf(pName,"/home/student/Desktop/log.txt");
+	pFile = fopen (pName,"a");
+
+	fprintf(pFile,"command: \n");
+*/
+	for(int i=0;i<argc;i++)
+	{
+//		fprintf(pFile,"argv[%d]=%s \n",i,argv[i]);
+	}
+	if (strcmp(argv[1], "per-queue") == 0)
+	{
+		printf("per-queue command is empty!\n");
+	}
+//	else if (strcmp(argv[1], "queue_num_") == 0)
+//	{
+//		SetNumQueue(atoi(argv[2]));
+//	}
+	else
+	{
+		Tcl& tcl = Tcl::instance();
+		if (argc == 2) {
+			if (strcmp(argv[1], "reset") == 0) {
+				reset();
+				return (TCL_OK);
+			}
+			if (strcmp(argv[1], "early-drop-target") == 0) {
+				if (m_Queues->de_drop_ != NULL)
+					tcl.resultf("%s", m_Queues->de_drop_->name());
+				return (TCL_OK);
+			}
+			if (strcmp(argv[1], "edrop-trace") == 0) {
+				if (m_Queues->EDTrace != NULL) {
+					tcl.resultf("%s", m_Queues->EDTrace->name());
+					if (debug_)
+						printf("edrop trace exists according to RED\n");
+				}
+				else {
+					if (debug_)
+						printf("edrop trace doesn't exist according to RED\n");
+					tcl.resultf("0");
+				}
+				return (TCL_OK);
+			}
+			if (strcmp(argv[1], "trace-type") == 0) {
+				tcl.resultf("%s", m_Queues->traceType);
+				return (TCL_OK);
+			}
+			if (strcmp(argv[1], "printstats") == 0) {
+				m_Queues->print_summarystats();
+				return (TCL_OK);
+			}
+
+//			if (strcmp(argv[1], "srcnode") == 0) {
+//				NsObject* node = (NsObject*)TclObject::lookup(argv[2]);
+//
+//				return (TCL_OK);
+//			}
+		}
+		else if (argc == 3) {
+			if (strcmp(argv[1], "nodeEntry") == 0) {
+				nodeEntry_ = (Classifier*)TclObject::lookup(argv[2]);
+				if (nodeEntry_ == 0) {
+					tcl.resultf("no such object %s", argv[2]);
+					return (TCL_ERROR);
+				}
+				return (TCL_OK);
+			}
+			if (strcmp(argv[1], "get-size") == 0)
+			{
+				int queueNum=atoi(argv[2]);
+				if(queueNum<0 || queueNum>1)
+					return(TCL_ERROR);
+				DBGMARK(0,0,"%d",m_Queues[queueNum].qlim_);
+				return(TCL_OK);
+			}
+			if (strcmp(argv[1], "get-threshold") == 0)
+			{
+				int queueNum=atoi(argv[2]);
+				if(queueNum<0 || queueNum>1)
+					return(TCL_ERROR);
+				DBGMARK(0,0,"%d",m_nThreshold[queueNum]);
+				return(TCL_OK);
+			}
+
+			// attach a file for variable tracing
+			if (strcmp(argv[1], "attach") == 0) {
+				int mode;
+				const char* id = argv[2];
+				m_Queues->tchan_ = Tcl_GetChannel(tcl.interp(), (char*)id, &mode);
+				if (m_Queues->tchan_ == 0) {
+					tcl.resultf("RED: trace: can't attach %s for writing", id);
+					return (TCL_ERROR);
+				}
+				return (TCL_OK);
+			}
+			// tell RED about link stats
+			if (strcmp(argv[1], "link") == 0) {
+				LinkDelay* del = (LinkDelay*)TclObject::lookup(argv[2]);
+				if (del == 0) {
+					tcl.resultf("RED: no LinkDelay object %s",
+						argv[2]);
+					return(TCL_ERROR);
+				}
+				// set ptc now
+				m_Queues->link_ = del;
+				m_Queues->edp_.ptc = m_Queues->link_->bandwidth() /
+					(8.0 * m_Queues->edp_.mean_pktsize);
+				m_Queues->edp_.delay = m_Queues->link_->delay();
+				if (
+				  (m_Queues->edp_.q_w <= 0.0 || m_Queues->edp_.th_min_pkts == 0 ||
+						  m_Queues->edp_.th_max_pkts == 0))
+					initialize_params();
+				return (TCL_OK);
+			}
+			if (strcmp(argv[1], "early-drop-target") == 0) {
+				NsObject* p = (NsObject*)TclObject::lookup(argv[2]);
+				if (p == 0) {
+					tcl.resultf("no object %s", argv[2]);
+					return (TCL_ERROR);
+				}
+				m_Queues->de_drop_ = p;
+				return (TCL_OK);
+			}
+			if (strcmp(argv[1], "edrop-trace") == 0) {
+				if (debug_)
+					printf("Ok, Here\n");
+				NsObject * t  = (NsObject *)TclObject::lookup(argv[2]);
+				if (debug_)
+					printf("Ok, Here too\n");
+				if (t == 0) {
+					tcl.resultf("no object %s", argv[2]);
+					return (TCL_ERROR);
+				}
+				m_Queues->EDTrace = t;
+				if (debug_)
+					printf("Ok, Here too too too %d\n", ((Trace *)m_Queues->EDTrace)->type_);
+				return (TCL_OK);
+			}
+			if (!strcmp(argv[1], "packetqueue-attach")) {
+				delete m_Queues->q_;
+				if (!(m_Queues->q_ = (PacketQueue*) TclObject::lookup(argv[2])))
+					return (TCL_ERROR);
+				else {
+					pq_ = m_Queues->q_;
+					return (TCL_OK);
+				}
+			}
+		}
+//		fprintf(pFile,"command End: %d\n",ret);
+//		fclose(pFile);
+		return (Queue::command(argc, argv));
+	}
+	return ret;
+}
+
+void RPQ::bindparams()
+{
+	/**
+	 * Q[0] Params
+	 */
+	bind_bool("bytes_", &m_Queues->edp_.bytes);	    // boolean: use bytes?
+	bind_bool("queue_in_bytes_", &m_Queues->qib_);	    // boolean: q in bytes?
+	//	_RENAMED("queue-in-bytes_", "queue_in_bytes_");
+	bind("thresh_", &m_Queues->edp_.th_min_pkts);		    // minthresh
+	bind("thresh_queue_", &m_Queues->edp_.th_min);
+	bind("maxthresh_", &m_Queues->edp_.th_max_pkts);	    // maxthresh
+	bind("maxthresh_queue_", &m_Queues->edp_.th_max);
+	bind("mean_pktsize_", &m_Queues->edp_.mean_pktsize);  // avg pkt size
+	bind("idle_pktsize_", &m_Queues->edp_.idle_pktsize);  // avg pkt size for idles
+	bind("q_weight_", &m_Queues->edp_.q_w);		    // for EWMA
+	bind("adaptive_", &m_Queues->edp_.adaptive);          // 1 for adaptive red
+	bind("cautious_", &m_Queues->edp_.cautious);          // 1 for cautious marking
+	bind("alpha_", &m_Queues->edp_.alpha); 	  	    // adaptive red param
+	bind("beta_", &m_Queues->edp_.beta);                  // adaptive red param
+	bind("interval_", &m_Queues->edp_.interval);	    // adaptive red param
+	bind("feng_adaptive_",&m_Queues->edp_.feng_adaptive); // adaptive red variant
+	bind("targetdelay_", &m_Queues->edp_.targetdelay);    // target delay
+	bind("top_", &m_Queues->edp_.top);		    // maximum for max_p
+	bind("bottom_", &m_Queues->edp_.bottom);		    // minimum for max_p
+	bind_bool("wait_", &m_Queues->edp_.wait);
+	bind("linterm_", &m_Queues->edp_.max_p_inv);
+	bind("mark_p_", &m_Queues->edp_.mark_p);
+	bind_bool("use_mark_p_", &m_Queues->edp_.use_mark_p);
+	bind_bool("setbit_", &m_Queues->edp_.setbit);	    // mark instead of drop
+	bind_bool("gentle_", &m_Queues->edp_.gentle);         // increase the packet
+
+	bind_bool("summarystats_", &m_Queues->summarystats_);
+	bind_bool("drop_tail_", &m_Queues->drop_tail_);	    // drop last pkt
+	//	_RENAMED("drop-tail_", "drop_tail_");
+
+	bind_bool("drop_front_", &m_Queues->drop_front_);	    // drop first pkt
+	//	_RENAMED("drop-front_", "drop_front_");
+
+	bind_bool("drop_rand_", &m_Queues->drop_rand_);	    // drop pkt at random
+	//	_RENAMED("drop-rand_", "drop_rand_");
+
+	bind_bool("ns1_compat_", &m_Queues->ns1_compat_);	    // ns-1 compatibility
+	//	_RENAMED("ns1-compat_", "ns1_compat_");
+
+	bind("ave_", &m_Queues->edv_.v_ave);		    // average queue sie
+	bind("prob1_", &m_Queues->edv_.v_prob1);		    // dropping probability
+	bind("curq_", &m_Queues->curq_);			    // current queue size
+	bind("cur_max_p_", &m_Queues->edv_.cur_max_p);        // current max_p
+
+	/**
+	 * Q[1] Params
+	 */
+	bind_bool("bytes_1", &m_Queues[1].edp_.bytes);	    // boolean: use bytes?
+	bind_bool("queue_in_bytes_1", &m_Queues[1].qib_);	    // boolean: q in bytes?
+	//	_RENAMED("queue-in-bytes_", "queue_in_bytes_");
+	bind("thresh_1", &m_Queues[1].edp_.th_min_pkts);		    // minthresh
+	bind("thresh_queue_1", &m_Queues[1].edp_.th_min);
+	bind("maxthresh_1", &m_Queues[1].edp_.th_max_pkts);	    // maxthresh
+	bind("maxthresh_queue_1", &m_Queues[1].edp_.th_max);
+	bind("mean_pktsize_1", &m_Queues[1].edp_.mean_pktsize);  // avg pkt size
+	bind("idle_pktsize_1", &m_Queues[1].edp_.idle_pktsize);  // avg pkt size for idles
+	bind("q_weight_1", &m_Queues[1].edp_.q_w);		    // for EWMA
+	bind("adaptive_1", &m_Queues[1].edp_.adaptive);          // 1 for adaptive red
+	bind("cautious_1", &m_Queues[1].edp_.cautious);          // 1 for cautious marking
+	bind("alpha_1", &m_Queues[1].edp_.alpha); 	  	    // adaptive red param
+	bind("beta_1", &m_Queues[1].edp_.beta);                  // adaptive red param
+	bind("interval_1", &m_Queues[1].edp_.interval);	    // adaptive red param
+	bind("feng_adaptive_1",&m_Queues[1].edp_.feng_adaptive); // adaptive red variant
+	bind("targetdelay_1", &m_Queues[1].edp_.targetdelay);    // target delay
+	bind("top_1", &m_Queues[1].edp_.top);		    // maximum for max_p
+	bind("bottom_1", &m_Queues[1].edp_.bottom);		    // minimum for max_p
+	bind_bool("wait_1", &m_Queues[1].edp_.wait);
+	bind("linterm_1", &m_Queues[1].edp_.max_p_inv);
+	bind("mark_p_1", &m_Queues[1].edp_.mark_p);
+	bind_bool("use_mark_p_1", &m_Queues[1].edp_.use_mark_p);
+	bind_bool("setbit_1", &m_Queues[1].edp_.setbit);	    // mark instead of drop
+	bind_bool("gentle_1", &m_Queues[1].edp_.gentle);         // increase the packet
+
+	bind_bool("summarystats_1", &m_Queues[1].summarystats_);
+	bind_bool("drop_tail_1", &m_Queues[1].drop_tail_);	    // drop last pkt
+	//	_RENAMED("drop-tail_", "drop_tail_");
+
+	bind_bool("drop_front_1", &m_Queues[1].drop_front_);	    // drop first pkt
+	//	_RENAMED("drop-front_", "drop_front_");
+
+	bind_bool("drop_rand_1", &m_Queues[1].drop_rand_);	    // drop pkt at random
+	//	_RENAMED("drop-rand_", "drop_rand_");
+
+	bind_bool("ns1_compat_1", &m_Queues[1].ns1_compat_);	    // ns-1 compatibility
+	//	_RENAMED("ns1-compat_", "ns1_compat_");
+
+	bind("ave_1", &m_Queues[1].edv_.v_ave);		    // average queue sie
+	bind("prob1_1", &m_Queues[1].edv_.v_prob1);		    // dropping probability
+	bind("curq_1", &m_Queues[1].curq_);			    // current queue size
+	bind("cur_max_p_1", &m_Queues[1].edv_.cur_max_p);        // current max_p
+
+}
+
+void RPQ::reset()
+{
+	for(int i=0;i<8;i++)
+	{
+		m_Queues[i].reset();
+		m_pfcState[i]=PFC_NORMAL_STS;
+	}
+}
+void RPQ::print_summarystats()
+{
+	for(int i=0;i<8;i++)
+	{
+		m_Queues[i].print_summarystats();
+	}
+}
+
+void RPQ::initialize_params()
+{
+	for(int i=0;i<8;i++)
+	{
+		m_Queues[i].initialize_params();
+		m_pfcState[i]=PFC_NORMAL_STS;
+	}
+}
+//**********************************************************
+
+void RPQ::enque(Packet* p)
+{
+	hdr_ip* iph = hdr_ip::access(p);
+
+/*
+	FILE* pFile;
+	char pName[255];
+	sprintf(pName,"/home/student/Desktop/log.txt");
+
+	if(Writecounter)
+		pFile = fopen (pName,"a");
+	else
+		pFile = fopen (pName,"w");
+	Writecounter++;
+*/
+	DBGMARK(DBGPFC,4,"@ %s :Enqueuing...prio:%d\n",this->name(),iph->prio_);
+	if (iph->prio_>=0 && iph->prio_<m_nNumQueues)
+	{
+		DBGMARK(DBGPFC,4,"...\n");
+		//if(iph->prio_)DBGMARK(0,0,"m_bPFC:%d now:%f @ %s :Enqueuing...prio:%d pkt=%p qlentgh:%d\n",m_bPFC,NOW,this->name(),iph->prio_,p,m_Queues[iph->prio_].length());
+		if(m_bPFC)
+		{
+			if(m_Queues[iph->prio_].length()<(m_nThreshold[iph->prio_]-m_nMargin) || m_Queues[iph->prio_].length()==0)
+			{
+				m_pfcState[iph->prio_]=PFC_NORMAL_STS;
+			}
+
+			if(m_Queues[iph->prio_].length()>(m_nThreshold[iph->prio_]) && m_pfcState[iph->prio_]!=PFC_PAUSED_STS)
+			{
+				DBGMARK(DBGPFC,4,"Changing the State to PAUSED...\n");
+				m_pfcState[iph->prio_]=PFC_PAUSED_STS;
+				//fixme: Calculate Pause Time:
+				double pasueTime = 0.000010;//1us		//Random::uniform(0.1);//100ms
+				m_pfcTimer[iph->prio_].resched(pasueTime);
+				if(iph->prio_)DBGMARK(DBGPFC,4,"\\\\\\\\\\\\name:%s now:%f paused!\n",name(),NOW);
+			}
+			else
+			{
+				DBGMARK(DBGPFC,4,"m_Queues[iph->prio_].length():%d\n",m_Queues[iph->prio_].length());
+			}
+		}
+		if(iph->prio_ /*&& m_Queues[iph->prio_].length()>m_nThreshold[iph->prio_]*/)
+			DBGMARK(DBGPFC,4,"{****\n now:%f @ %s state:%d Enqueuing...prio:%d pkt=%p qlentgh:%d\n",
+					NOW,this->name(),m_pfcState[iph->prio_],iph->prio_,p,m_Queues[iph->prio_].length());
+		m_Queues[iph->prio_].enque(p);
+
+		if(iph->prio_ /*&& m_Queues[iph->prio_].length()>m_nThreshold[iph->prio_]*/)
+			DBGMARK(DBGPFC,4,"****}\nnow:%f @ %s state:%d Enqueuing...prio:%d pkt=%p qlentgh:%d\n",
+					NOW,this->name(),m_pfcState[iph->prio_],iph->prio_,p,m_Queues[iph->prio_].length());
+
+//		fprintf(pFile,"W=%d enque:Q[%d] length:%d src:%d ,dst=%d, blocked=%d \n",Writecounter,iph->prio_,m_Queues[iph->prio_].length(),iph->src_.addr_,iph->dst_.addr_,blocked_);
+
+
+//    if (m_Queues->length() > qlim_) {
+//    	m_Queues->remove(p);
+//      drop(p);
+//    }
+	}
+	else
+	{
+		DBGERROR("Error! INVALID PRIORITY...\n");
+		m_Queues[m_nNumQueues-1].enque(p);
+//		fprintf(pFile,"OUT of Range Prio enque:Q[%d] length:%d src:%d ,dst=%d, blocked=%d \n",m_nNumQueues-1,m_Queues[m_nNumQueues-1].length(),iph->src_.addr_,iph->dst_.addr_,blocked_);
+
+		//    if (m_Queues->length() > qlim_) {
+		//    	m_Queues->remove(p);
+		//      drop(p);
+		//    }
+	}
+
+//	fclose (pFile);
+}
+
+Packet* RPQ::pfcdeque(int i)
+{
+	if(m_bPFC)
+	{
+		Packet *p;
+		if(m_Queues[i].length()!=0)
+		{
+			int pfc_sts=PFC_NORMAL_STS;
+//					DBGMARK(DBGPFC,2,"@%s : Dequeuing...\n",this->name());
+			if (m_Queues[i].summarystats_ && &Scheduler::instance() != NULL) {
+				Queue::updateStats(m_Queues[i].qib_?m_Queues[i].q_->byteLength():m_Queues[i].q_->length());
+			}
+			DBGMARK(DBGPFC,4,"...\nm_Queues[i].length():%d",m_Queues[i].length());
+			for(int n=0;n<m_Queues[i].length();n++)
+			{
+//						DBGMARK(DBGPFC,2,"n:%d m_Queues[%d].length():%d...\n",n,i,m_Queues[i].length());
+				//To simulate VOQ:
+				//If one output queue is paused other pkts should be able to go to other outputs!
+				p = m_Queues[i].q_->lookup(n);
+				if(p==0)
+				{
+					DBGMARK(DBGPFC,4,"now:%f @ %s state:%d No More packet .qlentgh:%d\n",
+							NOW,this->name(),m_pfcState[i],m_Queues[i].length());
+					//All are paused! Or no pkt to send.
+					m_Queues[i].SetIdle();
+					m_pfcDQTimer[i].resched(0.000001);
+					return 0;
+				}
+
+				//Check PFC State
+				int path = hdr_ip::access(p)->path_;
+//						DBGMARK(DBGPFC,1,"now:%f @ %s state:%d n:%d Dequeuing...pkt=%p path:%0x qlentgh:%d\n",
+//								NOW,this->name(),m_pfcState[i],n,p,hdr_ip::access(p)->path_,m_Queues[i].length());
+				pfc_sts = GetState(p);
+//						DBGMARK(0,0,"GetState: now:%f ",Scheduler::instance().clock());
+				if(path!=hdr_ip::access(p)->path_)
+				{
+					DBGMARK(DBGPFC,4,"now:%f @ %s state:%d n:%d path_change...pkt=%p p->path:%08x path:%08x qlentgh:%d\n",
+						NOW,this->name(),m_pfcState[i],n,p,hdr_ip::access(p)->path_,path,m_Queues[i].length());
+					hdr_ip::access(p)->path_= path;
+				}
+//						DBGMARK(DBGPFC,1,"now:%f @ %s state:%d n:%d Dequeuing...pkt=%p path:%0x qlentgh:%d\n",
+//								NOW,this->name(),m_pfcState[i],n,p,hdr_ip::access(p)->path_,m_Queues[i].length());
+
+				if(pfc_sts==PFC_NORMAL_STS)
+				{
+					DBGMARK(DBGPFC,4,"now:%f @ %s state:%d n:%d Dequeuing...pkt=%p qlentgh:%d\n",
+							NOW,this->name(),m_pfcState[i],n,p,m_Queues[i].length());
+					m_Queues[i].q_->remove(p);
+					m_Queues[i].idle_=0.0;
+//							Packet::free(pTmp);
+					m_pfcDQTimer[i].force_cancel();
+					return p;
+				}
+				else
+				{
+//							Packet::free(pTmp);
+					m_pfcDQTimer[i].resched(0.000001);
+					DBGMARK(DBGPFC,4,"now:%f name:%s we are paused... My queue length:%d, qlim:%d\n",NOW,name(),m_Queues[i].length(),m_Queues[i].qlim_);
+				}
+			}
+			m_Queues[i].SetIdle();
+			return 0;
+		}
+	//	fprintf(pFile,"EMPTY! deque: length:%d \n",m_Queues[0].length());
+	//	fclose (pFile);
+		m_Queues[0].SetIdle();
+		return 0;
+	}
+}
+
+Packet* RPQ::deque()
+{
+	if(m_bPFC)
+	{
+		Packet *p;
+//		DBGMARK(DBGPFC,2,"@%s : Dequeuing...\n",this->name());
+		for(int i=0;i<m_nNumQueues;i++)
+		{
+			if(m_Queues[i].length()!=0)
+			{
+				int pfc_sts=PFC_NORMAL_STS;
+				if(i>0)
+				{
+//					DBGMARK(DBGPFC,2,"@%s : Dequeuing...\n",this->name());
+					if (m_Queues[i].summarystats_ && &Scheduler::instance() != NULL) {
+						Queue::updateStats(m_Queues[i].qib_?m_Queues[i].q_->byteLength():m_Queues[i].q_->length());
+					}
+					DBGMARK(DBGPFC,4,"...\nm_Queues[i].length():%d",m_Queues[i].length());
+					for(int n=0;n<m_Queues[i].length();n++)
+					{
+//						DBGMARK(DBGPFC,2,"n:%d m_Queues[%d].length():%d...\n",n,i,m_Queues[i].length());
+						//To simulate VOQ:
+						//If one output queue is paused other pkts should be able to go to other outputs!
+						p = m_Queues[i].q_->lookup(n);
+						if(p==0)
+						{
+							DBGMARK(DBGPFC,4,"now:%f @ %s state:%d No More packet .qlentgh:%d\n",
+									NOW,this->name(),m_pfcState[i],m_Queues[i].length());
+							//All are paused! Or no pkt to send.
+							m_Queues[i].SetIdle();
+							m_pfcDQTimer[i].resched(0.00001);
+							return 0;
+						}
+
+						//Check PFC State
+						int path = hdr_ip::access(p)->path_;
+//						DBGMARK(DBGPFC,1,"now:%f @ %s state:%d n:%d Dequeuing...pkt=%p path:%0x qlentgh:%d\n",
+//								NOW,this->name(),m_pfcState[i],n,p,hdr_ip::access(p)->path_,m_Queues[i].length());
+						pfc_sts = GetState(p);
+//						DBGMARK(0,0,"GetState: now:%f ",Scheduler::instance().clock());
+						if(path!=hdr_ip::access(p)->path_)
+						{
+							DBGMARK(DBGPFC,4,"now:%f @ %s state:%d n:%d path_change...pkt=%p p->path:%08x path:%08x qlentgh:%d\n",
+								NOW,this->name(),m_pfcState[i],n,p,hdr_ip::access(p)->path_,path,m_Queues[i].length());
+							hdr_ip::access(p)->path_= path;
+						}
+//						DBGMARK(DBGPFC,1,"now:%f @ %s state:%d n:%d Dequeuing...pkt=%p path:%0x qlentgh:%d\n",
+//								NOW,this->name(),m_pfcState[i],n,p,hdr_ip::access(p)->path_,m_Queues[i].length());
+
+						if(pfc_sts==PFC_NORMAL_STS)
+						{
+							DBGMARK(DBGPFC,4,"now:%f @ %s state:%d n:%d Dequeuing...pkt=%p qlentgh:%d\n",
+									NOW,this->name(),m_pfcState[i],n,p,m_Queues[i].length());
+							m_Queues[i].q_->remove(p);
+							m_Queues[i].idle_=0.0;
+//							Packet::free(pTmp);
+							m_pfcDQTimer[i].force_cancel();
+							return p;
+						}
+						else
+						{
+//							Packet::free(pTmp);
+							m_pfcDQTimer[i].resched(0.00001);
+							DBGMARK(DBGPFC,4,"now:%f name:%s we are paused... My queue length:%d, qlim:%d\n",NOW,name(),m_Queues[i].length(),m_Queues[i].qlim_);
+						}
+					}
+					m_Queues[i].SetIdle();
+					return 0;
+				}
+				else
+				{
+					return m_Queues[i].deque();
+				}
+			}
+		}
+	//	fprintf(pFile,"EMPTY! deque: length:%d \n",m_Queues[0].length());
+	//	fclose (pFile);
+		m_Queues[0].SetIdle();
+		return 0;
+/*
+		for(int i=0;i<m_nNumQueues;i++)
+		{
+			if(m_Queues[i].length()!=0)
+			{
+				int pfc_sts=PFC_NORMAL_STS;
+				if(i>0)
+				{
+					Packet *p;
+					p = m_Queues[i].q_->lookup(0);
+					pfc_sts = GetState(p);
+				}
+				DBGMARK(0,4,"GetState: now:%f ",Scheduler::instance().clock());
+				if(pfc_sts==PFC_NORMAL_STS)
+				{
+					return m_Queues[i].deque();
+				}
+			}
+		}
+	//	fprintf(pFile,"EMPTY! deque: length:%d \n",m_Queues[0].length());
+	//	fclose (pFile);
+		return m_Queues[0].deque();
+*/
+	}
+	else
+	{
+		Packet *p;
+		for(int i=0;i<m_nNumQueues;i++)
+		{
+			if(m_Queues[i].length()!=0)
+			{
+	//			fprintf(pFile,"deque:Q[%d] length:%d\n",i,m_Queues[i].length());
+	//			fclose (pFile);
+				return m_Queues[i].deque();
+			}
+		}
+	//	fprintf(pFile,"EMPTY! deque: length:%d \n",m_Queues[0].length());
+	//	fclose (pFile);
+		return m_Queues[0].deque();
+	}
+
+}
+
+//PFC functionality
+int RPQ::CheckState(Packet* p)
+{
+	if(m_bPFC)
+	{
+		hdr_ip* iph = hdr_ip::access(p);
+		DBGMARK(DBGPFC,4,"@%s: target:%s\n",this->name(),target_->name());
+		if (iph->prio_>=0 && iph->prio_<m_nNumQueues)
+		{
+			if(iph->prio_)
+				DBGMARK(DBGPFC,4,"now:%f @ %s state:%d CheckState...pkt=%p qlentgh:%d\n",
+					NOW,this->name(),m_pfcState[iph->prio_],p,m_Queues[iph->prio_].length());
+
+			return m_pfcState[iph->prio_];
+		}
+		DBGERROR("Error! Nothing is found!\n");
+	}
+	return PFC_NORMAL_STS;
+}
+
+void RPQ::CopyPacket(Packet *pTmp,Packet *p)
+{
+//	hdr_cmn* chOriginal = hdr_cmn::access(p);
+//	hdr_cmn* ch = hdr_cmn::access(pTmp);
+//
+//	ch->uid() = Agent::uidcnt_++;
+//	ch->ptype() = chOriginal->ptype_;
+//	ch->size() = chOriginal->size_;
+//	ch->timestamp() = Scheduler::instance().clock();
+//	ch->iface() = UNKN_IFACE.value(); // from packet.h (agent is local)
+//	ch->direction() = hdr_cmn::NONE;
+//
+//	ch->error() = 0;	/* pkt not corrupt to start with */
+//
+//	hdr_ip* iph = hdr_ip::access(pTmp);
+//	hdr_ip* iphOrg = hdr_ip::access(p);
+//	iph->saddr() = iphOrg->src_.addr_;
+//	iph->sport() = iphOrg->src_.port_;
+//	iph->daddr() = iphOrg->dst_.addr_;
+//	iph->dport() = iphOrg->dst_.port_;
+//
+//	iph->flowid() = iphOrg->fid_;
+//	iph->prio() = iphOrg->prio_;
+//	iph->ttl() = iphOrg->ttl_;
+}
+
+//:Test
+////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
+
+static class DtRrQueueClass : public TclClass {
+public:
+        DtRrQueueClass() : TclClass("Queue/DTRR") {}
+        TclObject* create(int, const char*const*) {
+	         return (new DtRrQueue);
+	}
+} class_dropt_tail_round_robin;
+
+
+void DtRrQueue::enque(Packet* p)
+{
+  hdr_ip* iph = hdr_ip::access(p);
+
+  // if IPv6 priority = 15 enqueue to queue1
+  if (iph->prio_ < 1) {
+    q1_->enque(p);
+    if ((q1_->length() + q2_->length()) > qlim_) {
+      q1_->remove(p);
+      drop(p);
+    }
+  }
+  else {
+    q2_->enque(p);
+    if ((q1_->length() + q2_->length()) > qlim_) {
+      q2_->remove(p);
+      drop(p);
+    }
+  }
+}
+
+
+Packet* DtRrQueue::deque()
+{
+  Packet *p;
+
+  if (deq_turn_ == 1) {
+    p =  q1_->deque();
+    if (p == 0) {
+      p = q2_->deque();
+      deq_turn_ = 1;
+    }
+    else {
+      deq_turn_ = 2;
+    }
+  }
+  else {
+    p =  q2_->deque();
+    if (p == 0) {
+      p = q1_->deque();
+      deq_turn_ = 2;
+    }
+    else {
+      deq_turn_ = 1;
+    }
+  }
+
+  return (p);
+}
+
diff -rpuN ns-allinone-2.34.base/ns-2.34/queue/red.h ns-allinone-2.34.hyline/ns-2.34/queue/red.h
--- ns-allinone-2.34.base/ns-2.34/queue/red.h	2009-06-14 13:35:44.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/queue/red.h	2016-05-01 17:02:22.000000000 -0400
@@ -140,6 +140,7 @@ struct edv {
 };
 
 class REDQueue : public Queue {
+	friend class RPQ;
  public:	
 	/*	REDQueue();*/
 	REDQueue(const char * = "Drop");
@@ -163,10 +164,15 @@ class REDQueue : public Queue {
 	  double v_a, double v_b, double v_c, double v_d, double max_p);
  	double calculate_p(double v_ave, double th_max, int gentle, 
 	  double v_a, double v_b, double v_c, double v_d, double max_p_inv);
-        virtual void reportDrop(Packet *pkt) {}  //pushback
+ 	virtual void reportDrop(Packet *pkt)
+	{	hdr_ip* iph = hdr_ip::access(pkt);
+		if(iph->prio_)DBGMARK(0,4,"name:%s, now:%f **********drop********prio:%d pkt=%p lenght:%d byteLength():%d limit:%d fid:%d\n",
+				name(),NOW,iph->prio_,pkt,length(),byteLength(),limit(),iph->fid_);
+	}  //pushback
 	void print_summarystats();
 
-	
+	//:
+	void SetIdle();
 	int summarystats_;	/* true to print true average queue size */
 
 	LinkDelay* link_;	/* outgoing link */
@@ -214,4 +220,166 @@ class REDQueue : public Queue {
 
 };
 
+class RPQ;
+
+class PFCTimer : public TimerHandler {
+public:
+	PFCTimer(RPQ *a=0) : TimerHandler() { a_ = a; }
+	void setid(int id){this->id=id;}
+	void setRPQ(RPQ *a){a_=a;}
+protected:
+	virtual void expire(Event *e);
+	RPQ *a_;
+	int id;
+};
+
+class PFCDeQTimer :public TimerHandler {
+public:
+	PFCDeQTimer(RPQ *a=0) : TimerHandler() { a_ = a; }
+	void setid(int id){this->id=id;}
+	void setRPQ(RPQ *a){a_=a;}
+protected:
+	virtual void expire(Event *e);
+	RPQ *a_;
+	int id;
+};
+
+/**
+ * 
+ */
+class RPQ: public Queue
+{
+public:
+	RPQ(/*int nQueueNum*/)
+	{
+//		FILE* pFile;
+//		char pName[255];
+//		sprintf(pName,"/home/student/Desktop/log.txt");
+
+		Writecounter=0;
+		m_nNumQueues = 2;
+		m_bPFC=0;
+		m_nMargin=10;
+		for(int i=0;i<8;i++)
+		{
+			m_pfcState[i]=PFC_NORMAL_STS;
+			m_pfcTimer[i].setRPQ(this);
+			m_pfcTimer[i].setid(i);
+			m_pfcDQTimer[i].setRPQ(this);
+			m_pfcDQTimer[i].setid(i);
+
+		}
+//		m_Queues = new REDQueue;
+//		for (int i=0;i<8;i++)
+//		{
+//			m_Queues[i] = new REDQueue;
+//		}
+/*
+		q1_ = new REDQueue;
+		q2_ = new REDQueue;
+		q3_ = new REDQueue;
+		q4_ = new REDQueue;
+		q5_ = new REDQueue;
+		q6_ = new REDQueue;
+		q7_ = new REDQueue;
+		q8_ = new REDQueue;
+*/
+		pq_ = m_Queues->pq_;
+
+/*
+		if(Writecounter)
+			pFile = fopen (pName,"a");
+		else
+			pFile = fopen (pName,"w");
+		Writecounter++;
+	//
+
+		fprintf(pFile,"pq_=%p \n",pq_);
+
+		fclose (pFile);
+*/
+
+		bind("queue_num_", &m_nNumQueues);		    // minthresh
+		bind("pfc_enable", &m_bPFC);
+		bind("pfc_threshold_0", &m_nThreshold[0]);
+		bind("pfc_threshold_1", &m_nThreshold[1]);
+
+		bind("size_0", &m_Queues[0].qlim_);
+		bind("size_1", &m_Queues[1].qlim_);
+		bind("margin",&m_nMargin);
+		bindparams();
+	}
+//	void SetNumQueue(int num)	{m_nNumQueues=num;};
+	int command(int argc, const char*const* argv);
+	void bindparams();
+	void reset();
+	void initialize_params();
+	void print_summarystats();
+	void SendPFCMessage(int Priority, int PauseDuration);
+	int Writecounter;
+	void enque(Packet*);
+	Packet* deque();
+	Packet* pfcdeque(int id);
+	REDQueue m_Queues[8];   // FIFO queues
+	int m_nThreshold[8];
+	int m_bPFC;
+	int m_nNumQueues;
+	int m_nMargin;
+
+	//PFC functionality
+	virtual int CheckState(Packet* p);
+	int m_pfcState[8];
+	void pfctimeout(int id);
+	void pfcResume(int id);
+	Event intr_;
+
+	PFCTimer m_pfcTimer[8];
+	PFCDeQTimer m_pfcDQTimer[8];
+	//NsObject* m_pSrcNode;
+
+	void CopyPacket(Packet *pTmp,Packet *p);
+protected:
+/*
+	REDQueue *q1_;   // 1st FIFO queue
+	REDQueue *q2_;   // 2nd FIFO queue
+	REDQueue *q3_;   // 3rd FIFO queue
+	REDQueue *q4_;   // 4th FIFO queue
+	REDQueue *q5_;   // 5th FIFO queue
+	REDQueue *q6_;   // 6th FIFO queue
+	REDQueue *q7_;   // 7th FIFO queue
+	REDQueue *q8_;   // 8th FIFO queue
+*/
+public:
+//	REDQueue* queue(int i)
+//	{
+//		if(i<m_nNumQueues)
+//			return m_Queues[i];
+//		else
+//			return NULL;
+//	};
+};
+
+
+
+
+
+
+class DtRrQueue : public Queue {
+ public:
+	DtRrQueue() {
+		q1_ = new PacketQueue;
+		q2_ = new PacketQueue;
+		pq_ = q1_;
+		deq_turn_ = 1;
+	}
+
+ protected:
+         void enque(Packet*);
+	 Packet* deque();
+
+	 PacketQueue *q1_;   // First  FIFO queue
+	 PacketQueue *q2_;   // Second FIFO queue
+	 int deq_turn_;      // 1 for First queue 2 for Second
+};
+
 #endif
diff -rpuN ns-allinone-2.34.base/ns-2.34/tcl/lib/ns-default.tcl ns-allinone-2.34.hyline/ns-2.34/tcl/lib/ns-default.tcl
--- ns-allinone-2.34.base/ns-2.34/tcl/lib/ns-default.tcl	2009-06-14 13:35:41.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/tcl/lib/ns-default.tcl	2016-05-01 17:02:38.000000000 -0400
@@ -103,9 +103,17 @@ Queue/DropTail set drop_front_ false
 Queue/DropTail set summarystats_ false
 Queue/DropTail set queue_in_bytes_ false
 Queue/DropTail set mean_pktsize_ 500
+# Mohammad: Smart drop
+Queue/DropTail set drop_smart_ false
+Queue/DropTail set sq_limit_ 10
 
 Queue/DropTail/PriQueue set Prefer_Routing_Protocols    1
 
+# Shuang: Priority drop
+Queue/DropTail set drop_prio_ false
+Queue/DropTail set deque_prio_ false
+Queue/DropTail set keep_order_ false
+
 # special cmu implemented priority queue used by DSR
 CMUPriQueue set qlen_logthresh_ 10
 CMUPriQueue set fw_logthresh_ 25
@@ -119,6 +127,24 @@ Queue/dsRED set ecn_ 0
 # support only xcp flows; set to 1 when supporting both tcp and xcp flows; temporary fix for allocating link BW between xcp and tcp queues until dynamic queue weights come into effect. This fix should then go away
 Queue/XCP set tcp_xcp_on_ 0  ;
 
+# Drop Tail Variant
+# Queue/DropTailVariant set drop_front_ false
+# Queue/DropTailVariant set summarystats_ false
+# Queue/DropTailVariant set queue_in_bytes_ false
+# Queue/DropTailVariant set mean_pktsize_ 500
+# Queue/DropTailVariant set tcp_queue_limit_pkts_ 1000
+
+# Queue/DropTailVariant/RCP set alpha_ 0.4
+# Queue/DropTailVariant/RCP set beta_ 0.4
+# Queue/DropTailVariant/RCP set gamma_ 1
+# Queue/DropTailVariant/RCP set min_pprtt_ 0.01
+# Queue/DropTailVariant/RCP set init_rate_fact_ 0.05
+# Queue/DropTailVariant/RCP set print_status_ 1
+# Queue/DropTailVariant/RCP set rate_fact_mode_ 0
+# Queue/DropTailVariant/RCP set fixed_rate_fact_ 0.05 ;# effecitve only if rate_fact_mode = 1
+# Queue/DropTailVariant/RCP set propag_rtt_ 1.0  ;# effecitve only if rate_fact_mode = 3
+# Queue/DropTailVariant/RCP set upd_timeslot_ 0.01  ;# rate update interval (sec).
+
 Queue/RED set bytes_ true ;		# default changed on 10/11/2004.
 Queue/RED set queue_in_bytes_ true ;	# default changed on 10/11/2004.
 # Queue/RED set thresh_ 5
@@ -168,6 +194,156 @@ Queue/RED set bottom_ 0
 ###   for automatic configuration.
 Queue/RED set cautious_ 0
 Queue/RED set feng_adaptive_ 0
+# Mohammad: Phantom Queue extensions
+Queue/RED set pq_enable_ 0
+Queue/RED set pq_mode_ 0
+Queue/RED set pq_drainrate_ 0 ; # need to set this when PQ is enabled
+                                # always in bps
+Queue/RED set pq_thresh_ 0
+# Shuang: priority dropping/deque extensions
+Queue/RED set drop_prio_ 0
+Queue/RED set deque_prio_ 0
+
+#
+#######################################################
+Agent/TCP/FullTcp/Sack/SolTCP set NI 1 ;#1Gbps
+Agent/TCP set start_wait 0 
+Agent/TCP set prempt_wait 0
+Agent/TCP set num_prempt 0
+
+if {1} {
+Queue/RPQ set queue_num_ 2
+Queue/RPQ set pfc_enable 0
+Queue/RPQ set pfc_threshold_0 500 ; #desabling pfc for queue #0
+Queue/RPQ set pfc_threshold_1 175
+Queue/RPQ set size_0 225
+Queue/RPQ set size_1 225
+Queue/RPQ set margin 10
+
+Queue/RPQ set bytes_ true ;		# default changed on 10/11/2004.
+Queue/RPQ set queue_in_bytes_ true ;	# default changed on 10/11/2004.
+# Queue/RPQ set thresh_ 5
+Queue/RPQ set thresh_ 0
+# Queue/RPQ/thresh_ was changed on 12/29/01, for automatic configuration.
+# Queue/RPQ set maxthresh_ 15
+Queue/RPQ set maxthresh_ 0
+# Queue/RPQ/maxthresh_ was changed on 12/29/01, for automatic configuration.
+Queue/RPQ set thresh_queue_ [Queue set limit_]
+# Note from Sally: I don't see that thresh_queue_ is used for anything.
+Queue/RPQ set maxthresh_queue_ [Queue set limit_]
+# Note from Sally: I don't see that maxthresh_queue_ is used for anything.
+Queue/RPQ set mean_pktsize_ 500
+Queue/RPQ set idle_pktsize_ 100
+# Queue/RPQ set q_weight_ 0.002
+Queue/RPQ set q_weight_ -1
+# Queue/RPQ/q_weight_ was changed on 12/29/01, for automatic configuration.
+Queue/RPQ set wait_ true
+Queue/RPQ set linterm_ 10
+Queue/RPQ set mark_p_ 0.1
+Queue/RPQ set use_mark_p_ true
+# Queue/RPQ/use_mark_p_ was added on 11/23/05.
+# Queue/RPQ/use_mark_p_ was changed to true on 12/22/05.
+Queue/RPQ set setbit_ false
+Queue/RPQ set gentle_ true
+### Queue/RPQ/gentle_ was changed from false to true on Apr 23, 2001.
+Queue/RPQ set drop_tail_ true
+Queue/RPQ set drop_front_ false
+Queue/RPQ set drop_rand_ false
+Queue/RPQ set doubleq_ false
+Queue/RPQ set ns1_compat_ false
+Queue/RPQ set dqthresh_ 50
+Queue/RPQ set ave_ 0.0
+Queue/RPQ set prob1_ 0.0
+Queue/RPQ set curq_ 0
+Queue/RPQ set cur_max_p_ 0
+Queue/RPQ set summarystats_ false
+### Adaptive RPQ.
+Queue/RPQ set alpha_ 0.01
+Queue/RPQ set beta_ 0.9 
+Queue/RPQ set adaptive_ 0
+Queue/RPQ set interval_ 0.5
+Queue/RPQ set targetdelay_ 0.005
+Queue/RPQ set top_ 0.5
+Queue/RPQ set bottom_ 0
+### Queue/RPQ/bottom_ was changed from 0.01 to 0 on June 23, 2004,
+###   for automatic configuration.
+Queue/RPQ set cautious_ 0
+Queue/RPQ set feng_adaptive_ 0
+# Mohammad: Phantom Queue extensions
+Queue/RPQ set pq_enable_ 0
+Queue/RPQ set pq_mode_ 0
+Queue/RPQ set pq_drainrate_ 0 ; # need to set this when PQ is enabled
+                                # always in bps
+Queue/RPQ set pq_thresh_ 0
+# Shuang: priority dropping/deque extensions
+Queue/RPQ set drop_prio_ 0
+Queue/RPQ set deque_prio_ 0
+
+}
+#Q[1]
+if {1} {
+Queue/RPQ set bytes_1 true ;		# default changed on 10/11/2004.
+Queue/RPQ set queue_in_bytes_1 true ;	# default changed on 10/11/2004.
+# Queue/RPQ set thresh_ 5
+Queue/RPQ set thresh_1 0
+# Queue/RPQ/thresh_ was changed on 12/29/01, for automatic configuration.
+# Queue/RPQ set maxthresh_ 15
+Queue/RPQ set maxthresh_1 0
+# Queue/RPQ/maxthresh_ was changed on 12/29/01, for automatic configuration.
+Queue/RPQ set thresh_queue_1 [Queue set limit_]
+# Note from Sally: I don't see that thresh_queue_ is used for anything.
+Queue/RPQ set maxthresh_queue_1 [Queue set limit_]
+# Note from Sally: I don't see that maxthresh_queue_ is used for anything.
+Queue/RPQ set mean_pktsize_1 500
+Queue/RPQ set idle_pktsize_1 100
+# Queue/RPQ set q_weight_ 0.002
+Queue/RPQ set q_weight_1 -1
+# Queue/RPQ/q_weight_ was changed on 12/29/01, for automatic configuration.
+Queue/RPQ set wait_1 true
+Queue/RPQ set linterm_1 10
+Queue/RPQ set mark_p_1 0.1
+Queue/RPQ set use_mark_p_1 true
+# Queue/RPQ/use_mark_p_ was added on 11/23/05.
+# Queue/RPQ/use_mark_p_ was changed to true on 12/22/05.
+Queue/RPQ set setbit_1 false
+Queue/RPQ set gentle_1 true
+### Queue/RPQ/gentle_ was changed from false to true on Apr 23, 2001.
+Queue/RPQ set drop_tail_1 true
+Queue/RPQ set drop_front_1 false
+Queue/RPQ set drop_rand_1 false
+Queue/RPQ set doubleq_1 false
+Queue/RPQ set ns1_compat_1 false
+Queue/RPQ set dqthresh_1 50
+Queue/RPQ set ave_1 0.0
+Queue/RPQ set prob1_1 0.0
+Queue/RPQ set curq_1 0
+Queue/RPQ set cur_max_p_1 0
+Queue/RPQ set summarystats_1 false
+### Adaptive RPQ.
+Queue/RPQ set alpha_1 0.01
+Queue/RPQ set beta_1 0.9 
+Queue/RPQ set adaptive_1 0
+Queue/RPQ set interval_1 0.5
+Queue/RPQ set targetdelay_1 0.005
+Queue/RPQ set top_1 0.5
+Queue/RPQ set bottom_1 0
+### Queue/RPQ/bottom_ was changed from 0.01 to 0 on June 23, 2004,
+###   for automatic configuration.
+Queue/RPQ set cautious_1 0
+Queue/RPQ set feng_adaptive_1 0
+# Mohammad: Phantom Queue extensions
+Queue/RPQ set pq_enable_1 0
+Queue/RPQ set pq_mode_1 0
+Queue/RPQ set pq_drainrate_1 0 ; # need to set this when PQ is enabled
+                                # always in bps
+Queue/RPQ set pq_thresh_1 0
+# Shuang: priority dropping/deque extensions
+Queue/RPQ set drop_prio_1 0
+Queue/RPQ set deque_prio_1 0
+
+}
+
+#######################################################
 
 Queue/RED/RIO set bytes_ false
 Queue/RED/RIO set queue_in_bytes_ false
@@ -235,6 +411,9 @@ Queue/Vq set mean_pktsize_ 1000
 Queue/Vq set curq_ 0
 Queue/Vq set drop_front_ 0
 Queue/Vq set markfront_ 0
+# Mohammad
+Queue/Vq set ctilde_ 0
+Queue/Vq set vq_len_ 0
 
 Queue/REM set gamma_ 0.001
 Queue/REM set phi_ 1.001
@@ -298,6 +477,20 @@ QueueMonitor set pdrops_ 0
 QueueMonitor set pmarks_ 0
 QueueMonitor set bdrops_ 0
 
+#added for count dropping from small flow - Shuang
+QueueMonitor set num_monitor_ 50
+for {set k 0} {$k < 50} {incr k} {
+    set tmp kdrops$k
+	QueueMonitor set $tmp 0
+	set tmp karrivals$k
+	QueueMonitor set $tmp 0
+}
+
+QueueMonitor set ack_arrivals_ 0
+QueueMonitor set ack_drops_ 0
+QueueMonitor set ack_departures_ 0
+
+
 QueueMonitor set qs_pkts_ 0
 QueueMonitor set qs_bytes_ 0
 QueueMonitor set qs_drops_ 0
@@ -360,8 +553,7 @@ DelayLink set bandwidth_ 1.5Mb
 DelayLink set delay_ 100ms
 DelayLink set debug_ false
 DelayLink set avoidReordering_ false ;	# Added 3/27/2003.
-					# Set to true to avoid reordering when
-					#   changing link bandwidth or delay.
+					# Set to true to avoid reordering when				
 DynamicLink set status_ 1
 DynamicLink set debug_ false
 
@@ -389,6 +581,11 @@ Classifier/Addr/MPLS set reroute_option_
 Classifier/Addr/MPLS set control_driven_ 0
 Classifier/Addr/MPLS set data_driven_ 0
 
+# Mohammad
+Classifier/MultiPath set nodeid_ 0
+Classifier/MultiPath set nodetype_ 0
+Classifier/MultiPath set perflow_ 0
+Classifier/MultiPath set checkpathid_ 0
 #
 # FEC models
 #
@@ -634,7 +831,16 @@ NetworkInterface set debug_ false
 TBF set rate_ 64k
 TBF set bucket_ 1024
 TBF set qlen_ 0
-
+# Mohammad: Pacer variables
+TBF set pacer_enable_ 0
+TBF set assoc_timeout_ 0.01
+TBF set assoc_prob_ 0.125
+TBF set maxrate_ 1000000000
+TBF set minrate_ 10000000
+TBF set qlength_factor_ 122;
+TBF set rate_ave_factor_ 0.125
+TBF set rate_update_interval_  0.000064
+TBF set debug_ 0
 #
 # mobile Ip
 #
@@ -1022,6 +1228,18 @@ Agent/TCP set control_increase_ 0
 
 Agent/TCP set SetCWRonRetransmit_ true ; # added on 2005/06/19.
 				 	 # default changed on 2008/06/05. 
+# Mohammad
+Agent/TCP set ecnhat_ false;
+Agent/TCP set ecnhat_smooth_alpha_ true;
+Agent/TCP set ecnhat_alpha_ 0.0;
+Agent/TCP set ecnhat_g_ 0.125;
+Agent/TCP set ecnhat_enable_beta_ false;
+Agent/TCP set ecnhat_beta_ 0.0;
+Agent/TCP set ecnhat_quadratic_beta_ false;
+Agent/TCP set ecnhat_tcp_friendly_ false;
+Agent/TCP set perPacketMP_ false;
+Agent/TCP set pathAwareMP_ false;
+Agent/TCP set num_paths_ 1
 
 # XXX Generate nam trace or plain old text trace for variables. 
 # When it's true, generate nam trace.
@@ -1057,6 +1275,7 @@ Agent/TCPSink set qs_enabled_ false
 Agent/TCPSink set RFC2581_immediate_ack_ true
 Agent/TCPSink set bytes_ 0
 Agent/TCPSink set ecn_syn_ false ;	# Added 2005/11/21 for SYN/ACK pkts.
+Agent/TCPSink set ecnhat_ false;
 
 Agent/TCPSink/DelAck set interval_ 100ms
 catch {
@@ -1229,6 +1448,21 @@ if [TclObject is-class Agent/TCP/FullTcp
         Agent/TCP/FullTcp set ecn_syn_ false; # Make SYN/ACK packet ECN-Capable?
         Agent/TCP/FullTcp set ecn_syn_wait_ 0; # Wait after marked SYN/ACK? 
         Agent/TCP/FullTcp set debug_ false;  # Added Sept. 16, 2007.
+	Agent/TCP/FullTcp set flow_remaining_ -1; #Mohammad: added for robust FCT measurement
+	Agent/TCP/FullTcp set dynamic_dupack_ 0; # Mohammad: if non-zero, set dupack threshold to max(3, dynamic_dupack_ * cwnd_)
+	Agent/TCP/FullTcp set prio_scheme_ 2; #Shuang: priority scheme
+	Agent/TCP/FullTcp set prio_num_ 0; #Shuang: number of priority
+	Agent/TCP/FullTcp set pfc_enable 0; #: pfc
+	Agent/TCP/FullTcp set prio_cap0 6*1460+15;
+	Agent/TCP/FullTcp set prio_cap1 16*1460+15;
+	Agent/TCP/FullTcp set prio_cap2 30*1460+15;
+	Agent/TCP/FullTcp set prio_cap3 49*1460+15;
+	Agent/TCP/FullTcp set prio_cap4 266*1460+15;
+	Agent/TCP/FullTcp set prio_cap5 1001*1460+15;
+	Agent/TCP/FullTcp set prio_cap6 2825*1460+15;
+	Agent/TCP/FullTcp set prob_cap_ 0; #Shuang: prob mode
+	Agent/TCP/FullTcp set deadline 0; #Shuang: deadline
+	Agent/TCP/FullTcp set early_terminated_ 0; #Shuang
 
 	Agent/TCP/FullTcp/Newreno set recov_maxburst_ 2; # max burst dur recov
 
@@ -1259,6 +1493,18 @@ if [TclObject is-class Agent/TCP/FullTcp
 		set open_cwnd_on_pack_ false
 	}
 
+	Agent/TCP/FullTcp/Sack/MinTCP instproc init {} {
+		$self next
+	}
+
+	Agent/TCP/FullTcp/Sack/DDTCP instproc init {} {
+		$self next
+	}
+
+	Agent/TCP/FullTcp/Sack/SolTCP instproc init {} {
+		$self next
+	}
+
 }
 
 if [TclObject is-class Agent/TCP/BayFullTcp] {
@@ -1451,6 +1697,24 @@ Queue set util_records_ 5 ; 		# Changed
 
 Delayer set debug_ false
 
+# # Nandita: Following is for Video traffic. Taken from Xiaoqing Zhu
+# Application/Traffic/VideoCBR set rate_ 0
+# Application/Traffic/VideoCBR set pktsize_ 1500
+# Application/Traffic/VideoCBR set fps_ 30
+# Application/Traffic/VideoCBR set gop_ 15
+# Application/Traffic/VideoCBR set fix_interval_ 0
+# Application/Traffic/VideoCBR set init_delay_ 0.5
+# Application/Traffic/VideoCBR set debug_ 0
+# Application/Traffic/VideoCBR set random_ 0
+
+# Application/Traffic/VideoTrace set init_delay_ 0.5
+# Application/Traffic/VideoTrace set quality_ 0
+# Application/Traffic/VideoTrace set fps_ 30
+# Application/Traffic/VideoTrace set advance_per_gop_ 1
+# Application/Traffic/VideoTrace set debug_ 0
+# Application/Traffic/VideoTrace set random_ 0
+# Application/Traffic/VideoTrace set loop_ 0
+
 Agent/TCP/Linux set rtxcur_init_ 3
 Agent/TCP/Linux set maxrto_ 120
 Agent/TCP/Linux set minrto_ 0.2
diff -rpuN ns-allinone-2.34.base/ns-2.34/tcl/lib/ns-default.tcl.rej ns-allinone-2.34.hyline/ns-2.34/tcl/lib/ns-default.tcl.rej
--- ns-allinone-2.34.base/ns-2.34/tcl/lib/ns-default.tcl.rej	1969-12-31 19:00:00.000000000 -0500
+++ ns-allinone-2.34.hyline/ns-2.34/tcl/lib/ns-default.tcl.rej	2016-05-01 17:02:22.000000000 -0400
@@ -0,0 +1,10 @@
+--- ns-2.34/tcl/lib/ns-default.tcl	2015-10-29 13:40:06.000000000 -0400
++++ ns-2.34/tcl/lib/ns-default.tcl	2015-11-01 11:37:16.270948126 -0500
+@@ -215,6 +215,7 @@
+ Queue/RPQ set pfc_threshold_1 175
+ Queue/RPQ set size_0 225
+ Queue/RPQ set size_1 225
++Queue/RPQ set margin 10
+ 
+ Queue/RPQ set bytes_ true ;		# default changed on 10/11/2004.
+ Queue/RPQ set queue_in_bytes_ true ;	# default changed on 10/11/2004.
diff -rpuN ns-allinone-2.34.base/ns-2.34/tcl/lib/ns-lib.tcl ns-allinone-2.34.hyline/ns-2.34/tcl/lib/ns-lib.tcl
--- ns-allinone-2.34.base/ns-2.34/tcl/lib/ns-lib.tcl	2009-06-14 13:35:41.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/tcl/lib/ns-lib.tcl	2016-05-01 17:02:22.000000000 -0400
@@ -1015,6 +1015,24 @@ Simulator instproc clearMemTrace {} {
 	$scheduler_ clearMemTrace
 }
 
+#:
+##
+Simulator instproc get-size { n1 n2 queuenum } {
+	$self instvar link_
+	puts "----"
+	set size [[$link_([$n1 id]:[$n2 id]) queue] get-size queuenum]
+	puts "size:$size"
+}
+
+Simulator instproc get-thr { n1 n2 queuenum } {
+	$self instvar link_	
+	puts "----"
+	set size [[$link_([$n1 id]:[$n2 id]) queue] get-threshold queuenum]
+	puts "size:$size"
+
+}
+##
+
 Simulator instproc simplex-link { n1 n2 bw delay qtype args } {
 	$self instvar link_ queueMap_ nullAgent_ useasim_
 	set sid [$n1 id]
@@ -1089,7 +1107,14 @@ Simulator instproc simplex-link { n1 n2
 		set pushback 0
 	}
 	$n1 add-neighbor $n2 $pushback
-	
+	if {$qtype == "RPQ"} {
+		puts "making an RPQ: setting proper queue's parameters"
+		[$link_($sid:$did) queue] srcnode $n1 
+		[$link_($sid:$did) queue] get-size 0
+		[$link_($sid:$did) queue] get-size 1
+		[$link_($sid:$did) queue] get-threshold 0
+		[$link_($sid:$did) queue] get-threshold 1
+	}
 	#XXX yuck
 	if {[string first "RED" $qtype] != -1 || 
 	    [string first "PI" $qtype] != -1 || 
@@ -1221,6 +1246,7 @@ Simulator instproc duplex-link { n1 n2 b
 	$self instvar link_
 	set i1 [$n1 id]
 	set i2 [$n2 id]
+#	puts "duplex-link"
 	if [info exists link_($i1:$i2)] {
 		$self remove-nam-linkconfig $i1 $i2
 	}
diff -rpuN ns-allinone-2.34.base/ns-2.34/tcl/lib/ns-link.tcl ns-allinone-2.34.hyline/ns-2.34/tcl/lib/ns-link.tcl
--- ns-allinone-2.34.base/ns-2.34/tcl/lib/ns-link.tcl	2009-06-14 13:35:41.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/tcl/lib/ns-link.tcl	2016-05-01 17:02:22.000000000 -0400
@@ -195,7 +195,10 @@ SimpleLink instproc init { src dst bw de
 	$queue_ target $link_
 	$link_ target [$dst entry]
 	$queue_ drop-target $drophead_
-
+	
+	#	
+	$queue_ nodeEntry [$dst entry]
+	
 	# XXX
 	# put the ttl checker after the delay
 	# so we don't have to worry about accounting
@@ -218,7 +221,7 @@ SimpleLink instproc init { src dst bw de
             	$self enable-src-rt $src $dst $head_
         	}
 	}
-
+	puts "$src $dst $head_ $queue_ $link_ $ttl_ [$dst entry]"
 }
 
 SimpleLink instproc enable-src-rt {src dst head} {
diff -rpuN ns-allinone-2.34.base/ns-2.34/tcl/lib/ns-link.tcl.orig ns-allinone-2.34.hyline/ns-2.34/tcl/lib/ns-link.tcl.orig
--- ns-allinone-2.34.base/ns-2.34/tcl/lib/ns-link.tcl.orig	2009-06-14 13:35:41.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/tcl/lib/ns-link.tcl.orig	1969-12-31 19:00:00.000000000 -0500
@@ -1,588 +0,0 @@
-#
-# Copyright (c) 1996 Regents of the University of California.
-# All rights reserved.
-# 
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions
-# are met:
-# 1. Redistributions of source code must retain the above copyright
-#    notice, this list of conditions and the following disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright
-#    notice, this list of conditions and the following disclaimer in the
-#    documentation and/or other materials provided with the distribution.
-# 3. All advertising materials mentioning features or use of this software
-#    must display the following acknowledgement:
-# 	This product includes software developed by the MASH Research
-# 	Group at the University of California Berkeley.
-# 4. Neither the name of the University nor of the Research Group may be
-#    used to endorse or promote products derived from this software without
-#    specific prior written permission.
-# 
-# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
-# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
-# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
-# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-# SUCH DAMAGE.
-#
-# @(#) $Header: /cvsroot/nsnam/ns-2/tcl/lib/ns-link.tcl,v 1.48 2004/10/28 23:35:39 haldar Exp $
-#
-
-Class Link
-
-Link set nl_ 0
-
-Link instproc init { src dst } {
-	$self next
-
-	# Debo
-	$self instvar id_
-	set id_ [Link set nl_]
-        Link set nl_ [expr $id_ + 1]
-
-# puts -nonewline "Link " 
-# puts " $id_  init"
-
-        #modified for interface code
-	$self instvar trace_ fromNode_ toNode_ color_ oldColor_
-	set fromNode_ $src
-	set toNode_   $dst
-	set color_ "black"
-	set oldColor_ "black"
-
-	set trace_ ""
-}
-
-Link instproc head {} {
-	$self instvar head_
-	return $head_
-}
-
-Link instproc add-to-head { connector } {
-	$self instvar head_
-	$connector target [$head_ target]
-	$head_ target $connector
-}
-
-Link instproc queue {} {
-	$self instvar queue_
-	return $queue_
-}
-
-Link instproc link {} {
-	$self instvar link_
-	return $link_
-}
-
-Link instproc src {}	{ $self set fromNode_	}
-Link instproc dst {}	{ $self set toNode_	}
-Link instproc cost c	{ $self set cost_ $c	}
-
-Link instproc cost? {} {
-	$self instvar cost_
-	if ![info exists cost_] {
-		set cost_ 1
-	}
-	set cost_
-}
-
-# Debo
-Link instproc id {} 	{ $self set id_ }
-Link instproc setid { x } { $self set id_ $x }
-Link instproc bw {} { $self set bandwidth_ }
-
-Link instproc if-label? {} {
-	$self instvar iif_
-	$iif_ label
-}
-
-Link instproc up { } {
-	$self instvar dynamics_ dynT_
-	if ![info exists dynamics_] return
-	$dynamics_ set status_ 1
-	if [info exists dynT_] {
-		foreach tr $dynT_ {
-			$tr format link-up {$src_} {$dst_}
-			set ns [Simulator instance]
-			$self instvar fromNode_ toNode_
-			$tr ntrace "l -t [$ns now] -s [$fromNode_ id] -d [$toNode_ id] -S UP"
-			$tr ntrace "v -t [$ns now] link-up [$ns now] [$fromNode_ id] [$toNode_ id]"
-		}
-	}
-}
-
-Link instproc down { } {
-	$self instvar dynamics_ dynT_
-	if ![info exists dynamics_] {
-		puts stderr "$class::$proc Link $self was not declared dynamic, and cannot be taken down.  ignored"
-		return
-	}
-	$dynamics_ set status_ 0
-	$self all-connectors reset
-	if [info exists dynT_] {
-		foreach tr $dynT_ {
-			$tr format link-down {$src_} {$dst_}
-			set ns [Simulator instance]
-			$self instvar fromNode_ toNode_
-			$tr ntrace "l -t [$ns now] -s [$fromNode_ id] -d [$toNode_ id] -S DOWN"
-			$tr ntrace "v -t [$ns now] link-down [$ns now] [$fromNode_ id] [$toNode_ id]"
-		}
-	}
-}
-
-Link instproc up? {} {
-	$self instvar dynamics_
-	if [info exists dynamics_] {
-		return [$dynamics_ status?]
-	} else {
-		return "up"
-	}
-}
-
-Link instproc all-connectors op {
-	foreach c [$self info vars] {
-		$self instvar $c
-		if ![info exists $c] continue
-		if [array size $c] continue
-		foreach var [$self set $c] {
-			if [catch "$var info class"] {
-				continue
-			}
-			if ![$var info class Node] { ;# $op on most everything
-				catch "$var $op";# in case var isn't a connector
-			}
-		}
-	}
-}
-
-Link instproc install-error {em} {
-	$self instvar link_
-	$em target [$link_ target]
-	$link_ target $em
-}
-
-Class SimpleLink -superclass Link
-
-SimpleLink instproc init { src dst bw delay q {lltype "DelayLink"} } {
-	$self next $src $dst
-	$self instvar link_ queue_ head_ toNode_ ttl_
-	$self instvar drophead_
-
-	set ns [Simulator instance]
-	set drophead_ [new Connector]
-	$drophead_ target [$ns set nullAgent_]
-
-	set head_ [new Connector]
-	$head_ set link_ $self
-
-	#set head_ $queue_ -> replace by the following
-	# xxx this is hacky
-	if { [[$q info class] info heritage ErrModule] == "ErrorModule" } {
-		$head_ target [$q classifier]
-        } else {
-                $head_ target $q
-        }
-
-	set queue_ $q
-	set link_ [new $lltype]
-	$link_ set bandwidth_ $bw
-	$link_ set delay_ $delay
-	$queue_ target $link_
-	$link_ target [$dst entry]
-	$queue_ drop-target $drophead_
-
-	# XXX
-	# put the ttl checker after the delay
-	# so we don't have to worry about accounting
-	# for ttl-drops within the trace and/or monitor
-	# fabric
-	#
-	set ttl_ [new TTLChecker]
-	$ttl_ target [$link_ target]
-	$self ttl-drop-trace
-	$link_ target $ttl_
-
-	# Finally, if running a multicast simulation,
-	# put the iif for the neighbor node...
-	if { [$ns multicast?] } {
-		$self enable-mcast $src $dst
-	}
-        $ns instvar srcRt_
-	if [info exists srcRt_] {
-        	if { $srcRt_ == 1 } {
-            	$self enable-src-rt $src $dst $head_
-        	}
-	}
-
-}
-
-SimpleLink instproc enable-src-rt {src dst head} {
-    $self instvar ttl_
-    $src instvar src_agent_
-    $ttl_ target [$dst entry]
-    $src_agent_ install_slot $head [$dst id]
-}
-
-
-SimpleLink instproc enable-mcast {src dst} {
-	$self instvar iif_ ttl_
-	set iif_ [new NetworkInterface]
-	$iif_ target [$ttl_ target]
-	$ttl_ target $iif_
-
-        $src add-oif [$self head]  $self
-        $dst add-iif [$iif_ label] $self
-}
-
-# Debo
-
-SimpleLink instproc bw {} { 
-	$self instvar link_
-	$link_ set bandwidth_ 
-
-}
-
-SimpleLink instproc delay {} {
-        $self instvar link_
-        $link_ set delay_
-}
-
-SimpleLink instproc qsize {} {
-	[$self queue] set limit_
-}
-
-#
-# should be called after SimpleLink::trace
-#
-SimpleLink instproc nam-trace { ns f } {
-	$self instvar enqT_ deqT_ drpT_ rcvT_ dynT_
-
-	#XXX 
-	# we use enqT_ as a flag of whether tracing has been
-	# initialized
-	if [info exists enqT_] {
-		$enqT_ namattach $f
-		if [info exists deqT_] {
-			$deqT_ namattach $f
-		}
-		if [info exists drpT_] {
-			$drpT_ namattach $f
-		}
-		if [info exists rcvT_] {
-			$rcvT_ namattach $f
-		}
-		if [info exists dynT_] {
-			foreach tr $dynT_ {
-				$tr namattach $f
-			}
-		}
-	} else {
-		$self trace $ns $f "nam"
-	}
-}
-
-#
-# Build trace objects for this link and
-# update the object linkage
-#
-# create nam trace files if op == "nam"
-#
-SimpleLink instproc trace { ns f {op ""} } {
-
-	$self instvar enqT_ deqT_ drpT_ queue_ link_ fromNode_ toNode_
-	$self instvar rcvT_ ttl_ trace_
-	$self instvar drophead_		;# idea stolen from CBQ and Kevin
-
-	set trace_ $f
-	set enqT_ [$ns create-trace Enque $f $fromNode_ $toNode_ $op]
-	set deqT_ [$ns create-trace Deque $f $fromNode_ $toNode_ $op]
-	set drpT_ [$ns create-trace Drop $f $fromNode_ $toNode_ $op]
-	set rcvT_ [$ns create-trace Recv $f $fromNode_ $toNode_ $op]
-
-	$self instvar drpT_ drophead_
-	set nxt [$drophead_ target]
-	$drophead_ target $drpT_
-	$drpT_ target $nxt
-
-	$queue_ drop-target $drophead_
-
-#	$drpT_ target [$queue_ drop-target]
-#	$queue_ drop-target $drpT_
-
-	$deqT_ target [$queue_ target]
-	$queue_ target $deqT_
-
-	# head is, like the drop-head_ a special connector.
-	# mess not with it.
-	$self add-to-head $enqT_
-
-	# put recv trace after ttl checking, so that only actually 
-	# received packets are recorded
-	$rcvT_ target [$ttl_ target]
-	$ttl_ target $rcvT_
-
-	$self instvar dynamics_
-	if [info exists dynamics_] {
-		$self trace-dynamics $ns $f $op
-	}
-}
-
-SimpleLink instproc trace-dynamics { ns f {op ""}} {
-	$self instvar dynT_ fromNode_ toNode_
-	lappend dynT_ [$ns create-trace Generic $f $fromNode_ $toNode_ $op]
-	$self transit-drop-trace
-	$self linkfail-drop-trace
-}
-
-SimpleLink instproc ttl-drop-trace args {
-	$self instvar ttl_
-	if ![info exists ttl_] return
-	if {[llength $args] != 0} {
-		$ttl_ drop-target [lindex $args 0]
-	} else {
-		$self instvar drophead_
-		$ttl_ drop-target $drophead_
-	}
-}
-
-SimpleLink instproc transit-drop-trace args {
-	$self instvar link_
-	if {[llength $args] != 0} {
-		$link_ drop-target [lindex $args 0]
-	} else {
-		$self instvar drophead_
-		$link_ drop-target $drophead_
-	}
-}
-
-SimpleLink instproc linkfail-drop-trace args {
-	$self instvar dynamics_
-	if ![info exists dynamics_] return
-	if {[llength $args] != 0} {
-		$dynamics_ drop-target [lindex $args 0]
-	} else {
-		$self instvar drophead_
-		$dynamics_ drop-target $drophead_
-	}
-}
-
-#
-# Trace to a callback function rather than a file.
-#
-SimpleLink instproc trace-callback {ns cmd} {
-	$self trace $ns {}
-	foreach part {enqT_ deqT_ drpT_ rcvT_} {
-		$self instvar $part
-		set to [$self set $part]
-		$to set callback_ 1
-		$to proc handle a "$cmd \$a"
-	}
-}
-
-#
-# like init-monitor, but allows for specification of more of the items
-# attach-monitors $insnoop $inqm $outsnoop $outqm $dropsnoop $dropqm
-#
-SimpleLink instproc attach-monitors { insnoop outsnoop dropsnoop qmon } {
-	$self instvar drpT_ queue_ snoopIn_ snoopOut_ snoopDrop_
-	$self instvar qMonitor_ drophead_
-
-	set snoopIn_ $insnoop
-	set snoopOut_ $outsnoop
-	set snoopDrop_ $dropsnoop
-
-	$self add-to-head $snoopIn_
-
-	$snoopOut_ target [$queue_ target]
-	$queue_ target $snoopOut_
-
-	set nxt [$drophead_ target]
-	$drophead_ target $snoopDrop_
-	$snoopDrop_ target $nxt
-
-#	if [info exists drpT_] {
-#		$snoopDrop_ target [$drpT_ target]
-#		$drpT_ target $snoopDrop_
-#		$queue_ drop-target $drpT_
-#	} else {
-#		$snoopDrop_ target [[Simulator instance] set nullAgent_]
-#		$queue_ drop-target $snoopDrop_
-#	}
-
-	$snoopIn_ set-monitor $qmon
-	$snoopOut_ set-monitor $qmon
-	$snoopDrop_ set-monitor $qmon
-	set qMonitor_ $qmon
-}
-
-# 
-# Added by Yun Wang, based on attach-monitors
-# 
-# like init-monitor, but allows for specification of more of the items
-# attach-taggers $insnoop $inqm
-#
-SimpleLink instproc attach-taggers { insnoop qmon } {
-        $self instvar drpT_ queue_ head_ snoopIn_ snoopOut_ snoopDrop_
-        $self instvar qMonitor_ drophead_
-
-        set snoopIn_ $insnoop
-
-        $snoopIn_ target $head_
-        set head_ $snoopIn_
-
-        $snoopIn_ set-monitor $qmon
-
-# This may cause problem when you want to insert both flow monitor and tagger.
-# Yun Wang
-
-        set qMonitor_ $qmon
-
-}
-
-#
-# Insert objects that allow us to monitor the queue size
-# of this link.  Return the name of the object that
-# can be queried to determine the average queue size.
-#
-SimpleLink instproc init-monitor { ns qtrace sampleInterval} {
-	$self instvar qMonitor_ ns_ qtrace_ sampleInterval_
-
-	set ns_ $ns
-	set qtrace_ $qtrace
-	set sampleInterval_ $sampleInterval
-	set qMonitor_ [new QueueMonitor]
-
-	$self attach-monitors [new SnoopQueue/In] \
-		[new SnoopQueue/Out] [new SnoopQueue/Drop] $qMonitor_
-
-	set bytesInt_ [new Integrator]
-	$qMonitor_ set-bytes-integrator $bytesInt_
-	set pktsInt_ [new Integrator]
-	$qMonitor_ set-pkts-integrator $pktsInt_
-	return $qMonitor_
-}
-
-SimpleLink instproc start-tracing { } {
-	$self instvar qMonitor_ ns_ qtrace_ sampleInterval_
-	$self instvar fromNode_ toNode_
-
-	if {$qtrace_ != 0} {
-		$qMonitor_ trace $qtrace_
-	}
-	$qMonitor_ set-src-dst [$fromNode_ id] [$toNode_ id]
-} 
-
-SimpleLink instproc queue-sample-timeout { } {
-	$self instvar qMonitor_ ns_ qtrace_ sampleInterval_
-	$self instvar fromNode_ toNode_
-	
-	set qavg [$self sample-queue-size]
-	if {$qtrace_ != 0} {
-		puts $qtrace_ "[$ns_ now] [$fromNode_ id] [$toNode_ id] $qavg"
-	}
-	$ns_ at [expr [$ns_ now] + $sampleInterval_] "$self queue-sample-timeout"
-}
-
-SimpleLink instproc sample-queue-size { } {
-	$self instvar qMonitor_ ns_ qtrace_ sampleInterval_ lastSample_
-
-	set now [$ns_ now]
-	set qBytesMonitor_ [$qMonitor_ get-bytes-integrator]
-	set qPktsMonitor_ [$qMonitor_ get-pkts-integrator]
-
-	$qBytesMonitor_ newpoint $now [$qBytesMonitor_ set lasty_]
-	set bsum [$qBytesMonitor_ set sum_]
-
-	$qPktsMonitor_ newpoint $now [$qPktsMonitor_ set lasty_]
-	set psum [$qPktsMonitor_ set sum_]
-
-	if ![info exists lastSample_] {
-		set lastSample_ 0
-	}
-	set dur [expr $now - $lastSample_]
-	if { $dur != 0 } {
-		set meanBytesQ [expr $bsum / $dur]
-		set meanPktsQ [expr $psum / $dur]
-	} else {
-		set meanBytesQ 0
-		set meanPktsQ 0
-	}
-	$qBytesMonitor_ set sum_ 0.0
-	$qPktsMonitor_ set sum_ 0.0
-	set lastSample_ $now
-
-	#return "$meanBytesQ $meanPktsQ"
-
-	$qMonitor_ instvar pdrops_ pdepartures_ parrivals_ bdrops_ bdepartures_ barrivals_
-
-	return "$meanBytesQ $meanPktsQ $parrivals_ $pdepartures_ $pdrops_ $barrivals_ $bdepartures_ $bdrops_"	
-
-}	
-
-
-SimpleLink instproc dynamic {} {
-	$self instvar dynamics_
-
-	if [info exists dynamics_] return
-	
-	set dynamics_ [new DynamicLink]
-	$self add-to-head $dynamics_
-	
-	$self transit-drop-trace
-	$self all-connectors isDynamic
-}
-
-#
-# insert an "error module" BEFORE the queue
-# point the em's drop-target to the drophead
-#
-SimpleLink instproc errormodule args {
-	$self instvar errmodule_ queue_ drophead_
-	if { $args == "" } {
-		return $errmodule_
-	}
-
-	set em [lindex $args 0]
-	set errmodule_ $em
-
-	$self add-to-head $em
-
-	$em drop-target $drophead_
-}
-
-#
-# Insert a loss module AFTER the queue. 
-#
-# Must be inserted *RIGHT AFTER* the deqT_ (if present) or queue_, because
-# nam can only visualize a packet drop if and only if it is on the link or 
-# in the queue
-#
-SimpleLink instproc insert-linkloss args { 
-	$self instvar link_errmodule_ queue_ drophead_ deqT_ 
-	if { $args == "" } {
-		return $link_errmodule_
-	}
-
-	set em [lindex $args 0]
-	if [info exists link_errmodule_] {
-		delete link_errmodule_
-	}
-	set link_errmodule_ $em
-
-        if [info exists deqT_] {
-                $em target [$deqT_ target]
-                $deqT_ target $em
-        } else {
-                $em target [$queue_ target]
-                $queue_ target $em
-        }
-
-	$em drop-target $drophead_
-}
-
-
diff -rpuN ns-allinone-2.34.base/ns-2.34/tcl/lib/ns-node.tcl ns-allinone-2.34.hyline/ns-2.34/tcl/lib/ns-node.tcl
--- ns-allinone-2.34.base/ns-2.34/tcl/lib/ns-node.tcl	2009-06-14 13:35:41.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/tcl/lib/ns-node.tcl	2016-05-01 17:02:22.000000000 -0400
@@ -88,9 +88,9 @@ Node instproc init args {
 	set nodetype_ [$ns_ get-nodetype]
 
 	$self mk-default-classifier
-
 	# XXX Eventually these two should also be converted to modules
 	set multiPath_ [$class set multiPath_]
+
 }
 
 # XXX This instproc is backward compatibility; when satellite node, mobile
@@ -205,6 +205,7 @@ Node instproc insert-entry { module clsf
 			$clsfr target $classifier_
 		} elseif { $hook != "" } {
 			$clsfr install $hook $classifier_
+			#puts "insertentry $clsfr $hook $classifier_"
 		}
 	}
 	# Associate this module to the classifier, so if the classifier is
@@ -231,6 +232,7 @@ Node instproc install-entry { module cls
 				$clsfr target $hook_assoc($classifier_)
 			} elseif { $hook != "" } {
 				$clsfr install $hook $hook_assoc_($classifier_)
+				#puts "installentry $clsfr $hook $classifier_"
 			}
 			set hook_assoc_($clsfr) $hook_assoc_($classifier_)
 			unset hook_assoc_($classifier_)
@@ -338,11 +340,14 @@ Node instproc add-routes {id ifs} {
 		}
 		$self add-route $id [$ifs head]
 		set routes_($id) 1
+	#puts "344"
 		return
 	}
+	#puts "346"
 	if {$routes_($id) <= 0 && [llength $ifs] == 1 && \
 			![info exists mpathClsfr_($id)]} {
 		$self add-route $id [$ifs head]
+			#puts "350"
 		set routes_($id) 1
 	} else {
 		if ![info exists mpathClsfr_($id)] {
@@ -350,18 +355,39 @@ Node instproc add-routes {id ifs} {
 			# 1. get new MultiPathClassifier,
 			# 2. migrate existing routes to that mclassifier
 			# 3. install the mclassifier in the node classifier_
-			#
+			#			
 			set mpathClsfr_($id) [new Classifier/MultiPath]
+			$mpathClsfr_($id) set nodeid_ [$self id]
+			set nodecolor_ [$self get-attribute "COLOR"]
+			set nodetype_ 0
+			if {$nodecolor_ == "green"} {
+				set nodetype_ 1
+			}
+			if {$nodecolor_ == "blue"} {
+				set nodetype_ 2
+			}
+			if {$nodecolor_ == "red"} {
+				set nodetype_ 3
+			}
+			$mpathClsfr_($id) set nodetype_ $nodetype_
 			if {$routes_($id) > 0} {
 				assert "$routes_($id) == 1"
 				$mpathClsfr_($id) installNext \
 						[$classifier_ in-slot? $id]
 			}
+#puts "22"
 			$classifier_ install $id $mpathClsfr_($id)
+	#puts "23"		
 		}
 		foreach L $ifs {
-			$mpathClsfr_($id) installNext [$L head]
+			#puts "24-L head:[$L head] -- $mpathClsfr_($id) ntoNodeid [[$L set toNode_] id]"
+			#$mpathClsfr_($id) installNext [$L head]
+			#:
+			
+			set sl [$mpathClsfr_($id) cmd installNext [$L head] [[$L set toNode_] id]]
+			$mpathClsfr_($id) set slots_($sl) [$L head]			
 			incr routes_($id)
+			#puts "25"
 		}
 	}
 }
diff -rpuN ns-allinone-2.34.base/ns-2.34/tcl/lib/ns-queue.tcl ns-allinone-2.34.hyline/ns-2.34/tcl/lib/ns-queue.tcl
--- ns-allinone-2.34.base/ns-2.34/tcl/lib/ns-queue.tcl	2009-06-14 13:35:41.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/tcl/lib/ns-queue.tcl	2016-05-01 17:02:22.000000000 -0400
@@ -42,6 +42,29 @@
 # procs for some queues like FQ and RED/PD
 #
 
+#: Adding PFC to RPQ
+
+#
+# RPQ
+#
+
+Queue/RPQ instproc srcnode { src } {
+	$self instvar srcnode_
+	$self set srcnode_ $src
+}
+
+Queue/RPQ instproc srcnode_instance {} {
+	$self instvar srcnode_
+	return $srcnode_
+}
+
+Queue/RPQ instproc sendpfcmessage { prio duration } {
+	$self instvar srcnode_
+	puts "calling pfcmessage @ Classifier: entry [[$self srcnode_instance] entry] pfcmessage [$srcnode_ id]  $prio $duration"
+	set src [[$self srcnode_instance] entry]
+	$src pfcmessage [[$self srcnode_instance] id]  $prio $duration
+}
+
 #
 # CBQ
 #
@@ -400,6 +423,7 @@ FQLink instproc init { src dst bw delay
 	$self instvar link_ queue_ head_ toNode_ ttl_ classifier_ \
 		nactive_ 
 	$self instvar drophead_		;# idea stolen from CBQ and Kevin
+#	$self instvar NodeEntry_		;# End of the link: node's entrance 
 
 	set nactive_ 0
 
diff -rpuN ns-allinone-2.34.base/ns-2.34/tcp/tcp.cc ns-allinone-2.34.hyline/ns-2.34/tcp/tcp.cc
--- ns-allinone-2.34.base/ns-2.34/tcp/tcp.cc	2009-06-14 13:35:44.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/tcp/tcp.cc	2016-05-01 17:02:38.000000000 -0400
@@ -1,36 +1,3 @@
-/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
-/*
- * Copyright (c) 1991-1997 Regents of the University of California.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the Computer Systems
- *	Engineering Group at Lawrence Berkeley Laboratory.
- * 4. Neither the name of the University nor of the Laboratory may be used
- *    to endorse or promote products derived from this software without
- *    specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
 
 #ifndef lint
 static const char rcsid[] =
@@ -67,6 +34,7 @@ public:
 
 TcpAgent::TcpAgent() 
 	: Agent(PT_TCP), 
+		nStartWaitTime(0), nPremptWaitTime(0), nNumPrempt(0),
 	  t_seqno_(0), dupacks_(0), curseq_(0), highest_ack_(0), 
           cwnd_(0), ssthresh_(0), maxseq_(0), count_(0), 
           rtt_active_(0), rtt_seq_(-1), rtt_ts_(0.0), 
@@ -76,7 +44,8 @@ TcpAgent::TcpAgent()
 	  first_decrease_(1), fcnt_(0), nrexmit_(0), restart_bugfix_(1), 
           cong_action_(0), ecn_burst_(0), ecn_backoff_(0), ect_(0), 
           use_rtt_(0), qs_requested_(0), qs_approved_(0),
-	  qs_window_(0), qs_cwnd_(0), frto_(0)
+	  qs_window_(0), qs_cwnd_(0), frto_(0), ecnhat_recalc_seq(0), ecnhat_num_marked(0),ecnhat_total(0),
+	  ecnhat_maxseq(0), ecnhat_not_marked(0), ecnhat_mark_period(0), target_wnd(0) , ecnhat_tcp_friendly_increase_(1.0)
 {
 #ifdef TCP_DELAY_BIND_ALL
         // defined since Dec 1999.
@@ -101,6 +70,22 @@ TcpAgent::TcpAgent()
         bind("necnresponses_", &necnresponses_);
         bind("ncwndcuts_", &ncwndcuts_);
 	bind("ncwndcuts1_", &ncwndcuts1_);
+	// Mohammad
+	bind("ecnhat_", &ecnhat_);
+	bind("ecnhat_smooth_alpha_", &ecnhat_smooth_alpha_);  
+	bind("ecnhat_alpha_", &ecnhat_alpha_);
+	bind("ecnhat_g_", &ecnhat_g_);
+	bind("ecnhat_enable_beta_", &ecnhat_enable_beta_);
+	bind("ecnhat_beta_", &ecnhat_beta_);
+	bind("ecnhat_quadratic_beta_", &ecnhat_quadratic_beta_);
+	bind("ecnhat_tcp_friendly_", &ecnhat_tcp_friendly_);
+	/**
+	 * :
+	 */
+//	bind("start_wait", &nStartWaitTime);
+//	bind("prempt_wait", &nPremptWaitTime);
+//	bind("num_prempt", &nNumPrempt);
+
 #endif /* TCP_DELAY_BIND_ALL */
 
 }
@@ -109,6 +94,10 @@ void
 TcpAgent::delay_bind_init_all()
 {
 
+//	delay_bind_init_one("start_wait");
+//	delay_bind_init_one("prempt_wait");
+//	delay_bind_init_one("num_prempt");
+
         // Defaults for bound variables should be set in ns-default.tcl.
         delay_bind_init_one("window_");
         delay_bind_init_one("windowInit_");
@@ -123,6 +112,16 @@ TcpAgent::delay_bind_init_all()
         delay_bind_init_one("overhead_");
         delay_bind_init_one("tcpTick_");
         delay_bind_init_one("ecn_");
+	// Mohammad
+	delay_bind_init_one("ecnhat_"); 
+	delay_bind_init_one("ecnhat_smooth_alpha_"); 
+	delay_bind_init_one("ecnhat_alpha_");
+	delay_bind_init_one("ecnhat_g_");
+	delay_bind_init_one("ecnhat_beta_");
+	delay_bind_init_one("ecnhat_enable_beta_");
+	delay_bind_init_one("ecnhat_quadratic_beta_");
+	delay_bind_init_one("ecnhat_tcp_friendly_");
+
         delay_bind_init_one("SetCWRonRetransmit_");
         delay_bind_init_one("old_ecn_");
         delay_bind_init_one("bugfix_ss_");
@@ -234,7 +233,17 @@ TcpAgent::delay_bind_dispatch(const char
         if (delay_bind(varName, localName, "overhead_", &overhead_, tracer)) return TCL_OK;
         if (delay_bind(varName, localName, "tcpTick_", &tcp_tick_, tracer)) return TCL_OK;
         if (delay_bind_bool(varName, localName, "ecn_", &ecn_, tracer)) return TCL_OK;
-        if (delay_bind_bool(varName, localName, "SetCWRonRetransmit_", &SetCWRonRetransmit_, tracer)) return TCL_OK;
+	// Mohammad
+        if (delay_bind_bool(varName, localName, "ecnhat_", &ecnhat_, tracer)) return TCL_OK; 
+        if (delay_bind_bool(varName, localName, "ecnhat_smooth_alpha_", &ecnhat_smooth_alpha_, tracer)) return TCL_OK; 
+	if (delay_bind(varName, localName, "ecnhat_alpha_", &ecnhat_alpha_ , tracer)) return TCL_OK;
+        if (delay_bind(varName, localName, "ecnhat_g_", &ecnhat_g_ , tracer)) return TCL_OK;
+	if (delay_bind_bool(varName, localName, "ecnhat_enable_beta_", &ecnhat_enable_beta_ , tracer)) return TCL_OK;
+	if (delay_bind(varName, localName, "ecnhat_beta_", &ecnhat_beta_ , tracer)) return TCL_OK;
+	if (delay_bind_bool(varName, localName, "ecnhat_quadratic_beta_", &ecnhat_quadratic_beta_ , tracer)) return TCL_OK;
+	if (delay_bind_bool(varName, localName, "ecnhat_tcp_friendly_", &ecnhat_tcp_friendly_, tracer)) return TCL_OK; 
+
+	if (delay_bind_bool(varName, localName, "SetCWRonRetransmit_", &SetCWRonRetransmit_, tracer)) return TCL_OK;
         if (delay_bind_bool(varName, localName, "old_ecn_", &old_ecn_ , tracer)) return TCL_OK;
         if (delay_bind_bool(varName, localName, "bugfix_ss_", &bugfix_ss_ , tracer)) return TCL_OK;
         if (delay_bind(varName, localName, "eln_", &eln_ , tracer)) return TCL_OK;
@@ -546,10 +555,12 @@ double TcpAgent::rtt_timeout()
 	if (timeout > maxrto_)
 		timeout = maxrto_;
 
-        if (timeout < 2.0 * tcp_tick_) {
+    if (timeout < 2.0 * tcp_tick_) {
 		if (timeout < 0) {
 			fprintf(stderr, "TcpAgent: negative RTO!  (%f)\n",
 				timeout);
+			fflush(stdout);
+			fflush(stderr);
 			exit(1);
 		} else if (use_rtt_ && timeout < tcp_tick_)
 			timeout = tcp_tick_;
@@ -565,6 +576,7 @@ double TcpAgent::rtt_timeout()
 void TcpAgent::rtt_update(double tao)
 {
 	double now = Scheduler::instance().clock();
+	//printf("%f\n", tao);
 	if (ts_option_)
 		t_rtt_ = int(tao /tcp_tick_ + 0.5);
 	else {
@@ -610,7 +622,8 @@ void TcpAgent::rtt_update(double tao)
 
 void TcpAgent::rtt_backoff()
 {
-	if (t_backoff_ < 64 || rfc2988_)
+	//if (t_backoff_ < 64 || rfc2988_)
+	if (t_backoff_ < 64 || (rfc2988_ && rtt_timeout() < maxrto_))
         	t_backoff_ <<= 1;
         // RFC2988 allows a maximum for the backed-off RTO of 60 seconds.
         // This is applied by maxrto_.
@@ -665,14 +678,17 @@ void TcpAgent::output(int seqno, int rea
 	// (A real TCP would use scoreboard for this.)
         if (bugfix_ts_ && tss==NULL) {
                 tss = (double*) calloc(tss_size_, sizeof(double));
-                if (tss==NULL) exit(1);
+                if (tss==NULL) {
+					fflush(stdout);
+					exit(1);
+					}
         }
         //dynamically grow the timestamp array if it's getting full
         if (bugfix_ts_ && ((seqno - highest_ack_) > tss_size_* 0.9)) {
                 double *ntss;
                 ntss = (double*) calloc(tss_size_*2, sizeof(double));
                 printf("%p resizing timestamp table\n", this);
-                if (ntss == NULL) exit(1);
+                if (ntss == NULL) { fflush(stdout); exit(1);}
                 for (int i=0; i<tss_size_; i++)
                         ntss[(highest_ack_ + i) % (tss_size_ * 2)] =
                                 tss[(highest_ack_ + i) % tss_size_];
@@ -870,7 +886,25 @@ int TcpAgent::command(int argc, const ch
 			t_backoff_ = other->t_backoff_;
 			return (TCL_OK);
 		}
+	} else if (argc==2)
+	{
+		if (strcmp(argv[1], "start_wait") == 0)
+		{
+			Tcl::instance().resultf("%f",nStartWaitTime);
+			return(TCL_OK);
+		}
+		if (strcmp(argv[1], "prempt_wait") == 0)
+		{
+			Tcl::instance().resultf("%f",nPremptWaitTime);
+			return(TCL_OK);
+		}
+		if (strcmp(argv[1], "num_prempt") == 0)
+		{
+			Tcl::instance().resultf("%d",nNumPrempt);
+			return(TCL_OK);
+		}
 	}
+
 	return (Agent::command(argc, argv));
 }
 
@@ -1119,7 +1153,12 @@ void TcpAgent::opencwnd()
 	double increment;
 	if (cwnd_ < ssthresh_) {
 		/* slow-start (exponential) */
-		cwnd_ += 1;
+		if (ecnhat_enable_beta_)
+			cwnd_ += ecnhat_beta_ / cwnd_;
+		else{
+			//cwnd_ += increase_num_ / cwnd_;
+			cwnd_ += 1;
+	       	}
 	} else {
 		/* linear */
 		double f;
@@ -1133,14 +1172,30 @@ void TcpAgent::opencwnd()
 
 		case 1:
 			/* This is the standard algorithm. */
-			increment = increase_num_ / cwnd_;
+			if (ecnhat_enable_beta_)
+				increment = ecnhat_beta_ / cwnd_;
+			else if (ecnhat_tcp_friendly_) {
+				ecnhat_tcp_friendly_increase_ = ((int(t_srtt_) >> T_SRTT_BITS)*tcp_tick_ / 0.0004);// * ((int(t_srtt_) >> T_SRTT_BITS)*tcp_tick_ / 0.0004);
+				//printf("increase_factor = %f, s_rtt = %f\n",  ecnhat_tcp_friendly_increase_, (int(t_srtt_) >> T_SRTT_BITS)*tcp_tick_);				
+				increment = ecnhat_tcp_friendly_increase_ / cwnd_;
+				//increment = increase_num_ / cwnd_;
+			}
+			else
+				increment = increase_num_ / cwnd_;
+
 			if ((last_cwnd_action_ == 0 ||
 			  last_cwnd_action_ == CWND_ACTION_TIMEOUT) 
 			  && max_ssthresh_ > 0) {
 				increment = limited_slow_start(cwnd_,
 				  max_ssthresh_, increment);
 			}
+			//printf("%f: target = %f cwnd = %f\n", Scheduler::instance().clock(), target_wnd, (double) cwnd_);
+			/*if (1) {
+				target_wnd += increment;
+				cwnd_ += (target_wnd - cwnd_)/2.0/cwnd_;
+				} else*/
 			cwnd_ += increment;
+			
 			break;
 
 		case 2:
@@ -1245,6 +1300,8 @@ TcpAgent::slowdown(int how)
 	if (!(how & TCP_IDLE) && !(how & NO_OUTSTANDING_DATA)){
 		++ncwndcuts1_; 
 	}
+
+	//ecnhat_alpha_ = 0.07;
 	// we are in slowstart for sure if cwnd < ssthresh
 	if (cwnd_ < ssthresh_) 
 		slowstart = 1;
@@ -1264,6 +1321,7 @@ TcpAgent::slowdown(int how)
 	 		decreasewin = decrease_num_ * windowd();
 		}
 		win = windowd();
+		//printf("decrease param = %f window = %f decwin = %f\n", decrease_num_, win, decreasewin);
 	} else  {
 		int temp;
 		temp = (int)(window() / 2);
@@ -1295,6 +1353,9 @@ TcpAgent::slowdown(int how)
 		} else {
 			ssthresh_ = (int) decreasewin;
 		}
+	else if (how & CLOSE_SSTHRESH_ECNHAT) 
+		ssthresh_ = (int) ((1 - ecnhat_alpha_/2.0) * windowd());
+	//ssthresh_ = (int) (windowd() - sqrt(2*windowd())/2.0);		
         else if (how & THREE_QUARTER_SSTHRESH)
 		if (ssthresh_ < 3*cwnd_/4)
 			ssthresh_  = (int)(3*cwnd_/4);
@@ -1304,7 +1365,10 @@ TcpAgent::slowdown(int how)
 		if (first_decrease_ == 1 || slowstart || decrease_num_ == 0.5) {
 			cwnd_ = halfwin;
 		} else cwnd_ = decreasewin;
-        else if (how & CWND_HALF_WITH_MIN) {
+        else if (how & CLOSE_CWND_ECNHAT)
+		cwnd_ = (1 - ecnhat_alpha_/2.0) * windowd();
+	//cwnd_ = windowd() - sqrt(2*windowd())/2.0;      
+	else if (how & CWND_HALF_WITH_MIN) {
 		// We have not thought about how non-standard TCPs, with
 		// non-standard values of decrease_num_, should respond
 		// after quiescent periods.
@@ -1314,8 +1378,8 @@ TcpAgent::slowdown(int how)
 	}
 	else if (how & CLOSE_CWND_RESTART) 
 		cwnd_ = int(wnd_restart_);
-	else if (how & CLOSE_CWND_INIT)
-		cwnd_ = int(wnd_init_);
+	else if (how & CLOSE_CWND_INIT) 	  
+	        cwnd_ = int(wnd_init_);
 	else if (how & CLOSE_CWND_ONE)
 		cwnd_ = 1;
 	else if (how & CLOSE_CWND_HALF_WAY) {
@@ -1326,7 +1390,9 @@ TcpAgent::slowdown(int how)
 	}
 	if (ssthresh_ < 2)
 		ssthresh_ = 2;
-	if (how & (CLOSE_CWND_HALF|CLOSE_CWND_RESTART|CLOSE_CWND_INIT|CLOSE_CWND_ONE))
+	if (cwnd_ < 1)
+		cwnd_ = 1; // Added by Mohammad
+	if (how & (CLOSE_CWND_HALF|CLOSE_CWND_RESTART|CLOSE_CWND_INIT|CLOSE_CWND_ONE|CLOSE_CWND_ECNHAT))
 		cong_action_ = TRUE;
 
 	fcnt_ = count_ = 0;
@@ -1418,20 +1484,73 @@ void TcpAgent::newack(Packet* pkt)
  */
 void TcpAgent::ecn(int seqno)
 {
-	if (seqno > recover_ || 
-	      last_cwnd_action_ == CWND_ACTION_TIMEOUT) {
+	if (seqno > recover_ ||  
+	    last_cwnd_action_ == CWND_ACTION_TIMEOUT) {
 		recover_ =  maxseq_;
 		last_cwnd_action_ = CWND_ACTION_ECN;
 		if (cwnd_ <= 1.0) {
 			if (ecn_backoff_) 
 				rtt_backoff();
 			else ecn_backoff_ = 1;
-		} else ecn_backoff_ = 0;
-		slowdown(CLOSE_CWND_HALF|CLOSE_SSTHRESH_HALF);
+			} else ecn_backoff_ = 0;
+		if (ecnhat_) { 
+			if (ecnhat_tcp_friendly_) {
+				target_wnd = cwnd_;
+				//printf("changed target wnd = %f\n", target_wnd);
+				ecnhat_tcp_friendly_increase_ = 1.5/(2.0/ecnhat_alpha_ - 0.5);
+			}
+			slowdown(CLOSE_CWND_ECNHAT|CLOSE_SSTHRESH_ECNHAT);
+		
+		}
+			
+		else
+			slowdown(CLOSE_CWND_HALF|CLOSE_SSTHRESH_HALF);
 		++necnresponses_ ;
 		// added by sylvia to count number of ecn responses 
+		}
+}
+
+/*
+ * Mohammad: Update ecnhat alpha based on the ecn bit in the received packet.
+ *
+ * This procedure is called only when ecnhat_ is 1.
+ */
+void TcpAgent::update_ecnhat_alpha(Packet *pkt)
+{
+	int ecnbit = hdr_flags::access(pkt)->ecnecho();
+	int ackno = hdr_tcp::access(pkt)->ackno();
+	
+	if (!ecnhat_smooth_alpha_) 
+		ecnhat_alpha_ = (1 - ecnhat_g_) * ecnhat_alpha_ + ecnhat_g_ * ecnbit;
+	else {
+	        int acked_bytes = ackno - highest_ack_; 
+		if (acked_bytes <= 0) 
+		  acked_bytes = size_;
+		//printf("size_ = %d, acked_bytes = %d\n",size_, acked_bytes);
+		//ecnhat_total++;
+		ecnhat_total += acked_bytes;
+		if (ecnbit) {
+		  //ecnhat_num_marked++;
+		        ecnhat_num_marked += acked_bytes;
+		        ecnhat_beta_ = 1;
+		}
+		if (ackno > ecnhat_recalc_seq) {
+			double temp_alpha;
+			ecnhat_recalc_seq = ecnhat_maxseq;
+			if (ecnhat_total > 0) { 
+				temp_alpha = ((double) ecnhat_num_marked) / ecnhat_total;
+			} else temp_alpha = 0.0;
+
+			
+			//printf("%f %f %f %f\n", Scheduler::instance().clock(), (double) cwnd_, temp_alpha, ecnhat_alpha_);
+			ecnhat_alpha_ = (1 - ecnhat_g_) * ecnhat_alpha_ + ecnhat_g_ * temp_alpha;	
+			ecnhat_num_marked = 0;
+			ecnhat_total = 0;
+		}
 	}
+
 }
+ 
 
 /*
  *  Is the connection limited by the network (instead of by a lack
@@ -1453,6 +1572,7 @@ void TcpAgent::recv_newack_helper(Packet
                 // We can exit the Quick-Start phase.
                 qs_window_ = 0;
         }
+       
 	if (!ect_ || !hdr_flags::access(pkt)->ecnecho() ||
 		(old_ecn_ && ecn_burst_)) {
 		/* If "old_ecn", this is not the first ACK carrying ECN-Echo
@@ -1797,8 +1917,10 @@ void TcpAgent::recv(Packet *pkt, Handler
 	++nackpack_;
 	ts_peer_ = tcph->ts();
 	int ecnecho = hdr_flags::access(pkt)->ecnecho();
-	if (ecnecho && ecn_)
+	
+	if (ecnecho && ecn_) 
 		ecn(tcph->seqno());
+	
 	recv_helper(pkt);
 	recv_frto_helper(pkt);
 	/* grow cwnd and check if the connection is done */ 
@@ -1812,6 +1934,7 @@ void TcpAgent::recv(Packet *pkt, Handler
                         tcp_eln(pkt);
                         return;
                 }
+printf("dupacks= %d\n",dupacks_+1);
 		if (++dupacks_ == numdupacks_ && !noFastRetrans_) {
 			dupack_action();
 		} else if (dupacks_ < numdupacks_ && singledup_ ) {
diff -rpuN ns-allinone-2.34.base/ns-2.34/tcp/tcp-full.cc ns-allinone-2.34.hyline/ns-2.34/tcp/tcp-full.cc
--- ns-allinone-2.34.base/ns-2.34/tcp/tcp-full.cc	2009-06-14 13:35:44.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/tcp/tcp-full.cc	2016-05-31 12:11:24.000000000 -0400
@@ -1,75 +1,4 @@
-/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
-
-/*
- * Copyright (c) Intel Corporation 2001. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright (c) 1997, 1998 The Regents of the University of California.
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- * 	This product includes software developed by the Network Research
- * 	Group at Lawrence Berkeley National Laboratory.
- * 4. Neither the name of the University nor of the Laboratory may be used
- *    to endorse or promote products derived from this software without
- *    specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-/*
- *
- * Full-TCP : A two-way TCP very similar to the 4.4BSD version of Reno TCP.
- * This version also includes variants Tahoe, NewReno, and SACK.
- *
- * This code below has received a fairly major restructuring (Aug. 2001).
- * The ReassemblyQueue structure is now removed to a separate module and
- * entirely re-written.
- * Also, the SACK functionality has been re-written (almost) entirely.
- * -KF [kfall@intel.com]
- *
- * This code below was motivated in part by code contributed by
- * Kathie Nichols (nichols@baynetworks.com).  The code below is based primarily
- * on the 4.4BSD TCP implementation. -KF [kfall@ee.lbl.gov]
- *
- * Kathie Nichols and Van Jacobson have contributed significant bug fixes,
- * especially with respect to the the handling of sequence numbers during
- * connection establishment/clearin.  Additional fixes have followed
- * theirs.
- *
- * Fixes for gensack() and ReassemblyQueue::add() contributed by Richard 
- * Mortier <Richard.Mortier@cl.cam.ac.uk>
+ /* Mortier <Richard.Mortier@cl.cam.ac.uk>
  *
  * Some warnings and comments:
  *	this version of TCP will not work correctly if the sequence number
@@ -117,6 +46,11 @@ static const char rcsid[] =
 #include "flags.h"
 #include "random.h"
 #include "template.h"
+#include "math.h"
+#include "common/common.h"
+#define DBGTCP 0
+#define DBGCOST 0
+//(curseq_>1000000)?4:0
 
 #ifndef TRUE
 #define	TRUE 	1
@@ -171,6 +105,22 @@ public:
 	}
 } class_sack_full;
 
+static class MinTcpClass : public TclClass {
+public:
+	MinTcpClass() : TclClass("Agent/TCP/FullTcp/Sack/MinTCP") {}
+	TclObject* create(int, const char*const*) {
+		return (new MinTcpAgent());
+	}
+} class_min_full;
+
+static class DDTcpClass : public TclClass {
+public:
+	DDTcpClass() : TclClass("Agent/TCP/FullTcp/Sack/DDTCP") {}
+	TclObject* create(int, const char*const*) {
+		return (new DDTcpAgent());
+	}
+} class_dd_full;
+
 /*
  * Delayed-binding variable linkage
  */
@@ -199,7 +149,23 @@ FullTcpAgent::delay_bind_init_all()
         delay_bind_init_one("ecn_syn_wait_");
         delay_bind_init_one("debug_");
         delay_bind_init_one("spa_thresh_");
+	
+	delay_bind_init_one("flow_remaining_"); //Mohammad
+	delay_bind_init_one("dynamic_dupack_");
+
+	delay_bind_init_one("prio_scheme_"); // Shuang
+	delay_bind_init_one("prio_num_"); //Shuang
+	delay_bind_init_one("prio_cap0"); //Shuang
+	delay_bind_init_one("prio_cap1"); //Shuang
+	delay_bind_init_one("prio_cap2"); //Shuang
+	delay_bind_init_one("prio_cap3"); //Shuang
+	delay_bind_init_one("prio_cap4"); //Shuang
+	delay_bind_init_one("prio_cap5"); //Shuang
+	delay_bind_init_one("prio_cap6"); //Shuang
+	delay_bind_init_one("deadline"); //Shuang
+	delay_bind_init_one("early_terminated_"); //Shuang
 
+	delay_bind_init_one("pfc_enable"); //
 	TcpAgent::delay_bind_init_all();
        
       	reset();
@@ -229,7 +195,21 @@ FullTcpAgent::delay_bind_dispatch(const
         if (delay_bind_bool(varName, localName, "ecn_syn_", &ecn_syn_, tracer)) return TCL_OK;
         if (delay_bind(varName, localName, "ecn_syn_wait_", &ecn_syn_wait_, tracer)) return TCL_OK;
         if (delay_bind_bool(varName, localName, "debug_", &debug_, tracer)) return TCL_OK;
-
+	if (delay_bind(varName, localName, "flow_remaining_", &flow_remaining_, tracer)) return TCL_OK; // Mohammad
+	if (delay_bind(varName, localName, "dynamic_dupack_", &dynamic_dupack_, tracer)) return TCL_OK; // Mohammad
+	if (delay_bind(varName, localName, "prio_scheme_", &prio_scheme_, tracer)) return TCL_OK; // Shuang
+	if (delay_bind(varName, localName, "prio_num_", &prio_num_, tracer)) return TCL_OK; //Shuang
+	if (delay_bind(varName, localName, "pfc_enable", &m_bPFC, tracer)) return TCL_OK;
+	if (delay_bind(varName, localName, "prio_cap0", &prio_cap_[0], tracer)) return TCL_OK; 
+	if (delay_bind(varName, localName, "prio_cap1", &prio_cap_[1], tracer)) return TCL_OK; 
+	if (delay_bind(varName, localName, "prio_cap2", &prio_cap_[2], tracer)) return TCL_OK; 
+	if (delay_bind(varName, localName, "prio_cap3", &prio_cap_[3], tracer)) return TCL_OK; 
+	if (delay_bind(varName, localName, "prio_cap4", &prio_cap_[4], tracer)) return TCL_OK; 
+	if (delay_bind(varName, localName, "prio_cap5", &prio_cap_[5], tracer)) return TCL_OK; 
+	if (delay_bind(varName, localName, "prio_cap6", &prio_cap_[6], tracer)) return TCL_OK; 
+	if (delay_bind(varName, localName, "prob_cap_", &prob_cap_, tracer)) return TCL_OK; //Shuang
+	if (delay_bind(varName, localName, "deadline", &deadline, tracer)) return TCL_OK; //Shuang
+	if (delay_bind(varName, localName, "early_terminated_", &early_terminated_, tracer)) return TCL_OK; //Shuang
         return TcpAgent::delay_bind_dispatch(varName, localName, tracer);
 }
 
@@ -297,6 +277,16 @@ FullTcpAgent::command(int argc, const ch
 			advance_bytes(atoi(argv[2]));
 			return (TCL_OK);
 		}
+		//Mohammad
+		if (strcmp(argv[1], "get-flow") == 0) {
+		        flow_remaining_ = atoi(argv[2]);
+		        return(TCL_OK);
+		}
+		//
+		if (strcmp(argv[1], "deadline_") == 0) {
+				deadline = atof(argv[2]);
+				return(TCL_OK);
+		}
 	}
 	if (argc == 4) {
 		if (strcmp(argv[1], "sendmsg") == 0) {
@@ -330,10 +320,11 @@ FullTcpAgent::command(int argc, const ch
 void
 FullTcpAgent::advanceby(int np)
 {
-	// XXX hack:
+
+
+// XXX hack:
 	//	because np is in packets and a data source
 	//	may pass a *huge* number as a way to tell us
-	//	to go forever, just look for the huge number
 	//	and if it's there, pre-divide it
 	if (np >= 0x10000000)
 		np /= maxseg_;
@@ -350,6 +341,10 @@ void
 FullTcpAgent::advance_bytes(int nb)
 {
 
+////Shuang: hardcode
+	cwnd_ = initial_window();
+//	//ssthresh_ = cwnd_;
+
 	//
 	// state-specific operations:
 	//	if CLOSED or LISTEN, reset and try a new active open/connect
@@ -357,21 +352,26 @@ FullTcpAgent::advance_bytes(int nb)
 	//	if SYN_SENT or SYN_RCVD, just queue
 	//	if above ESTABLISHED, we are closing, so don't allow
 	//
-
-	switch (state_) {
+	start_time = now();
+	early_terminated_ = 0;
+  	switch (state_) {
 
 	case TCPS_CLOSED:
 	case TCPS_LISTEN:
                 reset();
+				startseq_ = iss_;
                 curseq_ = iss_ + nb;
-                connect();              // initiate new connection
+				seq_bound_ = -1;
+		connect();              // initiate new connection
 		break;
 
 	case TCPS_ESTABLISHED:
 	case TCPS_SYN_SENT:
 	case TCPS_SYN_RECEIVED:
                 if (curseq_ < iss_) 
-                        curseq_ = iss_; 
+                        curseq_ = iss_;
+				startseq_ = curseq_;
+				seq_bound_ = -1;
                 curseq_ += nb;
 		break;
 
@@ -400,11 +400,15 @@ FullTcpAgent::advance_bytes(int nb)
 void
 FullTcpAgent::sendmsg(int nbytes, const char *flags)
 {
-	if (flags && strcmp(flags, "MSG_EOF") == 0) 
+	if (flags && strcmp(flags, "MSG_EOF") == 0){ 
 		close_on_empty_ = TRUE;	
-	if (flags && strcmp(flags, "DAT_EOF") == 0) 
-		signal_on_empty_ = TRUE;	
+printf("setting 2 closeonempty to true for fid= %d\n",fid_);
+        }
 
+	if (flags && strcmp(flags, "DAT_EOF") == 0){ 
+		signal_on_empty_ = TRUE;	
+		printf("setting signalonempty to true for fid= %d\n",fid_);
+	}
 	if (nbytes == -1) {
 		infinite_send_ = TRUE;
 		advance_bytes(0);
@@ -446,6 +450,8 @@ void
 FullTcpAgent::bufferempty()
 {
    	signal_on_empty_=FALSE;
+
+	//printf("flow fid= %d is done\n",fid_);
 	Tcl::instance().evalf("%s done_data", this->name());
 }
 
@@ -459,7 +465,6 @@ FullTcpAgent::usrclosed()
 {
 	curseq_ = maxseq_ - 1;	// now, no more data
 	infinite_send_ = FALSE;	// stop infinite send
-
 	switch (state_) {
 	case TCPS_CLOSED:
 	case TCPS_LISTEN:
@@ -610,9 +615,9 @@ FullTcpAgent::reset()
 	cancel_timers();	// cancel timers first
       	TcpAgent::reset();	// resets most variables
 	rq_.clear();		// clear reassembly queue
-	rtt_init();		// zero rtt, srtt, backoff
-
+	rtt_init();		// zero rtt, srtt, backoff       
 	last_ack_sent_ = -1;
+	flow_remaining_ = -1; // Mohammad
 	rcv_nxt_ = -1;
 	pipe_ = 0;
 	rtxbytes_ = 0;
@@ -635,7 +640,12 @@ FullTcpAgent::reset()
                 ecn_syn_next_ = 1;
         else
                 ecn_syn_next_ = 0;
-
+	//Shuang
+	prob_mode_ = false;
+	prob_count_ = 0;
+	last_sqtotal_ = 0;
+	deadline = 0;
+	early_terminated_ = 0;
 }
 
 /*
@@ -764,6 +774,7 @@ int
 FullTcpAgent::rcvseqinit(int seq, int dlen)
 {
 	return (seq + dlen + 1);
+//printf("newww3 fid= %d, rcv_nxt_= %d diff= %d, highest_ack= %d, last_ack_sent= %d diff= %d\n",fid_,(int)rcv_nxt_,((int)rcv_nxt_)-oldrcvnxt,(int)highest_ack_,last_ack_sent_,((int)last_ack_sent_)-oldlastacksent);
 }
 
 /*
@@ -821,6 +832,56 @@ FullTcpAgent::ack_action(Packet* p)
 	FullTcpAgent::pack_action(p);
 }
 
+int 
+FullTcpAgent::set_prio(int seq, int maxseq) {
+	int max = 100 * 1460;
+	int prio;
+	if (prio_scheme_ == 0) {
+		if ( seq - startseq_ > max)
+		    prio = max;
+		else
+			prio = seq - startseq_;
+	}
+	if (prio_scheme_ == 1)
+		prio =  maxseq - startseq_;
+	if (prio_scheme_ == 2)
+		prio =  maxseq - seq;
+	if (prio_scheme_ == 3)
+		prio = seq - startseq_;
+
+	if (prio_num_ == 0)
+		return prio;
+	else
+		return calPrio(prio);
+}
+
+int
+FullTcpAgent::calPrio(int prio) {
+	/**
+	 * : changed on 6/17/15
+	 */
+//	if (prio_num_ != 2 && prio_num_ != 4 && prio_num_ != 8) {
+//		fprintf(stderr, "wrong number or priority class %d\n", prio_num_);
+//		return 0;
+//	}
+//	for (int i = 1; i < prio_num_; i++)
+//		if (prio <= prio_cap_[i * 8 / prio_num_ - 1])
+//		{
+//			printf("***prio %d cap %d ans %d calc=%d\n", prio, prio_cap_[i*8/prio_num_ - 1], i - 1, i*8/prio_num_ - 1);
+//			return i - 1;
+//		}
+	for (int i =0; i<prio_num_; i++)
+	{
+//		printf("***i=%d cap %d\n",i,prio_cap_[i]);
+		if (prio <= prio_cap_[i])
+		{
+//			printf("***prio %d cap %d ans %d\n",prio,prio_cap_[i],i);
+			return i;
+		}
+	}
+//	printf("***prio %d cap %d ans %d\n", prio, prio_cap_[prio_num_ - 1], prio_num_ - 1);
+	return prio_num_ - 1;
+}
 
 /*
  * sendpacket: 
@@ -839,6 +900,7 @@ FullTcpAgent::sendpacket(int seqno, int
         if (!p) p = allocpkt();
         hdr_tcp *tcph = hdr_tcp::access(p);
 	hdr_flags *fh = hdr_flags::access(p);
+	hdr_ip* iph = hdr_ip::access(p);
 
 	/* build basic header w/options */
 
@@ -849,7 +911,10 @@ FullTcpAgent::sendpacket(int seqno, int
 	tcph->sa_length() = 0;    // may be increased by build_options()
         tcph->hlen() = tcpip_base_hdr_size_;
 	tcph->hlen() += build_options(tcph);
+	//Shuang: reduce header length
+	//tcph->hlen() = 1;
 
+	//iph->prio() = curseq_ - seqno + 10; 
 	/*
 	 * Explicit Congestion Notification (ECN) related:
 	 * Bits in header:
@@ -871,10 +936,16 @@ FullTcpAgent::sendpacket(int seqno, int
 		/* Set ect() to 0.  -M. Weigle 1/19/05 */
 		fh->ect() = 0;
 	}
+
+	// Mohammad: for DCTCP, ect should be set on all packets
+            if (ecnhat_)
+                        fh->ect() = ect_;
+	
 	if (ecn_ && ect_ && recent_ce_ ) { 
 		// This is needed here for the ACK in a SYN, SYN/ACK, ACK
 		// sequence.
-		pflags |= TH_ECE;
+		pflags |= TH_ECE;	      
+	        
 	}
         // fill in CWR and ECE bits which don't actually sit in
         // the tcp_flags but in hdr_flags
@@ -883,6 +954,8 @@ FullTcpAgent::sendpacket(int seqno, int
         } else {
                 fh->ecnecho() = 0;
         }
+
+
         if ( pflags & TH_CWR ) {
                 fh->cong_action() = 1;
         }
@@ -896,8 +969,11 @@ FullTcpAgent::sendpacket(int seqno, int
         hdr_cmn *ch = hdr_cmn::access(p);
         ch->size() = datalen + tcph->hlen();
 
-        if (datalen <= 0)
+        if (datalen <= 0) {
                 ++nackpack_;
+				//Shuang: artifically reduce ack size
+				//ch->size() = 1;
+		}
         else {
                 ++ndatapack_;
                 ndatabytes_ += datalen;
@@ -907,15 +983,59 @@ FullTcpAgent::sendpacket(int seqno, int
                 ++nrexmitpack_;
                 nrexmitbytes_ += datalen;
         }
-
 	last_ack_sent_ = ackno;
 
 //if (state_ != TCPS_ESTABLISHED) {
 //printf("%f(%s)[state:%s]: sending pkt ", now(), name(), statestr(state_));
 //prpkt(p);
 //}
-
+	if (deadline > 0)
+		iph->prio_type() = 1;
+	if (datalen > 0) {
+		//iph->prio_type() = 0;
+		//iph->prio() = set_prio(seqno, curseq_);
+		/* Shuang: prio dropping */
+		if (deadline == 0) {
+			iph->prio() = set_prio(seqno, curseq_);
+			iph->prio_type() = 0;
+		} else {
+			int tleft = deadline - int((now() - start_time) * 1e6);
+			iph->prio_type() = 1;
+			iph->prio() = deadline + int(start_time * 1e6);
+			if (tleft < 0 || byterm() * 8 / 1e4 > tleft) {
+				iph->prio_type() = 0;
+				iph->prio() = (1 << 30);
+			} else {
+//				iph->prio() = iph->prio() / 40 * 1000 + set_prio(seqno, curseq_) / 1460;
+			}
+		}
+		
+	        /* Mohammad: this is deprecated
+		 * it was for path-aware multipath
+		 * congestion control experiments */
+	        //Shuang: delete it
+			//iph->prio() = fid_;
+	
+		/* Mohammad: inform pacer (TBF) that
+		 * this connection received an EcnEcho.
+		 * this is a bit hacky, but necessary 
+		 * for now since the TBF class doesn't see the
+		 * ACKS. */
+		
+		if (informpacer) 
+		       iph->gotecnecho = 1;
+		else 
+		       iph->gotecnecho = 0;
+        
+		informpacer = 0; 
+		//abd
+	}
+	
 	send(p, 0);
+	if(seqno>=(curseq_-2))
+	{
+
+	}
 
 	return;
 }
@@ -960,9 +1080,12 @@ FullTcpAgent::foutput(int seqno, int rea
 	// Q: how can this happen?
 
 	if (maxseg_ == 0) 
-	   	maxseg_ = size_ - headersize();
-	else
-		size_ =  maxseg_ + headersize();
+	       maxseg_ = size_;// Mohammad: changed from size_  - headersize();
+	// Mohamad: commented the else condition 
+	// which is unnecessary and conflates with
+	// tcp.cc
+	//else
+	//	size_ =  maxseg_ + headersize();
 
 	int is_retransmit = (seqno < maxseq_);
 	int quiet = (highest_ack_ == maxseq_);
@@ -971,8 +1094,11 @@ FullTcpAgent::foutput(int seqno, int rea
 	int emptying_buffer = FALSE;
 	int buffered_bytes = (infinite_send_) ? TCP_MAXSEQ :
 				curseq_ - highest_ack_ + 1;
-
+//printf("buffered bytes= %d now= %lf fid= %d cwnd= %d\n", buffered_bytes,now(),fid_,(int)cwnd_);
 	int win = window() * maxseg_;	// window (in bytes)
+	if (prob_mode_ && win > 1)
+	  win = 1;
+
 	int off = seqno - highest_ack_;	// offset of seg in window
 	int datalen;
 	//int amtsent = 0;
@@ -990,11 +1116,30 @@ FullTcpAgent::foutput(int seqno, int rea
 		datalen = buffered_bytes - off;
 	else
 		datalen = min(buffered_bytes, win) - off;
-
-        if ((signal_on_empty_) && (!buffered_bytes) && (!syn))
+	
+//	if (fid_ == 13 || fid_ == 14) {
+//		int tmp = 0;
+//		if (prob_mode_)
+//			tmp = 1;
+//		int tmph = highest_ack_;
+//		printf("%.5lf: FLOW%d: win %d probe: %d buffered bytes %d off %d seqno %d, highestack %d, datalen %d\n", now(), fid_, win, tmp, buffered_bytes, off, seqno, tmph, datalen);
+//		fflush(stdout);
+//	}
+
+//	if (deadline != 0 && !syn) {
+//		double tleft = deadline/1e6 - (now() - start_time);
+//		if (tleft < 0) {
+//			printf("early termination now %.8lf start %.8lf deadline %d\n", now(), start_time, deadline);
+//			fflush(stdout);
+//			buffered_bytes = 0;
+//			datalen = 0;
+//		}
+//    }	
+	if ((signal_on_empty_) && (!buffered_bytes) && (!syn)) {
 	                bufferempty();
+	}
+
 
-	//
 	// in real TCP datalen (len) could be < 0 if there was window
 	// shrinkage, or if a FIN has been sent and neither ACKd nor
 	// retransmitted.  Only this 2nd case concerns us here...
@@ -1004,6 +1149,7 @@ FullTcpAgent::foutput(int seqno, int rea
 	} else if (datalen > maxseg_) {
 		datalen = maxseg_;
 	}
+       
 
 	//
 	// this is an option that causes us to slow-start if we've
@@ -1014,9 +1160,11 @@ FullTcpAgent::foutput(int seqno, int rea
 	if (slow_start_restart_ && quiet && datalen > 0) {
 		if (idle_restart()) {
 			slowdown(CLOSE_CWND_INIT);
-		}
+			}
 	}
 
+	//printf("%f %d %d\n", Scheduler::instance().clock(), (int) highest_ack_, (int) maxseq_);
+
 	//
 	// see if sending this packet will empty the send buffer
 	// a dataless SYN packet counts also
@@ -1064,10 +1212,15 @@ FullTcpAgent::foutput(int seqno, int rea
 		//	only happen for tiny windows)
 		if (datalen >= ((wnd_ * maxseg_) / 2.0))
 			goto send;
+		//Shuang
+		if (datalen == 1 && prob_mode_)
+			goto send;
 	}
 
-	if (need_send())
+	if (need_send(seqno)){
+//		if(fid_==2352) printf("before need_send fid= %d, rcv_nxt_= %d highest_ack= %d, last_ack_sent= %d\n",fid_,(int)rcv_nxt_,(int)highest_ack_,last_ack_sent_);
 		goto send;
+	}
 
 	/*
 	 * send now if a control packet or we owe peer an ACK
@@ -1088,10 +1241,11 @@ FullTcpAgent::foutput(int seqno, int rea
 send:
 
 	// is a syn or fin?
-
+	//printf("made it to send\n");
 	syn = (pflags & TH_SYN) ? 1 : 0;
+	
 	int fin = (pflags & TH_FIN) ? 1 : 0;
-
+	
         /* setup ECN syn and ECN SYN+ACK packet headers */
         if (ecn_ && syn && !(pflags & TH_ACK)){
                 pflags |= TH_ECE;
@@ -1155,6 +1309,13 @@ send:
          * Any pending ACK has now been sent.
          */      
 	flags_ &= ~(TF_ACKNOW|TF_DELACK);
+	
+	// Mohammad
+	delack_timer_.force_cancel();
+	/*
+	if (datalen == 0)
+	        printf("%f -- %s sent ACK for %d, canceled delack\n", this->name(), Scheduler::instance().clock(), rcv_nxt_);
+	*/
 
 	/*
 	 * if we have reacted to congestion recently, the
@@ -1178,6 +1339,8 @@ send:
 	//	and adjusted for SYNs and FINs which use up one number
 
 	int highest = seqno + reliable;
+	if (highest > ecnhat_maxseq) 
+		ecnhat_maxseq = highest;
 	if (highest > maxseq_) {
 		maxseq_ = highest;
 		//
@@ -1191,13 +1354,13 @@ send:
 		}
 	}
 
-	/*
-	 * Set retransmit timer if not currently set,
+	/* Set retransmit timer if not currently set,
 	 * and not doing an ack or a keep-alive probe.
 	 * Initial value for retransmit timer is smoothed
 	 * round-trip time + 2 * round-trip time variance.
 	 * Future values are rtt + 4 * rttvar.
 	 */
+
 	if (rtx_timer_.status() != TIMER_PENDING && reliable) {
 		set_rtx_timer();  // no timer pending, schedule one
 	}
@@ -1221,15 +1384,15 @@ void
 FullTcpAgent::send_much(int force, int reason, int maxburst)
 {
 	int npackets = 0;	// sent so far
-
-//if ((int(t_seqno_)) > 1)
-//printf("%f: send_much(f:%d, win:%d, pipectrl:%d, pipe:%d, t_seqno:%d, topwin:%d, maxseq_:%d\n",
-//now(), force, win, pipectrl_, pipe_, int(t_seqno_), topwin, int(maxseq_));
+	bool doit=true;
+	//if ((int(t_seqno_)) > 1)
+	//printf("%f: send_much(f:%d, win:%d, pipectrl:%d, pipe:%d, t_seqno:%d, topwin:%d, maxseq_:%d\n",
+	//now(), force, win, pipectrl_, pipe_, int(t_seqno_), topwin, int(maxseq_));
 
 	if (!force && (delsnd_timer_.status() == TIMER_PENDING))
 		return;
 
-	while (1) {
+	while (doit) {
 
 		/*
 		 * note that if output decides to not actually send
@@ -1239,6 +1402,8 @@ FullTcpAgent::send_much(int force, int r
 		 */
 		int amt;
 		int seq = nxt_tseq();
+		
+		
 		if (!force && !send_allowed(seq))
 			break;
 		// Q: does this need to be here too?
@@ -1247,16 +1412,23 @@ FullTcpAgent::send_much(int force, int r
 			delsnd_timer_.resched(Random::uniform(overhead_));
 			return;
 		}
-		if ((amt = foutput(seq, reason)) <= 0)
-			break;
-		if ((outflags() & TH_FIN))
-			--amt;	// don't count FINs
-		sent(seq, amt);
-		force = 0;
+		amt = foutput(seq, reason);
+		if (amt <= 0)
+		{
+		  //printf("made call to foutput: returned %d\n", amt);
+			doit=false;
+		}
+		else
+		{
+			if ((outflags() & TH_FIN))
+				--amt;	// don't count FINs
+			sent(seq, amt);
+			force = 0;
+			if ((outflags() & (TH_SYN|TH_FIN)) ||
+				(maxburst && ++npackets >= maxburst))
+				doit=false;
+		}
 
-		if ((outflags() & (TH_SYN|TH_FIN)) ||
-		    (maxburst && ++npackets >= maxburst))
-			break;
 	}
 	return;
 }
@@ -1269,11 +1441,18 @@ int
 FullTcpAgent::send_allowed(int seq)
 {
         int win = window() * maxseg_;
+		//Shuang: probe_mode
+		if (prob_mode_ && win > 1)
+			win = 1;
         int topwin = curseq_; // 1 seq number past the last byte we can send
 
         if ((topwin > highest_ack_ + win) || infinite_send_)
-                topwin = highest_ack_ + win; 
-
+                topwin = highest_ack_ + win;
+	
+//	if (seq >= topwin) {
+//		printf("%.5lf: fid %d send not allowed\n", now(), fid_);
+//		fflush(stdout);
+//	}
 	return (seq < topwin);
 }
 /*
@@ -1292,11 +1471,17 @@ FullTcpAgent::send_allowed(int seq)
 void
 FullTcpAgent::newack(Packet* pkt)
 {
+
+   	//Shuang: cancel prob_mode_ when receiving an ack
+    prob_mode_ = false;
+    prob_count_ = 0;
+	
 	hdr_tcp *tcph = hdr_tcp::access(pkt);
 
 	register int ackno = tcph->ackno();
 	int progress = (ackno > highest_ack_);
-
+	
+	//printf("NEWACK cur %d last %d ackno %d highest %d\n", cur_sqtotal_, last_sqtotal_,int(ackno), int(highest_ack_));
 	if (ackno == maxseq_) {
 		cancel_rtx_timer();	// all data ACKd
 	} else if (progress) {
@@ -1304,8 +1489,9 @@ FullTcpAgent::newack(Packet* pkt)
 	}
 
 	// advance the ack number if this is for new data
-	if (progress)
+	if (progress) {
 		highest_ack_ = ackno;
+	}
 
 	// if we have suffered a retransmit timeout, t_seqno_
 	// will have been reset to highest_ ack.  If the
@@ -1360,6 +1546,8 @@ FullTcpAgent::newack(Packet* pkt)
 	return;
 }
 
+
+
 /*
  * this is the simulated form of the header prediction
  * predicate.  While not really necessary for a simulation, it
@@ -1415,7 +1603,7 @@ FullTcpAgent::fast_retransmit(int seq)
 {
 	// we are now going to fast-retransmit and willtrace that event
 	trace_event("FAST_RETX");
-	
+	printf("%f: fid %d did a fast retransmit - dupacks = %d prio:%d state:%d\n", now(), fid_, (int)dupacks_, set_prio(startseq_,curseq_));
 	recover_ = maxseq_;	// recovery target
 	last_cwnd_action_ = CWND_ACTION_DUPACK;
 	return(foutput(seq, REASON_DUPACK));	// send one pkt
@@ -1436,15 +1624,17 @@ FullTcpAgent::fast_retransmit(int seq)
  */
 
 int
-FullTcpAgent::need_send()
+FullTcpAgent::need_send(int seqno)
 {
 	if (flags_ & TF_ACKNOW)
 		return TRUE;
 
 	int spa = (spa_thresh_ > 0 && ((rcv_nxt_ - irs_)  < spa_thresh_)) ?
 		1 : segs_per_ack_;
-		
-	return ((rcv_nxt_ - last_ack_sent_) >= (spa * maxseg_));
+	//Shuang
+		return ((rcv_nxt_ - last_ack_sent_) > 0);
+	//return ((rcv_nxt_ - last_ack_sent_) >= spa * maxseg_);
+
 }
 
 /*
@@ -1471,6 +1661,8 @@ FullTcpAgent::idle_restart()
 	}
 
 	return (tao > t_rtxcur_);  // verify this CHECKME
+	//return (tao > (int(t_srtt_) >> T_SRTT_BITS)*tcp_tick_); //Mohammad
+
 }
 
 /*
@@ -1506,6 +1698,10 @@ FullTcpAgent::set_initial_window()
 void
 FullTcpAgent::recv(Packet *pkt, Handler*)
 {
+	//Shuang: cancel probe mode
+		prob_mode_ = false;
+		prob_count_ = 0;
+
 	hdr_tcp *tcph = hdr_tcp::access(pkt);	// TCP header
 	hdr_cmn *th = hdr_cmn::access(pkt);	// common header (size, etc)
 	hdr_flags *fh = hdr_flags::access(pkt);	// flags (CWR, CE, bits)
@@ -1518,6 +1714,7 @@ FullTcpAgent::recv(Packet *pkt, Handler*
 	last_state_ = state_;
 
 	int datalen = th->size() - tcph->hlen(); // # payload bytes
+//printf("fid2= %d datalen= %d\n",fid_,datalen);
 	int ackno = tcph->ackno();		 // ack # from packet
 	int tiflags = tcph->flags() ; 		 // tcp flags from packet
 
@@ -1525,7 +1722,6 @@ FullTcpAgent::recv(Packet *pkt, Handler*
 //fprintf(stdout, "%f(%s)in state %s recv'd this packet: ", now(), name(), statestr(state_));
 //prpkt(pkt);
 //}
-
 	/* 
 	 * Acknowledge FIN from passive closer even in TCPS_CLOSED state
 	 * (since we lack TIME_WAIT state and RST packets,
@@ -1550,6 +1746,14 @@ FullTcpAgent::recv(Packet *pkt, Handler*
 		goto drop;
 	}
 
+	/*
+	 *  Shuang: if fid does not match, drop packets
+	 */
+	if (fid_ != hdr_ip::access(pkt)->fid_) {
+		//printf("extra!%d %d\n", fid_, hdr_ip::access(pkt)->fid_);
+		goto drop;
+	}
+
         /*
          * Process options if not in LISTEN state,
          * else do it below
@@ -1563,12 +1767,33 @@ FullTcpAgent::recv(Packet *pkt, Handler*
 	 * They are set to fire every 'interval_' secs, starting
 	 * at time t0 = (0.0 + k * interval_) for some k such
 	 * that t0 > now
+	 */ 
+	/* 
+	 *Mohammad: commented this out for more efficient 
+	 * delayed ack generation
 	 */
-	if (delack_interval_ > 0.0 &&
+	/*if (delack_interval_ > 0.0 &&
 	    (delack_timer_.status() != TIMER_PENDING)) {
 		int last = int(now() / delack_interval_);
 		delack_timer_.resched(delack_interval_ * (last + 1.0) - now());
-	}
+		}*/
+	
+
+	// Mohammad
+	if (ecnhat_) 
+		update_ecnhat_alpha(pkt);
+
+	/* Mohammad: check if we need to inform
+	 * pacer of ecnecho.
+	 */
+	if (!(tiflags & TH_SYN) && fh->ecnecho())
+	        informpacer = 1;
+
+	/*if (datalen > 0)
+	  printf("received data: datalen = %d seqno = %d, ackno = %d, ce = %d, ecn-echo = %d\n", datalen, tcph->seqno(), ackno, fh->ce(), fh->ecnecho());
+	else 
+	  printf("received ack : datalen = %d seqno = %d, ackno = %d, ce = %d, ecn-echo = %d\n", datalen, tcph->seqno(), ackno, fh->ce(), fh->ecnecho());
+	*/
 
 	/*
 	 * Try header prediction: in seq data or in seq pure ACK
@@ -1596,16 +1821,36 @@ FullTcpAgent::recv(Packet *pkt, Handler*
 		// cong_action bit
 		//
 
-	    	if (ecn_) {
+	    	if (ecn_) { 
+		  if (ecnhat_) { // Mohammad		       
 	    		if (fh->ce() && fh->ect()) {
 	    			// no CWR from peer yet... arrange to
 	    			// keep sending ECNECHO
+			        if (recent_ce_ == FALSE) {
+				     ce_transition_ = 1;
+				     recent_ce_ = TRUE;
+				} else {
+				     ce_transition_ = 0;
+				}
+	    		} else if (datalen > 0 && !fh->ce() && fh->ect()){
+			        if (recent_ce_ == TRUE) {
+				     ce_transition_ = 1;
+				     recent_ce_ = FALSE;
+				} else {
+				      ce_transition_ = 0;
+				}
+			}  
+		  } else {
+		           if (fh->ce() && fh->ect()) {
+	    			// no CWR from peer yet... arrange to
+	    			// keep sending ECNECHO
 	    			recent_ce_ = TRUE;
-	    		} else if (fh->cwr()) {
-	    			// got CWR response from peer.. stop
+			   } else if (fh->cwr()) { 
+		                // got CWR response from peer.. stop
 	    			// sending ECNECHO bits
-	    			recent_ce_ = FALSE;
-	    		}
+			        recent_ce_ = FALSE;
+		           }		    
+		  }
 	    	}
 
 		// Header predication basically looks to see
@@ -1638,16 +1883,47 @@ FullTcpAgent::recv(Packet *pkt, Handler*
 			//	this routine scans all tcpcb's looking for
 			//	DELACK segments and when it finds them
 			//	changes DELACK to ACKNOW and calls tcp_output()
-			rcv_nxt_ += datalen;
+			
+		        /* Mohammad: For DCTCP state machine */
+		        if (ecnhat_ && ce_transition_ && ((rcv_nxt_ - last_ack_sent_) > 0)) {
+			  // Must send an immediate ACK with with previous ECN state 
+			  // before transitioning to new state
+			  flags_ |= TF_ACKNOW;
+			  recent_ce_ = !recent_ce_;
+			  // printf("should be acking %d with recent_ce_ = %d\n", rcv_nxt_, recent_ce_);
+			  send_much(1, REASON_NORMAL, maxburst_);
+			  recent_ce_ = !recent_ce_;			  
+			} 
+
+		        rcv_nxt_ += datalen;
+
 			flags_ |= TF_DELACK;
+			// Mohammad
+			delack_timer_.resched(delack_interval_);
+		
+			// printf("%f: receving data %d, rescheduling delayed ack\n", Scheduler::instance().clock(), rcv_nxt_);
+
 			recvBytes(datalen); // notify application of "delivery"
+			
+			//printf("flow_remaining before dec = %d\n" , flow_remaining_);
+			if (flow_remaining_ > 0)
+			        flow_remaining_ -= datalen; // Mohammad
+		
+			if (flow_remaining_ == 0) {			       
+			        flags_ |= TF_ACKNOW;
+				flow_remaining_ = -1;
+			}
+			//printf("flow_remaining after dec = %d\n" , flow_remaining_);
+			
 			//
 			// special code here to simulate the operation
 			// of a receiver who always consumes data,
 			// resulting in a call to tcp_output
 			Packet::free(pkt);
-			if (need_send())
+			if (need_send()){
 				send_much(1, REASON_NORMAL, maxburst_);
+//				if(fid_==2352) printf("before2 need_send fid= %d, rcv_nxt_= %d highest_ack= %d, last_ack_sent= %d\n",fid_,(int)rcv_nxt_,(int)highest_ack_,last_ack_sent_);
+			}
 			return;
 		}
 	} /* header prediction */
@@ -1707,7 +1983,6 @@ FullTcpAgent::recv(Packet *pkt, Handler*
 		t_seqno_ = iss_; /* tcp_sendseqinit() macro in real tcp */
 		rcv_nxt_ = rcvseqinit(irs_, datalen);
 		flags_ |= TF_ACKNOW;
-
 		// check for a ECN-SYN with ECE|CWR
 		if (ecn_ && fh->ecnecho() && fh->cong_action()) {
 			ect_ = TRUE;
@@ -1816,6 +2091,8 @@ if (t_rtt_) {
 			 */
 			if (datalen > 0) {
 				flags_ |= TF_DELACK;	// data there: wait
+				// Mohammad
+				delack_timer_.resched(delack_interval_);	       
 			} else {
 				flags_ |= TF_ACKNOW;	// ACK peer's SYN
 			}
@@ -2064,6 +2341,7 @@ trimthenstep6:
                 // Do not move to TCPS_ESTB state or update TCP variables.
 			cancel_rtx_timer();
 			ecn_syn_next_ = 0;
+			DBGMARK(DBGTCP,2,"TCPS_SYN_RECEIVED\n");
 			foutput(iss_, REASON_NORMAL);
 			wnd_init_option_ = 1;
                         wnd_init_ = 1;
@@ -2122,21 +2400,49 @@ trimthenstep6:
 
 		if (fh->ecnecho() && (!ecn_ || !ect_)) {
 			fprintf(stderr,
-			    "%f: FullTcp(%s): warning, recvd ecnecho but I am not ECN capable!\n",
-				now(), name());
+			    "%f: FullTcp(%s): warning, recvd ecnecho but I am not ECN capable! %d\n",
+				now(), name(), ecn_);
 		}
 
-                //
-                // generate a stream of ecnecho bits until we see a true
-                // cong_action bit
-                // 
-                if (ecn_) {
-                        if (fh->ce() && fh->ect())
-                                recent_ce_ = TRUE;
-                        else if (fh->cwr()) 
-                                recent_ce_ = FALSE;
-                }
+		//
+		// generate a stream of ecnecho bits until we see a true
+		// cong_action bit
+		//
+
+	    	if (ecn_) { 
+		  if (ecnhat_) { // Mohammad		       
+		    	if (fh->ce() && fh->ect()) {
+	    			// no CWR from peer yet... arrange to
+	    			// keep sending ECNECHO
+			        if (recent_ce_ == FALSE) {
+				     ce_transition_ = 1;
+				     recent_ce_ = TRUE;
+				} else {
+				     ce_transition_ = 0;
+				}
+      	    		} else if (datalen > 0 && !fh->ce() && fh->ect()){
+			        if (recent_ce_ == TRUE) {
+				     ce_transition_ = 1;
+				     recent_ce_ = FALSE;
+				} else {
+				      ce_transition_ = 0;
+				}
+			}
+		   
+		  } else {
+		           if (fh->ce() && fh->ect()) {
+	    			// no CWR from peer yet... arrange to
+	    			// keep sending ECNECHO
+	    			recent_ce_ = TRUE;
+			   } else if (fh->cwr()) { 
+		                // got CWR response from peer.. stop
+	    			// sending ECNECHO bits
+			        recent_ce_ = FALSE;
+		           }		    
+		  }
+	    	}
 
+ 
 		//
 		// If ESTABLISHED or starting to close, process SACKS
 		//
@@ -2156,11 +2462,22 @@ trimthenstep6:
 		// look for dup ACKs (dup ack numbers, no data)
 		//
 		// do fast retransmit/recovery if at/past thresh
+//if (ackno <= highest_ack_) printf("dupi= %d\n",(int)dupacks_);
+//else printf("in fully\n");
+		//Shuang:
+//		if (ackno <= highest_ack_ && cur_sqtotal_ <= last_sqtotal_) {
 		if (ackno <= highest_ack_) {
 			// a pure ACK which doesn't advance highest_ack_
+//printf("dupi= %d\n",dupacks_);
 			if (datalen == 0 && (!dupseg_fix_ || !dupseg)) {
 
-                                /*
+			        //Mohammad: check for dynamic dupack mode.
+			         if (dynamic_dupack_ > 0.0) {
+				        tcprexmtthresh_ = int(dynamic_dupack_ * window());
+					if (tcprexmtthresh_ < 3)
+					       tcprexmtthresh_ = 3;
+				 }
+				  /*
                                  * If we have outstanding data
                                  * this is a completely
                                  * duplicate ack,
@@ -2187,6 +2504,7 @@ trimthenstep6:
 				} else if (++dupacks_ == tcprexmtthresh_) {
 					// ACK at highest_ack_ AND meets threshold
 					//trace_event("FAST_RECOVERY");
+					//Shuang: dupack_action
 					dupack_action(); // maybe fast rexmt
 					goto drop;
 
@@ -2263,14 +2581,22 @@ process_ACK:
 		 * but not if it is a syn packet
 		 */
 		if (fh->ecnecho() && !(tiflags&TH_SYN) )
-		if (fh->ecnecho()) {
+		  if (fh->ecnecho()) {
 			// Note from Sally: In one-way TCP,
 			// ecn() is called before newack()...
 			ecn(highest_ack_);  // updated by newack(), above
 			// "set_rtx_timer();" from T. Kelly.
 			if (cwnd_ < 1)
 			 	set_rtx_timer();
-		}
+		  }
+
+		// Mohammad
+		/*if (Random::uniform(1) < ecnhat_alpha_ && !(tiflags&TH_SYN) ) {
+			ecn(highest_ack_);
+			if (cwnd_ < 1)
+			 	set_rtx_timer();
+				}*/
+
 		// CHECKME: handling of rtx timer
 		if (ackno == maxseq_) {
 			needoutput = TRUE;
@@ -2297,11 +2623,19 @@ process_ACK:
 		if ((!delay_growth_ || (rcv_nxt_ > 0)) &&
 		    last_state_ == TCPS_ESTABLISHED) {
 			if (!partial || open_cwnd_on_pack_) {
-                           if (!ect_ || !hdr_flags::access(pkt)->ecnecho())
-				opencwnd();
+				if (!ect_ || !hdr_flags::access(pkt)->ecnecho() || ecn_burst_)
+				  opencwnd();
                         }
 		}
 
+		// Mohammad
+		if (ect_) {
+			if (!ecn_burst_ && hdr_flags::access(pkt)->ecnecho())
+				ecn_burst_ = TRUE;
+			else if (ecn_burst_ && ! hdr_flags::access(pkt)->ecnecho())
+				ecn_burst_ = FALSE;
+		}
+
 		if ((state_ >= TCPS_FIN_WAIT_1) && (ackno == maxseq_)) {
 			ourfinisacked = TRUE;
 		}
@@ -2395,14 +2729,42 @@ step6:
 			// don't really have a process anyhow, just
 			// accept the data here as-is (i.e. don't
 			// require being in ESTABLISHED state)
-			flags_ |= TF_DELACK;
+			
+		        /* Mohammad: For DCTCP state machine */
+		        if (ecnhat_ && ce_transition_ && ((rcv_nxt_ - last_ack_sent_) > 0)) {
+			  // Must send an immediate ACK with with previous ECN state 
+			  // before transitioning to new state
+			  flags_ |= TF_ACKNOW;
+			  recent_ce_ = !recent_ce_;
+			  //printf("should be acking %d with recent_ce_ = %d\n", rcv_nxt_, recent_ce_);
+			  send_much(1, REASON_NORMAL, maxburst_);
+			  recent_ce_ = !recent_ce_;			  
+                        }
+		        
+		        flags_ |= TF_DELACK;
+			// Mohammad
+			delack_timer_.resched(delack_interval_);			
 			rcv_nxt_ += datalen;
+
+			// printf("%f: receving data %d, rescheduling delayed ack\n", Scheduler::instance().clock(), rcv_nxt_);
+
 			tiflags = tcph->flags() & TH_FIN;
 
 			// give to "application" here
 			// in "real" TCP, this is sbappend() + sorwakeup()
-			if (datalen)
+			if (datalen) {
 				recvBytes(datalen); // notify app. of "delivery"
+
+				//printf("flow_remaining before dec = %d\n" , flow_remaining_);
+				if (flow_remaining_ > 0)
+				      flow_remaining_ -= datalen; // Mohammad
+				if (flow_remaining_ == 0) {		       
+				      flags_ |= TF_ACKNOW;
+				      flow_remaining_ = -1;
+				}
+				//printf("flow_remaining after dec = %d\n" , flow_remaining_);			
+       			}
+
 			needoutput = need_send();
 		} else {
 			// see the "tcp_reass" function:
@@ -2412,13 +2774,29 @@ step6:
 			// segments or hole-fills.  Also,
 			// send an ACK (or SACK) to the other side right now.
 			// Note that we may have just a FIN here (datalen = 0)
-			int rcv_nxt_old_ = rcv_nxt_; // notify app. if changes
+		  
+		        /* Mohammad: the DCTCP receiver conveys the ECN-CE 
+			   received on each out-of-order data packet */
+
+		        int rcv_nxt_old_ = rcv_nxt_; // notify app. if changes
 			tiflags = reass(pkt);
 			if (rcv_nxt_ > rcv_nxt_old_) {
 				// if rcv_nxt_ has advanced, must have
 				// been a hole fill.  In this case, there
-				// is something to give to application
-				recvBytes(rcv_nxt_ - rcv_nxt_old_);
+				// is something to give to application		       
+			        recvBytes(rcv_nxt_ - rcv_nxt_old_);
+
+				//printf("flow_remaining before dec = %d\n" , flow_remaining_);
+				if (flow_remaining_ > 0) 
+				       flow_remaining_ -= datalen; // Mohammad
+							
+				if (flow_remaining_ == 0) {		       
+				       flags_ |= TF_ACKNOW;
+				       flow_remaining_ = -1;
+				}
+			
+				//printf("flow_remaining after dec = %d\n" , flow_remaining_);
+			
 			}
 			flags_ |= TF_ACKNOW;
 
@@ -2562,15 +2940,13 @@ FullTcpAgent::dupack_action()
 		cancel_rtx_timer();
 		rtt_active_ = FALSE;
 		(void)fast_retransmit(highest_ack_);
-                return; 
+		return; 
         }      
     
         if (bug_fix_) {
-                /*
-                 * The line below, for "bug_fix_" true, avoids
-                 * problems with multiple fast retransmits in one
-                 * window of data.
-                 */      
+                 // The line below, for "bug_fix_" true, avoids
+                 // problems with multiple fast retransmits in one
+                 // window of data.
                 return;  
         }
     
@@ -2584,7 +2960,8 @@ full_reno_action:
 	// so don't scale by maxseg_
 	// as real TCP does
 	cwnd_ = double(ssthresh_) + double(dupacks_);
-        return;
+       return;
+  
 }
 
 void
@@ -2592,6 +2969,8 @@ FullTcpAgent::timeout_action()
 {
 	recover_ = maxseq_;
 
+//	cwnd_ = 0.5 * cwnd_; 
+//Shuang: comment all below
 	if (cwnd_ < 1.0) {
                 if (debug_) {
 	            fprintf(stderr, "%f: FullTcpAgent(%s):: resetting cwnd from %f to 1\n",
@@ -2606,8 +2985,16 @@ FullTcpAgent::timeout_action()
 		slowdown(CLOSE_SSTHRESH_HALF|CLOSE_CWND_RESTART);
 		last_cwnd_action_ = CWND_ACTION_TIMEOUT;
 	}
+
+	//cwnd_ = initial_window();
+//	ssthresh_ = cwnd_;
+
 	reset_rtx_timer(1);
 	t_seqno_ = (highest_ack_ < 0) ? iss_ : int(highest_ack_);
+	ecnhat_recalc_seq = t_seqno_;
+	ecnhat_maxseq = ecnhat_recalc_seq;
+	
+	//printf("%f, fid %d took timeout, cwnd_ = %f\n", now(), fid_, (double)cwnd_);
 	fastrecov_ = FALSE;
 	dupacks_ = 0;
 }
@@ -2662,7 +3049,8 @@ FullTcpAgent::timeout(int tno)
                         flags_ |= TF_ACKNOW;
                         send_much(1, REASON_NORMAL, 0);
                 }
-                delack_timer_.resched(delack_interval_);
+		// Mohammad
+                //delack_timer_.resched(delack_interval_);
 		break;
 	default:
 		fprintf(stderr, "%f: FullTcpAgent(%s) Unknown Timeout type %d\n",
@@ -2706,6 +3094,11 @@ FullTcpAgent::process_sack(hdr_tcp*)
 	return;
 }
 
+int
+FullTcpAgent::byterm() {
+	return curseq_ - int(highest_ack_) - window() * maxseg_;
+}
+
 
 /*
  * ****** Tahoe ******
@@ -2828,6 +3221,51 @@ NewRenoFullTcpAgent::ack_action(Packet*
  * "pipe" style control until recovery is complete
  */
 
+int
+SackFullTcpAgent::set_prio(int seq, int maxseq) {
+	int max = 100 * 1460;
+	int prio;
+	if (prio_scheme_ == 0) {
+		if ( seq - startseq_ > max)
+			prio =  max;
+		else
+			prio =  seq - startseq_;
+	}
+	if (prio_scheme_ == 1)
+		prio =  maxseq - startseq_;
+	if (prio_scheme_ == 2) {
+			//printf("%d %d\n", maxseq, int(highest_ack_));
+			//printf("%d %d %d %d\n", maxseq, int(highest_ack_), sq_.total(), maxseq - int(highest_ack_) - sq_.total() + 10);
+			//fflush(stdout);
+			if (maxseq - int(highest_ack_) - sq_.total() + 10 < 0)
+				prio = 0;
+			else
+				prio = maxseq - int(highest_ack_) - sq_.total() + 10;
+			//return maxseq - seq;
+		}
+	if (prio_scheme_ == 3) {
+		//printf("3??\n");
+		prio =  seq - startseq_;
+	}
+	if (prio_scheme_ == 4) { //in batch
+		if (int(highest_ack_) >= seq_bound_) {
+			seq_bound_ = maxseq_;
+			if (maxseq - int(highest_ack_) - sq_.total() + 10 < 0)
+				last_prio_ = 0;
+			else
+				last_prio_ = maxseq - int(highest_ack_) - sq_.total() + 10;
+		}
+		//printf("prio scheme 4: highest ack %d maxseq_ %d seq %d prio %d\n", int(highest_ack_), int(maxseq_), seq, last_prio_);
+		prio = last_prio_;
+	}
+
+	if (prio_num_ == 0)
+		return prio;
+	else
+		return calPrio(prio);
+}
+
+
 void
 SackFullTcpAgent::reset()
 {
@@ -2874,6 +3312,9 @@ SackFullTcpAgent::dupack_action()
 		 * packet.   -M. Weigle  6/19/02
 		 */
 		last_cwnd_action_ = CWND_ACTION_DUPACK;
+		/* Mohammad: cut window by half when we have 3 dup ack */
+		if (ecnhat_) 
+			slowdown(CLOSE_SSTHRESH_HALF|CLOSE_CWND_HALF); 
 		cancel_rtx_timer();
 		rtt_active_ = FALSE;
 		int amt = fast_retransmit(highest_ack_);
@@ -2933,7 +3374,10 @@ SackFullTcpAgent::ack_action(Packet* p)
 {
 //printf("%f: EXITING fast recovery, recover:%d\n",
 //now(), recover_);
+
+	//Shuang: not set pipectrol_ = false
 	fastrecov_ = pipectrl_ = FALSE;
+	fastrecov_ = FALSE;
         if (!sq_.empty() && sack_min_ < highest_ack_) {
                 sack_min_ = highest_ack_;
                 sq_.cleartonxt();
@@ -2964,6 +3408,8 @@ SackFullTcpAgent::build_options(hdr_tcp*
         } else {
                 tcph->sa_length() = 0;
         }
+	//Shuang: reduce ack size
+	//return 0;
 	return (total);
 }
 
@@ -2972,6 +3418,23 @@ SackFullTcpAgent::timeout_action()
 {
 	FullTcpAgent::timeout_action();
 
+	/*recover_ = maxseq_;
+
+	int progress = curseq_ - int(highest_ack_) - sq_.total();
+	cwnd_ = min((last_timeout_progress_ - progress) / 1460 + 1, maxcwnd_);
+	ssthresh_ = cwnd_;
+	printf("%d %d", progress/1460, last_timeout_progress_ / 1460);
+	last_timeout_progress_ = progress;
+
+	reset_rtx_timer(1);
+	t_seqno_ = (highest_ack_ < 0) ? iss_ : int(highest_ack_);
+	ecnhat_recalc_seq = t_seqno_;
+	ecnhat_maxseq = ecnhat_recalc_seq;
+	
+	printf("%f, fid %d took timeout, cwnd_ = %f\n", now(), fid_, (double)cwnd_);
+	fastrecov_ = FALSE;
+	dupacks_ = 0;*/
+
 	//
 	// original SACK spec says the sender is
 	// supposed to clear out its knowledge of what
@@ -2981,7 +3444,7 @@ SackFullTcpAgent::timeout_action()
 	// enabled.
 	//
 
-	if (clear_on_timeout_) {
+	if (clear_on_timeout_ ) {
 		sq_.clear();
 		sack_min_ = highest_ack_;
 	}
@@ -2997,6 +3460,7 @@ SackFullTcpAgent::process_sack(hdr_tcp*
 	// in the pkt.  Insert each block range
 	// into the scoreboard
 	//
+	last_sqtotal_ = sq_.total();
 
 	if (max_sack_blocks_ <= 0) {
 		fprintf(stderr,
@@ -3009,7 +3473,7 @@ SackFullTcpAgent::process_sack(hdr_tcp*
 	for (i = 0; i < slen; ++i) {
 		/* Added check for FIN   -M. Weigle 5/21/02 */
 		if ((tcph->flags() & TH_FIN == 0) && 
-		    tcph->sa_left(i) >= tcph->sa_right(i)) {
+		    (tcph->sa_left(i) >= tcph->sa_right(i))) {
 			fprintf(stderr,
 			    "%f: FullTcpAgent(%s) warning: received illegal SACK block [%d,%d]\n",
 				now(), name(), tcph->sa_left(i), tcph->sa_right(i));
@@ -3017,22 +3481,28 @@ SackFullTcpAgent::process_sack(hdr_tcp*
 		}
 		sq_.add(tcph->sa_left(i), tcph->sa_right(i), 0);  
 	}
-
+	
+	cur_sqtotal_ = sq_.total();
 	return;
 }
 
 int
 SackFullTcpAgent::send_allowed(int seq)
 {
+	//Shuang: always pipe control and simple pipe function
+	//pipectrl_ = true;
+	//pipe_ = maxseq_ - highest_ack_ - sq_.total();
+
 	// not in pipe control, so use regular control
 	if (!pipectrl_)
 		return (FullTcpAgent::send_allowed(seq));
 
 	// don't overshoot receiver's advertised window
 	int topawin = highest_ack_ + int(wnd_) * maxseg_;
+//	printf("%f: PIPECTRL: SEND(%d) AWIN:%d, pipe:%d, cwnd:%d highest_ack:%d sqtotal:%d\n",
+	//now(), seq, topawin, pipe_, int(cwnd_), int(highest_ack_), sq_.total());
+
 	if (seq >= topawin) {
-//printf("%f: SEND(%d) NOT ALLOWED DUE TO AWIN:%d, pipe:%d, cwnd:%d\n",
-//now(), seq, topawin, pipe_, int(cwnd_));
 		return FALSE;
 	}
 
@@ -3104,6 +3574,10 @@ SackFullTcpAgent::nxt_tseq()
 		} else if (fcnt <= 0)
 			break;
 		else {
+		//Shuang; probe
+			if (prob_cap_ != 0) {
+				seq ++;
+			} else
 			seq += maxseg_;
 		}
 	}
@@ -3112,3 +3586,967 @@ SackFullTcpAgent::nxt_tseq()
 //now(), int(t_seqno_));
 	return (t_seqno_);
 }
+
+int
+SackFullTcpAgent::byterm() {
+	return curseq_ - int(highest_ack_) - sq_.total() - window() * maxseg_;
+}
+void
+
+MinTcpAgent::timeout_action() {
+//Shuang: prob count when cwnd=1
+	if (prob_cap_ != 0) {
+		prob_count_ ++;
+		if (prob_count_ == prob_cap_) {
+			prob_mode_ = true;
+		}
+		//Shuang: h_seqno_?
+		h_seqno_ = highest_ack_;
+	}
+
+	
+	SackFullTcpAgent::timeout_action();
+}
+
+double
+MinTcpAgent::rtt_timeout() {
+	return minrto_;
+}
+
+//void
+//MinTcpAgent::advance_bytes(int nb)
+//	SackFullTcpAgent::advance_bytes();
+//}
+
+void
+DDTcpAgent::slowdown(int how) {
+
+	double decrease;  /* added for highspeed - sylvia */
+	double win, halfwin, decreasewin;
+	int slowstart = 0;
+	++ncwndcuts_;
+	if (!(how & TCP_IDLE) && !(how & NO_OUTSTANDING_DATA)){
+		++ncwndcuts1_; 
+	}
+
+	//Shuang: deadline-aware
+	double penalty = ecnhat_alpha_;
+	if (deadline != 0) {
+		double tleft = deadline/1e6 - (now() - start_time);
+
+		//if (tleft < 0 && now() < 3) {
+		//	cwnd_ = 1;
+		//	printf("early termination now %.8lf start %.8lf deadline %d\n", now(), start_time, deadline);
+		//	fflush(stdout);
+   		//	if (signal_on_empty_);
+		//		bufferempty();
+	    //		return;
+		//} else 
+		if (tleft < 0) {
+			tleft = 1e10;	
+		}
+		double rtt = int(t_srtt_ >> T_SRTT_BITS) * tcp_tick_;
+		double Tc = byterm() / (0.75 * cwnd_ * maxseg_) * rtt;
+		double d = Tc/tleft;
+		if (d > 2) d = 2;
+		if (d < 0.5) d = 0.5;
+		if (d >= 0)
+			penalty = pow(penalty, d);
+  		//printf("deadline left %.6lf d-factor %f Tc %f start %f rm %d cwnd %f\n", tleft, Tc/tleft, Tc, start_time, byterm(), double(cwnd_));
+		//fflush(stdout);
+	} else if (penalty > 0) {
+		//non-deadline->TCP
+		penalty = 1;
+	}
+
+	//ecnhat_alpha_ = 0.07;
+	// we are in slowstart for sure if cwnd < ssthresh
+	if (cwnd_ < ssthresh_) 
+		slowstart = 1;
+        if (precision_reduce_) {
+		halfwin = windowd() / 2;
+                if (wnd_option_ == 6) {         
+                        /* binomial controls */
+                        decreasewin = windowd() - (1.0-decrease_num_)*pow(windowd(),l_parameter_);
+                } else if (wnd_option_ == 8 && (cwnd_ > low_window_)) { 
+                        /* experimental highspeed TCP */
+			decrease = decrease_param();
+			//if (decrease < 0.1) 
+			//	decrease = 0.1;
+			decrease_num_ = decrease;
+                        decreasewin = windowd() - (decrease * windowd());
+                } else {
+	 		decreasewin = decrease_num_ * windowd();
+		}
+		win = windowd();
+		//printf("decrease param = %f window = %f decwin = %f\n", decrease_num_, win, decreasewin);
+	} else  {
+		int temp;
+		temp = (int)(window() / 2);
+		halfwin = (double) temp;
+                if (wnd_option_ == 6) {
+                        /* binomial controls */
+                        temp = (int)(window() - (1.0-decrease_num_)*pow(window(),l_parameter_));
+                } else if ((wnd_option_ == 8) && (cwnd_ > low_window_)) { 
+                        /* experimental highspeed TCP */
+			decrease = decrease_param();
+			//if (decrease < 0.1)
+                        //       decrease = 0.1;		
+			decrease_num_ = decrease;
+                        temp = (int)(windowd() - (decrease * windowd()));
+                } else {
+ 			temp = (int)(decrease_num_ * window());
+		}
+		decreasewin = (double) temp;
+		win = (double) window();
+	}
+	if (how & CLOSE_SSTHRESH_HALF)
+		// For the first decrease, decrease by half
+		// even for non-standard values of decrease_num_.
+		if (first_decrease_ == 1 || slowstart ||
+			last_cwnd_action_ == CWND_ACTION_TIMEOUT) {
+			// Do we really want halfwin instead of decreasewin
+		// after a timeout?
+			ssthresh_ = (int) halfwin;
+		} else {
+			ssthresh_ = (int) decreasewin;
+		}
+	else if (how & CLOSE_SSTHRESH_ECNHAT) 
+		ssthresh_ = (int) ((1 - penalty/2.0) * windowd());
+	//ssthresh_ = (int) (windowd() - sqrt(2*windowd())/2.0);		
+        else if (how & THREE_QUARTER_SSTHRESH)
+		if (ssthresh_ < 3*cwnd_/4)
+			ssthresh_  = (int)(3*cwnd_/4);
+	if (how & CLOSE_CWND_HALF)
+		// For the first decrease, decrease by half
+		// even for non-standard values of decrease_num_.
+		if (first_decrease_ == 1 || slowstart || decrease_num_ == 0.5) {
+			cwnd_ = halfwin;
+		} else cwnd_ = decreasewin;
+        else if (how & CLOSE_CWND_ECNHAT) {
+		cwnd_ = (1 - penalty/2.0) * windowd();
+		if (cwnd_ < 1)
+			cwnd_ = 1;
+		}
+	//cwnd_ = windowd() - sqrt(2*windowd())/2.0;      
+	else if (how & CWND_HALF_WITH_MIN) {
+		// We have not thought about how non-standard TCPs, with
+		// non-standard values of decrease_num_, should respond
+		// after quiescent periods.
+                cwnd_ = decreasewin;
+                if (cwnd_ < 1)
+                        cwnd_ = 1;
+	}
+	else if (how & CLOSE_CWND_RESTART) 
+		cwnd_ = int(wnd_restart_);
+	else if (how & CLOSE_CWND_INIT) 	  
+	        cwnd_ = int(wnd_init_);
+	else if (how & CLOSE_CWND_ONE)
+		cwnd_ = 1;
+	else if (how & CLOSE_CWND_HALF_WAY) {
+		// cwnd_ = win - (win - W_used)/2 ;
+		cwnd_ = W_used + decrease_num_ * (win - W_used);
+                if (cwnd_ < 1)
+                        cwnd_ = 1;
+	}
+	if (ssthresh_ < 2)
+		ssthresh_ = 2;
+	if (cwnd_ < 1)
+		cwnd_ = 1; // Added by Mohammad
+	if (how & (CLOSE_CWND_HALF|CLOSE_CWND_RESTART|CLOSE_CWND_INIT|CLOSE_CWND_ONE|CLOSE_CWND_ECNHAT))
+		cong_action_ = TRUE;
+
+	fcnt_ = count_ = 0;
+	if (first_decrease_ == 1)
+		first_decrease_ = 0;
+	// for event tracing slow start
+	if (cwnd_ == 1 || slowstart) 
+		// Not sure if this is best way to capture slow_start
+		// This is probably tracing a superset of slowdowns of
+		// which all may not be slow_start's --Padma, 07/'01.
+		trace_event("SLOW_START");
+}
+
+int
+DDTcpAgent::byterm() {
+	return curseq_ - int(highest_ack_) - sq_.total();
+}
+
+int
+DDTcpAgent::foutput(int seqno, int reason) {
+	if (deadline != 0) {
+// 		double tleft = double(deadline)/1e6 - (now() - start_time) - byterm()*8/1e10;
+		double tleft = deadline/1e6 - (now() - start_time) - (curseq_ - int(maxseq_)) * 8/1e10;
+   		if (tleft < 0 && signal_on_empty_) {
+			early_terminated_ = 1;
+			bufferempty();
+			printf("early termination V2 now %.8lf start %.8lf deadline %d byterm %d tleft %.8f\n", now(), start_time, deadline, curseq_ - int(maxseq_), tleft);
+			fflush(stdout);
+			return 0;
+		} else if (tleft < 0) {
+			return 0;
+		}
+		//printf("test foutput\n");
+	}
+	return SackFullTcpAgent::foutput(seqno, reason);
+}
+
+int
+DDTcpAgent::need_send() {
+	if (deadline != 0) {
+ 		double tleft1 = deadline/1e6 - (now() - start_time);
+		if (tleft1 < 0)
+			return 0;
+		//printf("test need send\n");
+	}
+	return SackFullTcpAgent::need_send();
+}
+
+
+/**
+ * :
+ */
+
+void SolTCPAgent::pfctimeout()
+{
+	send_much(1, REASON_NORMAL, maxburst_);
+}
+
+void AgentPFCTimer::expire(Event *e)
+{
+	a_->pfctimeout();
+}
+///////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
+
+void SolTCPAgent::sendpacket(int seqno, int ackno, int pflags, int datalen, int reason, Packet *p)
+{
+
+    if (!p) p = allocpkt();
+    hdr_tcp *tcph = hdr_tcp::access(p);
+	hdr_flags *fh = hdr_flags::access(p);
+	hdr_ip* iph = hdr_ip::access(p);
+
+	/* build basic header w/options */
+
+	tcph->seqno() = seqno;
+	tcph->ackno() = ackno;
+	tcph->flags() = pflags;
+	tcph->reason() |= reason; // make tcph->reason look like ns1 pkt->flags?
+	tcph->sa_length() = 0;    // may be increased by build_options()
+	tcph->hlen() = tcpip_base_hdr_size_;
+	tcph->hlen() += build_options(tcph);
+	//Shuang: reduce header length
+	//tcph->hlen() = 1;
+
+	//iph->prio() = curseq_ - seqno + 10;
+	/*
+	 * Explicit Congestion Notification (ECN) related:
+	 * Bits in header:
+	 * 	ECT (EC Capable Transport),
+	 * 	ECNECHO (ECHO of ECN Notification generated at router),
+	 * 	CWR (Congestion Window Reduced from RFC 2481)
+	 * States in TCP:
+	 *	ecn_: I am supposed to do ECN if my peer does
+	 *	ect_: I am doing ECN (ecn_ should be T and peer does ECN)
+	 */
+
+	if (datalen > 0 && ecn_ )
+	{
+			// set ect on data packets
+		fh->ect() = ect_;	// on after mutual agreement on ECT
+	}
+	else if (ecn_ && ecn_syn_ && ecn_syn_next_ && (pflags & TH_SYN) && (pflags & TH_ACK))
+	{
+				// set ect on syn/ack packet, if syn packet was negotiating ECT
+				fh->ect() = ect_;
+	}
+	else
+	{
+		/* Set ect() to 0.  -M. Weigle 1/19/05 */
+		fh->ect() = 0;
+	}
+
+	// Mohammad: for DCTCP, ect should be set on all packets
+	if (ecnhat_)
+		fh->ect() = ect_;
+
+	if (ecn_ && ect_ && recent_ce_ )
+	{
+		// This is needed here for the ACK in a SYN, SYN/ACK, ACK
+		// sequence.
+		pflags |= TH_ECE;
+
+	}
+	// fill in CWR and ECE bits which don't actually sit in
+	// the tcp_flags but in hdr_flags
+	if ( pflags & TH_ECE) {
+			fh->ecnecho() = 1;
+	}
+	else
+	{
+			fh->ecnecho() = 0;
+	}
+
+
+	if ( pflags & TH_CWR )
+	{
+			fh->cong_action() = 1;
+	}
+	else
+	{
+		/* Set cong_action() to 0  -M. Weigle 1/19/05 */
+		fh->cong_action() = 0;
+	}
+
+	/* actual size is data length plus header length */
+
+	hdr_cmn *ch = hdr_cmn::access(p);
+	ch->size() = datalen + tcph->hlen();
+
+	if (datalen <= 0)
+	{
+		++nackpack_;
+		//Shuang: artifically reduce ack size
+		//ch->size() = 1;
+	}
+	else
+	{
+		++ndatapack_;
+		ndatabytes_ += datalen;
+		last_send_time_ = now();	// time of last data
+	}
+	if (reason == REASON_TIMEOUT || reason == REASON_DUPACK || reason == REASON_SACK)
+	{
+		++nrexmitpack_;
+		nrexmitbytes_ += datalen;
+	}
+	last_ack_sent_ = ackno;
+
+
+	/**
+	 * : Changing priority Based for flows with deadline.
+	 */
+	if (datalen > 0)
+	{
+		//iph->prio_type() = 0;
+		//iph->prio() = set_prio(seqno, curseq_);
+		/* Shuang: prio dropping */
+/*
+		if (deadline == 0)
+		{
+*/
+
+/*
+		}
+		else
+		{
+			int tleft = deadline - int((now() - start_time) * 1e6);
+			iph->prio_type() = 1;
+			iph->prio() = deadline + int(start_time * 1e6);
+			if (tleft < 0 || byterm() * 8 / 1e4 > tleft)
+			{
+				iph->prio_type() = 0;
+				iph->prio() = (1 << 30);
+			}
+			else
+			{
+	//				iph->prio() = iph->prio() / 40 * 1000 + set_prio(seqno, curseq_) / 1460;
+			}
+		}
+*/
+
+		/* Mohammad: this is deprecated
+		 * it was for path-aware multipath
+		 * congestion control experiments */
+			//Shuang: delete it
+			//iph->prio() = fid_;
+
+		/* Mohammad: inform pacer (TBF) that
+		 * this connection received an EcnEcho.
+		 * this is a bit hacky, but necessary
+		 * for now since the TBF class doesn't see the
+		 * ACKS. */
+
+		if (informpacer)
+			   iph->gotecnecho = 1;
+		else
+			   iph->gotecnecho = 0;
+
+		informpacer = 0;
+		//abd
+		if(iph->prio())
+		{
+			DBGPRINT(0,4,"id:%d cwnd_:%f, ssthresh_:%f\n",fid_,double(cwnd_),double(ssthresh_));
+			//DBGPRINT(0,0,"now:%f pkt:%p\n",now(),p);
+		}
+	}
+
+	/**
+	 * :Set Priority
+	 */
+	iph->prio() = set_prio(seqno, curseq_);
+	iph->prio_type() = 0;
+
+	if(bPathSelect)
+	{
+		iph->path_enable() = true;
+		iph->path() = nPath;
+	}
+	else
+	{
+		iph->path_enable() = false;
+		iph->path() = 0xFFFFFFFF;
+	}
+
+	/**
+	 * : If Initial State: circumvent the queues! ==> Priority =0;
+	 */
+	if(state_==TCPS_SYN_SENT && iph->prio()>0)
+	{
+		iph->prio()=0;
+		iph->path_enable() = false;
+		iph->path() = 0xFFFFFFFF;
+		DBGMARK(0,4,"@%f TCP fid:%d real state:%d priority:%d seqno:%d iss:%d\n",now(),fid_,state_,set_prio(seqno, curseq_),seqno,iss_);
+	}
+	else if (state_==TCPS_SYN_SENT)
+	{
+		DBGMARK(0,4,"@%f state_==TCPS_SYN_SENT !! fid:%d real state:%d priority:%d \n",now(),fid_,state_,set_prio(seqno, curseq_));
+	}
+
+	send(p, 0);
+
+	return;
+
+}
+
+//int SolTCPAgent::delay_bind_dispatch(const char *varName, const char *localName, TclObject *tracer)
+//{
+//    if (delay_bind(varName, localName, "NI", &m_nBW, tracer)) return TCL_OK;
+//    return SackFullTcpAgent::delay_bind_dispatch(varName, localName, tracer);
+//}
+//int SolTCPAgent::byterm()
+//{
+//	return curseq_ - int(highest_ack_) - sq_.total();
+//}
+
+int SolTCPAgent::need_send(int seqno)
+{
+//	if (deadline != 0) {
+//
+//		double tleft1 = deadline/1e6 - (now() - start_time);
+//		if (tleft1 < 0)
+//			return 0;
+//
+//		double tRequired = (curseq_ - seqno) * 8/(m_nBW*1e9);
+//		//You can not meet your deadline, so do not send!
+//		if(tleft1<tRequired)
+//		{
+//			printf("need_send():can not meet deadline  tleft1: %.8lf deadline %lf byterm %d tRequired: %.8f\n", tleft1, deadline, curseq_ - seqno, tRequired);
+//			fflush(stdout);
+//			return 0;
+//		}
+//	}
+	return SackFullTcpAgent::need_send();
+
+}
+
+int SolTCPAgent::delay_bind_dispatch(const char *varName, const char *localName, TclObject *tracer)
+{
+	if (delay_bind(varName, localName, "NI", &m_nBW, tracer)) return TCL_OK; //Shuang
+	return SackFullTcpAgent::delay_bind_dispatch(varName, localName, tracer);
+}
+
+void SolTCPAgent::delay_bind_init_all()
+{
+    delay_bind_init_one("NI");
+    SackFullTcpAgent::delay_bind_init_all();
+}
+
+int SolTCPAgent::command(int argc, const char*const* argv)
+{
+//	DBGMARK(DBGTCP,2,"***** argc: %d\n",argc);
+	if (argc == 3) {
+		//
+		if (strcmp(argv[1], "NI") == 0) {
+				m_nBW = atoi(argv[2]);
+				return(TCL_OK);
+		}
+		if (strcmp(argv[1], "advance-bytes") == 0) {
+			advance_bytes(atoi(argv[2]));
+			return (TCL_OK);
+		}
+	}
+	return (FullTcpAgent::command(argc, argv));
+}
+
+
+int CtrTCPAgent::GetState(Packet* p)
+{
+	DBGMARK(DBGPFC,4,"@ %s: Checking PFC sts...\n",this->name());
+	return target_->CheckState(p);
+}
+
+int CtrTCPAgent::foutput(int seqno, int reason)
+{
+//	if (deadline != 0) {
+//// 		double tleft = double(deadline)/1e6 - (now() - start_time) - byterm()*8/1e10;
+////		double tleft = deadline/1e6 - (now() - start_time) - (curseq_ - int(maxseq_)) * 8/1e10;
+//		//We should send with NI rate (Using all NI rate). Therefore, we could assume that NI = Cwnd/Rtt ,(Cwnd=BDP)
+//		//Remaining_Time = Remaining_Bytes*8/NI
+//		double dd = deadline/1e6;
+//		double remaining_time = (curseq_ - seqno) * 8/(m_nBW*1e9);
+//		double tleft = dd - (now() - start_time) - remaining_time;
+////		double tleft = deadline/1e6 - (now() - start_time) - (curseq_ - int(maxseq_)) * 8/(m_nBW*1e9);
+//		if (tleft < 0 && signal_on_empty_ /*&& remaining_time>0*/) {
+//			early_terminated_ = 1;
+//			bufferempty();
+//			printf(">>>>>>>>>><<<<<<<<\n early termination V2 now %.8lf start %.8lf deadline %f dd %.8lf rmn %.8lf byterm %d tleft %.8f, m_nBW=%d\n>>>>>>>>>><<<<<<<<\n", now(), start_time, deadline, dd, remaining_time, curseq_ - seqno,  tleft,m_nBW);
+//			fflush(stdout);
+//			return 0;
+//		} else if (tleft < 0) {
+//			return 0;
+//		}
+//		//printf("test foutput\n");
+//	}
+//	if(state_==TCPS_LISTEN || state_==TCPS_CLOSED)
+//	{
+//		return SolTCPAgent::foutput(seqno,reason);
+//	}
+//	DBGMARK(DBGTCP,2,"fid:%d ePrt_State=%d seqno=%d time=%lf \n",fid_,ePrt_State,seqno,now());
+
+	//Check pfc first:
+	/**
+	 * we need a pkt for pfc check:
+	 */
+//	DBGPRINT(0,0,"now:%f m_bPFC:%d ePrt_State=%d set_prio(startseq_,curseq_):%d \n",now(),m_bPFC,ePrt_State,set_prio(startseq_,curseq_));
+
+	if(m_bPFC)
+	{
+		if(ePrt_State!=eInit && ePrt_State!=eRQ && set_prio(startseq_,curseq_))
+		{
+			Packet *p = allocpkt();
+			hdr_tcp *tcph = hdr_tcp::access(p);
+			hdr_flags *fh = hdr_flags::access(p);
+			hdr_ip* iph = hdr_ip::access(p);
+			iph->prio() = set_prio(seqno, curseq_);
+			iph->prio_type() = 0;
+			if(bPathSelect)
+			{
+				iph->path_enable() = true;
+				iph->path() = nPath;
+			}
+			else
+			{
+				iph->path_enable() = false;
+				iph->path() = 0xFFFFFFFF;
+			}
+
+			int pfc_sts = GetState(p);
+			DBGMARK(DBGPFC,4,"Agent: GetState: %d",pfc_sts);
+//			DBGPRINT(0,0,"now:%f GetState:%d\n",now(),pfc_sts);
+			if(pfc_sts==PFC_PAUSED_STS)
+			{
+				if(bpfc_state!=PFC_PAUSED_STS)DBGMARK(DBGPFC,4,"now:%f ************* seq:%d Paused: %d fid:%d,",now(),seqno,pfc_sts,fid_);
+				bpfc_state=PFC_PAUSED_STS;
+				double pasueTime = 0.000001;//1us
+				m_pfcTimer.resched(pasueTime);
+				//cancel_timers();
+				set_rtx_timer();
+				Packet::free(p);
+				return 0;
+			}
+			Packet::free(p);
+		}
+	}
+	bpfc_state=PFC_NORMAL_STS;
+	int IsFin = curseq_ - seqno;
+	double cwn=cwnd_;
+	switch (ePrt_State)
+	{
+		case eRQ:
+			DBGPRINT(DBGTCP,2,"STATE: eRQ\n");
+		case eSTOP:
+			DBGPRINT(DBGTCP,2,"STATE: STOP, fid:%d cwn:%lf\n",fid_,cwn);
+//			printf("\nSTOP STATE.\n");
+//			fflush(stdout);
+			return 0;
+		case eInit:
+		case eGO:
+//			printf("{%d} STATE.\n",ePrt_State);
+//			fflush(stdout);
+			/**
+			 * : Tell the controller. (remove me)
+			 */
+//			if((curseq_-seqno)<2)
+//			{
+//				//Tell the Controller that we have finished it!
+//				if(set_prio(startseq_,curseq_))
+//				{
+//					Tcl::instance().evalf("%s remove_me", this->name());
+//				}
+//			}
+			return SolTCPAgent::foutput(seqno,reason);
+		default:
+			printf("INVALID PROTOCOL STATE flowid:%d! {%d}\n",fid_,ePrt_State);
+			fflush(stdout);
+			return 0;
+	}
+}
+
+int CtrTCPAgent::command(int argc, const char*const* argv)
+{
+	DBGMARK(DBGTCP,5,"argv[1]:%s argc: %d\n",argv[1],argc);
+	if (argc == 3) {
+		if (strcmp(argv[1], "signal-go") == 0)
+		{
+				DBGMARK(DBGTCP,2,"fid:%d ePrt_State=%d path:%08x\n",fid_,ePrt_State,atoi(argv[2]));
+				RcvSignalGo(atoi(argv[2]));
+				return(TCL_OK);
+		}
+		if(strcmp(argv[1], "cost") == 0)
+		{
+			SetCost(atoi(argv[2]));
+			return(TCL_OK);
+		}
+	}
+	else if (argc==2)
+	{
+		if (strcmp(argv[1], "get-state") == 0)
+		{
+			Tcl::instance().resultf("%d",ePrt_State);
+			return(TCL_OK);
+		}
+		else if (strcmp(argv[1], "signal-stop") == 0)
+		{
+				RcvSignalStop();
+				return(TCL_OK);
+		}
+		else if (strcmp(argv[1], "get-rem") == 0)
+		{
+				GetRemainSize();
+				return(TCL_OK);
+		}
+	}
+	return (SolTCPAgent::command(argc, argv));
+}
+
+void CtrTCPAgent::advance_bytes(int nb)
+{
+
+	//Assuming that wnd_init_ is set properly to BDP by user!
+	cwnd_ = initial_window();
+//	DBGMARK(DBGTCP,2,"fid:%d ePrt_State=%d\n",fid_,ePrt_State);
+
+	// state-specific operations:
+	//	if CLOSED or LISTEN, reset and try a new active open/connect
+	//	if ESTABLISHED, queue and try to send more
+	//	if SYN_SENT or SYN_RCVD, just queue
+	//	if above ESTABLISHED, we are closing, so don't allow
+	//
+	start_time = now();
+	early_terminated_ = 0;
+  	switch (state_) {
+
+	case TCPS_CLOSED:
+	case TCPS_LISTEN:
+                reset();
+				startseq_ = iss_;
+                curseq_ = iss_ + nb;
+				seq_bound_ = -1;
+//		connect();              // initiate new connection
+		break;
+
+	case TCPS_ESTABLISHED:
+	case TCPS_SYN_SENT:
+	case TCPS_SYN_RECEIVED:
+                if (curseq_ < iss_)
+                        curseq_ = iss_;
+				startseq_ = curseq_;
+				seq_bound_ = -1;
+                curseq_ += nb;
+		break;
+
+	default:
+            if (debug_)
+	            fprintf(stderr, "%f: FullTcpAgent::advance(%s): cannot advance while in state %s\n",
+		         now(), name(), statestr(state_));
+
+	}
+  	FirstTimeRun();
+}
+
+void CtrTCPAgent::SendRequest()
+{
+	nStartTime=now();
+//	DBGMARK(DBGTCP,1,"fid:%d nStartTime:%f !\n",fid_,nStartTime);
+//	Tcl::instance().evalf("%s admission_request", this->name());
+	SendRQTimer.resched(dCost); //Cost=100us;
+}
+void CtrTCPAgent::SendRequestNow()
+{
+	//Send Request to Controller: Invoking TCP_Pair's Controller's API
+	DBGMARK(DBGCOST,1,"fid:%d nStartTime:%f !\n",fid_,nStartTime);
+	Tcl::instance().evalf("%s admission_request", this->name());
+}
+void  CtrTCPAgent::SetCost(double cost)
+{
+	dCost=cost;
+}
+
+void CtrTCPAgent::GetRemainSize()
+{
+	//Send Request to Controller: Invoking TCP_Pair's Controller's API
+	DBGMARK(DBGTCP,3,"Flowid(%d) state:%d\n",fid_,ePrt_State);
+	Tcl::instance().evalf("%s set_remaining %d", this->name(),(curseq_ - int(highest_ack_) - sq_.total() + 10));
+}
+
+void CtrTCPAgent::RcvSignalGo(int nPath)
+{
+	//Assuming that wnd_init_ is set properly to BDP by user!
+	cwnd_ = wnd_init_;
+	double cwn=cwnd_;
+	DBGMARK(DBGTCP,2,"Going>> fid:%d TCP_State:%d ePrt_State=%d cwnd_:%lf nPath:%08x\n",fid_,state_,ePrt_State,cwn,nPath);
+	this->nPath = nPath;
+	bPathSelect=true;
+
+	if(ePrt_State==eSTOP)
+	{
+		if(nNumPrempt>0)
+		{
+			nPremptWaitTime+=now()-nPremptLastTime;
+			DBGMARK(DBGTCP,1,"fid:%d now():%f - nPremptLastTime:%f - nPremptWaitTime:%f !\n",fid_,now(),nPremptLastTime,nPremptWaitTime);
+		}
+		else
+		{
+			nStartWaitTime=now()-nStartTime;
+			DBGMARK(DBGTCP,1,"fid:%d nStartWaitTime:%f !\n",fid_,nStartWaitTime);
+		}
+	}
+	else if (ePrt_State==eRQ)
+	{
+		nStartWaitTime=now()-nStartTime;
+		DBGMARK(DBGTCP,1,"fid:%d nStartWaitTime:%f !\n",fid_,nStartWaitTime);
+	}
+	else
+	{
+		DBGMARK(DBGTCP,1,"fid:%d Previous state is not STOP or even RQ! Check it!\n",fid_);
+	}
+
+  	switch (state_) {
+
+	case TCPS_CLOSED:
+	case TCPS_LISTEN:
+		//from RQ to Init
+		ePrt_State=eInit;
+		connect();              // initiate new connection
+		break;
+
+	case TCPS_ESTABLISHED:
+//	case TCPS_SYN_SENT:
+//	case TCPS_SYN_RECEIVED:
+		ePrt_State = eGO	;
+		send_much(1, REASON_NORMAL, maxburst_);
+		break;
+	}
+
+	/**
+	 * Following is Commented: bc here we are sure that connection is already established!
+	 */
+//	if (state_ == TCPS_ESTABLISHED)
+//	{
+	/**
+	 *: Debugged- We should Force it to start here; Deltimer might not let us to send! :D
+	 */
+
+//	}
+}
+
+void CtrTCPAgent::RcvSignalStop()
+{
+	if(ePrt_State==eGO || (nNumPrempt>0 && ePrt_State!=eSTOP))
+	{
+		nPremptLastTime=now();
+		nNumPrempt++;
+		DBGMARK(DBGTCP,1,"fid:%d now:%f nNumPrempt:%d nPremptWaitTime:%f !\n",fid_,now(),nNumPrempt,nPremptWaitTime);
+	}
+	ePrt_State = eSTOP;
+	//cancel_timers();
+//	rtx_timer_.force_cancel();
+//		burstsnd_timer_.force_cancel();
+}
+
+void CtrTCPAgent::Stop()
+{
+
+}
+
+void CtrTCPAgent::FirstTimeRun()
+{
+
+	//Check whether we need to send a request
+	ePrt_State=eInit;
+
+	if(set_prio(startseq_,curseq_)/*&&(state_ == TCPS_ESTABLISHED)*/)
+	{
+		//Send request:
+		ePrt_State=eRQ;
+		bPathSelect=true;
+		DBGMARK(DBGTCP,2,"fid:%d ePrt_State=%d\n",fid_,ePrt_State);
+		/**
+		 *	Go to MinTCP setup!
+		 */
+//		clear_on_timeout_=0;
+//		sack_rtx_threshmode_=2;
+//		prob_cap_=5;
+		SendRequest();
+	}
+	else
+	{
+		ePrt_State=eInit;
+		bPathSelect=false;
+	  	switch (state_) {
+
+		case TCPS_CLOSED:
+		case TCPS_LISTEN:
+			connect();              // initiate new connection
+			break;
+		case TCPS_ESTABLISHED:
+		case TCPS_SYN_SENT:
+		case TCPS_SYN_RECEIVED:
+			send_much(1, REASON_NORMAL, maxburst_);
+			break;
+		}
+	}
+//	DBGMARK(DBGTCP,2,"fid:%d ePrt_State=%d\n",fid_,ePrt_State);
+}
+
+void CtrTCPAgent::ResetState()
+{
+	ePrt_State=eInit;
+}
+
+void CtrTCPAgent::bufferempty()
+{
+	//Tell the Controller that we have finished it!
+	if(set_prio(startseq_,curseq_))
+	{
+		ResetState();
+		Tcl::instance().evalf("%s remove_me", this->name());
+	}
+
+	FullTcpAgent::bufferempty();
+}
+
+int CtrTCPAgent::fast_retransmit(int seq)
+{
+	DBGPRINT(DBGTCP,1,"fid %d fast retransmit - dupacks = %d prio:%d state:%d\n",fid_, (int)dupacks_, set_prio(startseq_,curseq_),ePrt_State);
+	return SackFullTcpAgent::fast_retransmit(seq);
+}
+void CtrTCPAgent::timeout_action()
+{
+	if(set_prio(startseq_,curseq_))
+	{
+//		if (prob_cap_ != 0) {
+//			prob_count_ ++;
+//			if (prob_count_ == prob_cap_) {
+//				prob_mode_ = true;
+//			}
+//			//Shuang: h_seqno_?
+//			h_seqno_ = highest_ack_;
+//		}
+		if(m_bPFC)DBGPRINT(0,0,"@%f: TIME out, Big Flows! state:%d ctr_state:%d fid:%d nextseq:%d iss:%d max:%d startsq:%d\n",now(),state_,ePrt_State,fid_,h_seqno_,iss_,int(curseq_),startseq_);
+	}
+	SackFullTcpAgent::timeout_action();
+}
+
+double CtrTCPAgent::rtt_timeout()
+{
+	if(set_prio(startseq_,curseq_))
+	{
+		return minrto_;
+	}
+	else
+	{
+		return TcpAgent::rtt_timeout();
+	}
+}
+
+void CtrTCPAgent::timeout(int tno)
+{
+	if (tno == TCP_TIMER_RTX)
+	{
+		switch (ePrt_State)
+		{
+			case eSTOP:
+				set_rtx_timer();
+				return;
+			default:
+				break;
+		}
+		if(bpfc_state==PFC_PAUSED_STS)
+		{
+			set_rtx_timer();
+			return;
+		}
+	}
+//	if(set_prio(startseq_,curseq_))
+//	{
+//		DBGPRINT(0,0,"********** timeout(%d)\n",tno);
+//	}
+
+	FullTcpAgent::timeout(tno);
+}
+
+void CtrTCPAgent::slowdown(int how)
+{
+	if(set_prio(startseq_,curseq_))
+	{
+//		DBGPRINT(0,0,"fid_:%d cwnd_:%f Initcwnd_:%f ssthresh_:%f\n",fid_,double(cwnd_),wnd_init_,double(ssthresh_));
+		cwnd_ = wnd_init_; //Do nothing! Just set it to infinity again! :)
+		ssthresh_ =10*cwnd_;
+	}
+	else
+	{
+		SackFullTcpAgent::slowdown(how);
+	}
+}
+
+void CtrTCPAgent::connect()
+{
+	newstate(TCPS_SYN_SENT);	// sending a SYN now
+	int amt=foutput(iss_, REASON_NORMAL);
+	if(amt==0)
+	{
+		DBGPRINT(0,0,"@%f: connect() state:%d ctr_state:%d fid:%d nextseq:%d iss:%d max:%d startsq:%d\n",now(),state_,ePrt_State,fid_,h_seqno_,iss_,int(curseq_),startseq_);
+	}
+	sent(iss_, amt);
+	ePrt_State=eGO;
+	return;
+}
+
+void CostTimer::expire(Event*)
+{
+	a_->SendRequestNow();
+}
+
+
+static class SolTCPClass : public TclClass {
+public:
+	SolTCPClass() : TclClass("Agent/TCP/FullTcp/Sack/SolTCP") {}
+	TclObject* create(int, const char*const*) {
+		// ns-default sets reno_fastrecov_ to false
+		// ns-default sets open_cwnd_on_pack_ to false
+		return (new SolTCPAgent());
+	}
+} class_soltcp_full;
+
+static class CtrTCPClass : public TclClass {
+public:
+	CtrTCPClass() : TclClass("Agent/TCP/FullTcp/Sack/SolTCP/Ctr") {}
+	TclObject* create(int, const char*const*) {
+		// ns-default sets reno_fastrecov_ to false
+		// ns-default sets open_cwnd_on_pack_ to false
+		return (new CtrTCPAgent());
+	}
+} class_ctrtcp_full;
+
diff -rpuN ns-allinone-2.34.base/ns-2.34/tcp/tcp-full.h ns-allinone-2.34.hyline/ns-2.34/tcp/tcp-full.h
--- ns-allinone-2.34.base/ns-2.34/tcp/tcp-full.h	2009-06-14 13:35:44.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/tcp/tcp-full.h	2016-05-30 11:37:44.000000000 -0400
@@ -1,38 +1,3 @@
-/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
-/*
- * Copyright (c) 1997, 2001 The Regents of the University of California.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *  This product includes software developed by the Network Research
- *  Group at Lawrence Berkeley National Laboratory.
- * 4. Neither the name of the University nor of the Laboratory may be used
- *    to endorse or promote products derived from this software without
- *    specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * @(#) $Header: /cvsroot/nsnam/ns-2/tcp/tcp-full.h,v 1.60 2008/10/14 17:42:52 sallyfloyd Exp $ (LBL)
- */
 
 #ifndef ns_tcp_full_h
 #define ns_tcp_full_h
@@ -116,18 +81,21 @@ protected:
 class FullTcpAgent : public TcpAgent {
 public:
 	FullTcpAgent() :
+		prio_scheme_(0), prio_num_(0), startseq_(0), last_prio_(0), seq_bound_(0),
 		closed_(0), pipe_(-1), rtxbytes_(0), fastrecov_(FALSE),
         	last_send_time_(-1.0), infinite_send_(FALSE), irs_(-1),
         	delack_timer_(this), flags_(0),
         	state_(TCPS_CLOSED), recent_ce_(FALSE),
-        	last_state_(TCPS_CLOSED), rq_(rcv_nxt_), last_ack_sent_(-1) { }
+		  last_state_(TCPS_CLOSED), rq_(rcv_nxt_), last_ack_sent_(-1),
+		  informpacer(0),m_bPFC(0) { }
+		// Mohammad: added informpacer
 
 	~FullTcpAgent() { cancel_timers(); rq_.clear(); }
 	virtual void recv(Packet *pkt, Handler*);
 	virtual void timeout(int tno); 	// tcp_timers() in real code
 	virtual void close() { usrclosed(); }
 	void advanceby(int);	// over-rides tcp base version
-	void advance_bytes(int);	// unique to full-tcp
+	virtual void advance_bytes(int);	// unique to full-tcp
         virtual void sendmsg(int nbytes, const char *flags = 0);
         virtual int& size() { return maxseg_; } //FullTcp uses maxseg_ for size_
 	virtual int command(int argc, const char*const* argv);
@@ -135,6 +103,25 @@ public:
 protected:
 	virtual void delay_bind_init_all();
 	virtual int delay_bind_dispatch(const char *varName, const char *localName, TclObject *tracer);
+	/* Shuang: priority dropping */
+	virtual int set_prio(int seq, int maxseq);
+	virtual int calPrio(int prio);
+	virtual int byterm();
+	int prio_scheme_;
+	int prio_num_; //number of priorities; 0: unlimited
+	int prio_cap_[7]; 
+	int startseq_;
+	int last_prio_;
+	int seq_bound_;
+	int prob_cap_;  //change to prob mode after #prob_cap_ timeout
+	int prob_count_; //current #timeouts
+	bool prob_mode_;
+	int last_sqtotal_;
+	int cur_sqtotal_;
+	double deadline; // time remain in us at the beginning
+	double start_time; //start time
+	int early_terminated_; //early terminated
+	
 	int closed_;
 	int ts_option_size_;	// header bytes in a ts option
 	int pipe_;		// estimate of pipe occupancy (for Sack)
@@ -148,6 +135,29 @@ protected:
 	int deflate_on_pack_;	// deflate on partial acks (reno:yes)
 	int data_on_syn_;   // send data on initial SYN?
 	double last_send_time_;	// time of last send
+  
+
+	/* Mohammad: state-variable for robust
+	   FCT measurement. 
+	*/
+	int flow_remaining_; /* Number of bytes yet to be received from 
+			       the current flow (at the receiver). This is 
+			       set by TCL when starting a flow. Receiver will
+			       set immediate ACKs when nothing remains to
+			       notify sender of flow completion. */
+       
+	/* Mohammad: state-variable to inform 
+	 * pacer (TBF) of receiving ecnecho for the flow
+	 */
+	int informpacer;
+	//abd
+
+	// Mohammad: if non-zero, set dupack threshold to max(3, dynamic_dupack_ * cwnd)_
+	double dynamic_dupack_;
+  
+	//: pfc
+	int m_bPFC;
+
 	int close_on_empty_;	// close conn when buffer empty
 	int signal_on_empty_;	// signal when buffer is empty
 	int reno_fastrecov_;	// do reno-style fast recovery?
@@ -174,11 +184,11 @@ protected:
 	int rcvseqinit(int, int); // how to set rcv_nxt_
 	int predict_ok(Packet*); // predicate for recv-side header prediction
 	int idle_restart();	// should I restart after idle?
-	int fast_retransmit(int);  // do a fast-retransmit on specified seg
+	virtual int fast_retransmit(int);  // do a fast-retransmit on specified seg
 	inline double now() { return Scheduler::instance().clock(); }
 	virtual void newstate(int ns);
 
-	void bufferempty();   		// called when sender buffer is empty
+	virtual void bufferempty();   		// called when sender buffer is empty
 
 	void finish();
 	void reset_rtx_timer(int);  	// adjust the rtx timer
@@ -212,11 +222,11 @@ protected:
 	}
 
 	virtual void sendpacket(int seq, int ack, int flags, int dlen, int why, Packet *p=0);
-	void connect();     		// do active open
+	virtual void connect();     		// do active open
 	void listen();      		// do passive open
 	void usrclosed();   		// user requested a close
-	int need_send();    		// send ACK/win-update now?
-	int foutput(int seqno, int reason = 0); // output 1 packet
+	virtual int need_send(int seqno=0);    		// send ACK/win-update now?
+	virtual int foutput(int seqno, int reason = 0); // output 1 packet
 	void newack(Packet* pkt);	// process an ACK
 	int pack(Packet* pkt);		// is this a partial ack?
 	void dooptions(Packet*);	// process option(s)
@@ -225,7 +235,8 @@ protected:
 	void prpkt(Packet*);		// print packet (debugging helper)
 	char *flagstr(int);		// print header flags as symbols
 	char *statestr(int);		// print states as symbols
-
+	
+	
 	/*
 	* the following are part of a tcpcb in "real" RFC793 TCP
 	*/
@@ -233,13 +244,18 @@ protected:
 	int flags_;     /* controls next output() call */
 	int state_;     /* enumerated type: FSM state */
 	int recent_ce_;	/* last ce bit we saw */
+	int ce_transition_; /* Mohammad: was there a transition in 
+			       recent_ce by last ACK. for DCTCP receiver 
+			       state machine. */
 	int last_state_; /* FSM state at last pkt recv */
 	int rcv_nxt_;       /* next sequence number expected */
+	
 	ReassemblyQueue rq_;    /* TCP reassembly queue */
 	/*
 	* the following are part of a tcpcb in "real" RFC1323 TCP
 	*/
 	int last_ack_sent_; /* ackno field from last segment we sent */
+	
 	double recent_;		// ts on SYN written by peer
 	double recent_age_;	// my time when recent_ was set
 
@@ -272,7 +288,6 @@ public:
 		sq_(sack_min_), sack_min_(-1), h_seqno_(-1) { }
 	~SackFullTcpAgent() { rq_.clear(); }
 protected:
-
 	virtual void delay_bind_init_all();
 	virtual int delay_bind_dispatch(const char *varName, const char *localName, TclObject *tracer);
 
@@ -281,6 +296,7 @@ protected:
 	virtual void dupack_action();
 	virtual void process_sack(hdr_tcp*);
 	virtual void timeout_action();
+	virtual int set_prio(int seq, int maxseq);
 	virtual int nxt_tseq();
 	virtual int hdrsize(int nblks);
 	virtual int send_allowed(int);
@@ -289,6 +305,7 @@ protected:
 			h_seqno_ += amt;
 		FullTcpAgent::sent(seq, amt);
 	}
+	virtual int byterm();
 
 	int build_options(hdr_tcp*);	// insert opts, return len
 	int clear_on_timeout_;	// clear sender's SACK queue on RTX timeout?
@@ -309,4 +326,132 @@ protected:
 	int h_seqno_;		// next seq# to hole-fill
 };
 
+class MinTcpAgent : public SackFullTcpAgent {
+public:
+   virtual void timeout_action();
+   virtual double rtt_timeout();
+//   virtual void advance_bytes(int nb);
+};
+
+class DDTcpAgent : public SackFullTcpAgent {
+
+	virtual void slowdown(int how);			/* reduce cwnd/ssthresh */
+	virtual int byterm();
+	virtual int foutput(int seqno, int reason = 0); // output 1 packet
+	virtual int need_send();    		// send ACK/win-update now?
+
+};
+
 #endif
+
+
+class SolTCPAgent;
+
+class AgentPFCTimer : public TimerHandler {
+public:
+	AgentPFCTimer(SolTCPAgent *a=0) : TimerHandler() { a_ = a; }
+protected:
+	virtual void expire(Event *e);
+	SolTCPAgent *a_;
+	int id;
+};
+
+
+class SolTCPAgent: public SackFullTcpAgent
+{
+public:
+	//Protocol State: Stop - GO
+	enum EPrt_State
+	{
+		eInit=0, 	//Check whether we need a Request
+		eRQ,		//Waiting for the response
+		eSTOP,		//Stop signal is received
+		eGO			//Go signal is received
+	};
+	AgentPFCTimer m_pfcTimer;
+	SolTCPAgent():m_pfcTimer(this)
+	{
+		nPath = 0xFFFFFFFF; //Disable Path Select
+		bPathSelect=false;
+		prio_scheme_=1;
+		prio_num_=2;
+		m_nBW=10;//1Gbps
+//		bind("NI", &m_nBW);
+	}
+	virtual int command(int argc, const char*const* argv);
+	virtual void sendpacket(int seq, int ack, int flags, int dlen, int why, Packet *p=0);
+	virtual void delay_bind_init_all();
+	virtual int delay_bind_dispatch(const char *varName, const char *localName, TclObject *tracer);
+//	virtual int byterm();
+	virtual int need_send(int seqno=0);
+	void pfctimeout();
+	virtual void connect(){SackFullTcpAgent::connect();};
+//	virtual int set_prio(int seq, int maxseq);
+//	virtual int calPrio(int prio);
+public:
+	//Bottleneck BW: most likely it is equal to the End-Host's NI
+	int m_nBW;
+	//Indicates whether we should use a deterministic path.
+	bool bPathSelect;
+	int nPath;
+};
+
+class CtrTCPAgent;
+
+class CostTimer : public TimerHandler {
+public:
+	CostTimer(CtrTCPAgent*a=0) : TimerHandler() { a_ = a; }
+	void set(CtrTCPAgent*a){a_=a;};
+protected:
+	virtual void expire(Event *e);
+	CtrTCPAgent *a_;
+
+};
+
+class CtrTCPAgent: public SolTCPAgent
+{
+public:
+	CtrTCPAgent():SolTCPAgent(){ePrt_State=eInit;bpfc_state=PFC_NORMAL_STS;nStartTime=0;nPremptLastTime=0;SendRQTimer.set(this);dCost=0.0001;}
+	virtual int command(int argc, const char*const* argv);
+	virtual int foutput(int seqno, int reason = 0);
+	virtual void advance_bytes(int);
+	virtual void bufferempty();   		// called when sender buffer is empty
+	virtual void connect();
+
+	virtual void slowdown(int how);			/* reduce cwnd/ssthresh */
+
+	//First you need to send a request to controller, then if Go signal is returned to you, you are allowed to send that priority class.
+	//If not, you should wait: Do not send the flow!
+	void SendRequest();
+	void SetCost(double);
+
+	void SendRequestNow();
+	void RcvSignalGo(int nPath);
+	void RcvSignalStop();
+	void FirstTimeRun();
+	void Stop();
+	void ResetState();
+	void GetRemainSize();
+
+	int GetState(Packet* p);
+
+	virtual int fast_retransmit(int);  // do a fast-retransmit on specified seg
+
+	/**
+	 * Supporting MinTcp
+	 */
+	virtual void timeout(int tno); 	// tcp_timers() in real code
+	virtual void timeout_action();
+	virtual double rtt_timeout();
+
+public:
+	EPrt_State ePrt_State;
+	bool bpfc_state;
+
+	double nStartTime;
+	double nPremptLastTime;
+
+	double dCost;		//Default 100us.
+	CostTimer SendRQTimer;
+};
+
diff -rpuN ns-allinone-2.34.base/ns-2.34/tcp/tcp.h ns-allinone-2.34.hyline/ns-2.34/tcp/tcp.h
--- ns-allinone-2.34.base/ns-2.34/tcp/tcp.h	2009-06-14 13:35:44.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/tcp/tcp.h	2016-05-01 17:02:38.000000000 -0400
@@ -1,37 +1,3 @@
-/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */ /*
- * Copyright (c) 1991-1997 Regents of the University of California.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the Computer Systems
- *	Engineering Group at Lawrence Berkeley Laboratory.
- * 4. Neither the name of the University nor of the Laboratory may be used
- *    to endorse or promote products derived from this software without
- *    specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * @(#) $Header: /cvsroot/nsnam/ns-2/tcp/tcp.h,v 1.130 2007/09/29 01:07:22 sallyfloyd Exp $ (LBL)
- */
 #ifndef ns_tcp_h
 #define ns_tcp_h
 
@@ -104,6 +70,9 @@ struct hdr_tcp {
 #define CWND_HALF_WITH_MIN	0x00000200
 #define TCP_IDLE		0x00000400
 #define NO_OUTSTANDING_DATA     0x00000800
+#define CLOSE_SSTHRESH_ECNHAT   0x00001000
+#define CLOSE_CWND_ECNHAT       0x00002000
+
 
 /*
  * tcp_tick_:
@@ -194,7 +163,7 @@ protected:
 
 	virtual void delay_bind_init_all();
 	virtual int delay_bind_dispatch(const char *varName, const char *localName, TclObject *tracer);
-
+	
 	double boot_time_;	/* where between 'ticks' this sytem came up */
 	double overhead_;
 	double wnd_;
@@ -215,14 +184,14 @@ protected:
 				/* windows */
 
 	/* connection and packet dynamics */
-	virtual void output(int seqno, int reason = 0);
+virtual void output(int seqno, int reason = 0);
 	virtual void send_much(int force, int reason, int maxburst = 0);
 	virtual void newtimer(Packet*);
 	virtual void dupack_action();		/* do this on dupacks */
 	virtual void send_one();		/* do this on 1-2 dupacks */
 	virtual void opencwnd();
 
-	void slowdown(int how);			/* reduce cwnd/ssthresh */
+	virtual void slowdown(int how);			/* reduce cwnd/ssthresh */
 	void ecn(int seqno);		/* react to quench */
 	virtual void set_initial_window();	/* set IW */
 	double initial_window();		/* what is IW? */
@@ -316,7 +285,7 @@ protected:
 	void spurious_timeout();
 
 	/* Timers */
-	RtxTimer rtx_timer_;
+	RtxTimer rtx_timer_; 
 	DelSndTimer delsnd_timer_;
 	BurstSndTimer burstsnd_timer_;
 	virtual void cancel_timers() {
@@ -425,8 +394,37 @@ protected:
 	int useHeaders_;	/* boolean: Add TCP/IP header sizes */
 	/* end of specifying variants */
 
+	/**
+	 * : Added for MicroBenchmarking ...
+	 */
+	double nStartWaitTime;
+	double nPremptWaitTime;
+	int nNumPrempt;
+
 	/* Used for ECN */
 	int ecn_;		/* Explicit Congestion Notification */
+	
+	/* Mohammad: added for Ecn-Hat */
+	int ecnhat_;            
+	int ecnhat_smooth_alpha_;
+	double ecnhat_g_;
+	double ecnhat_alpha_;
+	int ecnhat_recalc_seq;
+	int ecnhat_maxseq;
+	int ecnhat_num_marked;
+	int ecnhat_total;
+	int ecnhat_enable_beta_;
+	double ecnhat_beta_;
+	int ecnhat_quadratic_beta_;
+	int ecnhat_tcp_friendly_;
+	double ecnhat_tcp_friendly_increase_;
+	int ecnhat_not_marked;
+	double ecnhat_mark_period;
+	int dctcp_enable_ap;
+	double target_wnd;
+
+	void update_ecnhat_alpha(Packet *pkt); /* updates the ecnhat alpha value */
+
 	int cong_action_;	/* Congestion Action.  True to indicate
 				   that the sender responded to congestion. */
         int ecn_burst_;		/* True when the previous ACK packet
diff -rpuN ns-allinone-2.34.base/ns-2.34/tcp/tcp-newreno.cc ns-allinone-2.34.hyline/ns-2.34/tcp/tcp-newreno.cc
--- ns-allinone-2.34.base/ns-2.34/tcp/tcp-newreno.cc	2009-06-14 13:35:44.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/tcp/tcp-newreno.cc	2016-05-01 17:02:22.000000000 -0400
@@ -144,7 +144,10 @@ NewRenoTcpAgent::dupack_action()
                  * all unnecessary Fast Retransmits.
                  */
                 reset_rtx_timer(1,0);
-                output(last_ack_ + 1, TCP_REASON_DUPACK);
+		/* Mohammad: cut window by half when we have 3 dup ack */
+		if (ecnhat_) 
+			slowdown(CLOSE_SSTHRESH_HALF|CLOSE_CWND_HALF); 
+                output(last_ack_ + 1, TCP_REASON_DUPACK);	
 		dupwnd_ = numdupacks_;
                 return;
         }
@@ -218,9 +221,14 @@ void NewRenoTcpAgent::recv(Packet *pkt,
         }
 	++nackpack_;
 	ts_peer_ = tcph->ts();
-
+	
+	
+	if (ecnhat_) 
+		update_ecnhat_alpha(pkt);
+	
 	if (hdr_flags::access(pkt)->ecnecho() && ecn_)
 		ecn(tcph->seqno());
+
 	recv_helper(pkt);
 	recv_frto_helper(pkt);
 	if (tcph->seqno() > last_ack_) {
diff -rpuN ns-allinone-2.34.base/ns-2.34/tcp/tcp-sink.cc ns-allinone-2.34.hyline/ns-2.34/tcp/tcp-sink.cc
--- ns-allinone-2.34.base/ns-2.34/tcp/tcp-sink.cc	2009-06-14 13:35:44.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/tcp/tcp-sink.cc	2016-05-01 17:02:22.000000000 -0400
@@ -189,6 +189,7 @@ TcpSink::TcpSink(Acker* acker) : Agent(P
 #if defined(TCP_DELAY_BIND_ALL) && 0
 #else /* ! TCP_DELAY_BIND_ALL */
 	bind("maxSackBlocks_", &max_sack_blocks_); // used only by sack
+	bind("ecnhat_", &ecnhat_);
 #endif /* TCP_DELAY_BIND_ALL */
 }
 
@@ -203,6 +204,7 @@ TcpSink::delay_bind_init_all()
 	delay_bind_init_one("qs_enabled_");
 	delay_bind_init_one("RFC2581_immediate_ack_");
 	delay_bind_init_one("ecn_syn_");
+	delay_bind_init_one("ecnhat_");
 #if defined(TCP_DELAY_BIND_ALL) && 0
         delay_bind_init_one("maxSackBlocks_");
 #endif /* TCP_DELAY_BIND_ALL */
@@ -220,6 +222,7 @@ TcpSink::delay_bind_dispatch(const char
         if (delay_bind_bool(varName, localName, "qs_enabled_", &qs_enabled_, tracer)) return TCL_OK;
         if (delay_bind_bool(varName, localName, "RFC2581_immediate_ack_", &RFC2581_immediate_ack_, tracer)) return TCL_OK;
 	if (delay_bind_bool(varName, localName, "ecn_syn_", &ecn_syn_ ,tracer)) return TCL_OK;
+	if (delay_bind_bool(varName, localName, "ecnhat_", &ecnhat_ ,tracer)) return TCL_OK;
 #if defined(TCP_DELAY_BIND_ALL) && 0
         if (delay_bind(varName, localName, "maxSackBlocks_", &max_sack_blocks_, tracer)) return TCL_OK;
 #endif /* TCP_DELAY_BIND_ALL */
@@ -321,9 +324,16 @@ void TcpSink::ack(Packet* opkt)
 			(of->ect() && of->ce()) )
 		// New report of congestion.  
 		acker_->update_ecn_unacked(1);
-	if ( (sf != 0 && sf->ect()) || of->ect() )
-		// Set EcnEcho bit.  
-		nf->ecnecho() = acker_->ecn_unacked();
+	if ( (sf != 0 && sf->ect()) || of->ect() ) {
+		// Set EcnEcho bit.
+		if (ecnhat_) {
+			if ( (sf != 0 && sf->ect() && sf->ce()) ||
+			     (of->ect() && of->ce()) )
+			     nf->ecnecho() = 1;
+			else
+			     nf->ecnecho() = 0;  			
+		} else nf->ecnecho() = acker_->ecn_unacked();
+	}
 	if (!of->ect() && of->ecnecho() ||
 		(sf != 0 && !sf->ect() && sf->ecnecho()) ) {
 		 // This is the negotiation for ECN-capability.
diff -rpuN ns-allinone-2.34.base/ns-2.34/tcp/tcp-sink.h ns-allinone-2.34.hyline/ns-2.34/tcp/tcp-sink.h
--- ns-allinone-2.34.base/ns-2.34/tcp/tcp-sink.h	2009-06-14 13:35:44.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/tcp/tcp-sink.h	2016-05-01 17:02:22.000000000 -0400
@@ -128,7 +128,7 @@ protected:
 	double lastreset_; 	/* W.N. used for detecting packets  */
 				/* from previous incarnations */
         int ecn_syn_;           /* allow SYN/ACK packets to be ECN-capable */
-
+	int ecnhat_;            /* Mohammad: added to enable ECNHAT receiver behavior */
 };
 
 class DelAckSink;
diff -rpuN ns-allinone-2.34.base/ns-2.34/tools/queue-monitor.cc ns-allinone-2.34.hyline/ns-2.34/tools/queue-monitor.cc
--- ns-allinone-2.34.base/ns-2.34/tools/queue-monitor.cc	2009-06-14 13:35:44.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/tools/queue-monitor.cc	2016-05-01 17:02:22.000000000 -0400
@@ -41,6 +41,8 @@ static const char rcsid[] =
 #include "trace.h"
 #include <math.h>
 
+#include "ip.h"
+
 int QueueMonitor::command(int argc, const char*const* argv)
 {
 	Tcl& tcl = Tcl::instance();
@@ -245,6 +247,20 @@ void QueueMonitor::in(Packet* p)
 		prevTime_ = now;
 	}
 
+	//Shuang: count small flow arrivals
+	hdr_ip* iph = hdr_ip::access(p);
+	int prio = iph->prio() / 1460;
+	if (prio < 100000 && pktsz > 100) {
+		karrivals_[calc_prio(prio)] ++;
+	}
+
+	//Shuang: count ack arrivals
+	//hdr_rcp* rh = hdr_rcp::access(p);
+	//if (rh->RCP_pkt_type() == RCP_ACK) {
+	//	ack_arrivals_++;
+	//}
+
+
 	barrivals_ += pktsz;
 	parrivals_++;
 	size_ += pktsz;
@@ -273,6 +289,13 @@ void QueueMonitor::out(Packet* p)
 	pkts_--;
 	bdepartures_ += pktsz;
 	pdepartures_++;
+	
+	//Shuang: count ack departure
+	//hdr_rcp* rh = hdr_rcp::access(p);
+	//if (rh->RCP_pkt_type() == RCP_ACK) {
+	//	ack_departures_++;
+	//}
+
 	if (bytesInt_)
 		bytesInt_->newPoint(now, double(size_));
 	if (pktsInt_)
@@ -302,6 +325,19 @@ void QueueMonitor::drop(Packet* p)
 	bdrops_ += pktsz;
 	pdrops_++;
 
+	//Shuang: count small flow dropping
+	hdr_ip* iph = hdr_ip::access(p);
+	int prio = iph->prio() / 1460;
+	if (prio < 100000 && pktsz > 100) {
+		kdrops_[calc_prio(prio)] ++;
+	}
+	//Shuang: count ack dropping
+	//hdr_rcp* rh = hdr_rcp::access(p);
+	//if (rh->RCP_pkt_type() == RCP_ACK) {
+	//	ack_drops_++;
+	//}
+
+
 	if (pf->qs())
 		qs_drops_++;
 
@@ -313,6 +349,20 @@ void QueueMonitor::drop(Packet* p)
 		printStats();
 }
 
+int QueueMonitor::calc_prio(int prio)
+{
+	if (prio <= 10)
+		return prio;
+	if (prio <= 100)
+		return 10 + prio / 10;
+	if (prio <= 1000)
+		return 20 + prio / 100;
+	if (prio <= 10000)
+		return 30 + prio / 1000;
+	if (prio <= 100000)
+		return 40 + prio / 10000;
+}
+
 // The procedure to estimate the rate of the incoming traffic
 void QueueMonitor::estimateRate(Packet *pkt) {
 	
@@ -448,7 +498,6 @@ public:
  * ############################################################
  */
 
-#include "ip.h"
 QueueMonitorCompat::QueueMonitorCompat()
 {
 	memset(pkts_, 0, sizeof(pkts_));
diff -rpuN ns-allinone-2.34.base/ns-2.34/tools/queue-monitor.h ns-allinone-2.34.hyline/ns-2.34/tools/queue-monitor.h
--- ns-allinone-2.34.base/ns-2.34/tools/queue-monitor.h	2009-06-14 13:35:44.000000000 -0400
+++ ns-allinone-2.34.hyline/ns-2.34/tools/queue-monitor.h	2016-05-01 17:02:22.000000000 -0400
@@ -49,7 +49,8 @@ public:
 		size_(0), pkts_(0),
 		parrivals_(0), barrivals_(0),
 		pdepartures_(0), bdepartures_(0),
-		pdrops_(0), pmarks_(0), bdrops_(0), 
+		pdrops_(0), pmarks_(0), bdrops_(0), num_monitor_(50),
+		ack_arrivals_(0), ack_drops_(0), ack_departures_(0),
 			 qs_pkts_(0), qs_bytes_(0), qs_drops_(0),
 		keepRTTstats_(0), maxRTT_(1), numRTTs_(0), binsPerSec_(10),
 		keepSeqnoStats_(0), maxSeqno_(1000), 
@@ -59,7 +60,22 @@ public:
 		k_(0.1), 
 		estRate_(0.0),
 		temp_size_(0) {
-		
+
+		//Shuang: monitor the kth drop
+		for (int i = 0; i < num_monitor_; i++) {
+			char buf[20];
+			memset(buf, 0, sizeof(buf));
+			sprintf(buf, "kdrops%d", i);
+			bind(buf, &kdrops_[i]);
+			memset(buf, 0, sizeof(buf));
+			sprintf(buf, "karrivals%d", i);
+			bind(buf, &karrivals_[i]);
+		}
+		bind("num_monitor_", &num_monitor_);
+		bind("ack_arrivals_", &ack_arrivals_);
+		bind("ack_drops_", &ack_drops_);
+		bind("ack_departures_", &ack_departures_);
+
 		bind("size_", &size_);
 		bind("pkts_", &pkts_);
 		bind("parrivals_", &parrivals_);
@@ -150,6 +166,12 @@ protected:
 	int pdrops_;
 	int pmarks_;
 	int bdrops_;
+	int kdrops_[50];	//Shuang: count the num of kth drop
+	int karrivals_[50];	//Shuang: count the num of kth arrival
+	int num_monitor_;	//Shuang: maximum of k to monitor
+	int ack_arrivals_;  //Shuang: number of ack pkts arrival
+	int ack_drops_;		//Shuang: number of ack pkts dropped
+	int ack_departures_;	//Shuang: number of ack pkts departured
 
 	int qs_pkts_;			/* Number of Quick-Start packets */
 	int qs_bytes_;			/* Number of Quick-Start bytes */
@@ -192,6 +214,7 @@ protected:
 	void estimateRate(Packet *p);
 	void keepRTTstats(Packet *p);
 	void keepSeqnoStats(Packet *p);
+	int calc_prio(int prio);
 };
 
 class SnoopQueue : public Connector {

